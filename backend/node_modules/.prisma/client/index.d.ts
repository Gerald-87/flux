
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model VendorSettings
 * 
 */
export type VendorSettings = $Result.DefaultSelection<Prisma.$VendorSettingsPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model CashierSchedule
 * 
 */
export type CashierSchedule = $Result.DefaultSelection<Prisma.$CashierSchedulePayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductVariant
 * 
 */
export type ProductVariant = $Result.DefaultSelection<Prisma.$ProductVariantPayload>
/**
 * Model ProductStockLocation
 * 
 */
export type ProductStockLocation = $Result.DefaultSelection<Prisma.$ProductStockLocationPayload>
/**
 * Model CashierProductAssignment
 * 
 */
export type CashierProductAssignment = $Result.DefaultSelection<Prisma.$CashierProductAssignmentPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Sale
 * 
 */
export type Sale = $Result.DefaultSelection<Prisma.$SalePayload>
/**
 * Model SaleItem
 * 
 */
export type SaleItem = $Result.DefaultSelection<Prisma.$SaleItemPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model PurchaseItem
 * 
 */
export type PurchaseItem = $Result.DefaultSelection<Prisma.$PurchaseItemPayload>
/**
 * Model StockMovement
 * 
 */
export type StockMovement = $Result.DefaultSelection<Prisma.$StockMovementPayload>
/**
 * Model StockTake
 * 
 */
export type StockTake = $Result.DefaultSelection<Prisma.$StockTakePayload>
/**
 * Model StockTakeItem
 * 
 */
export type StockTakeItem = $Result.DefaultSelection<Prisma.$StockTakeItemPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model SupportTicket
 * 
 */
export type SupportTicket = $Result.DefaultSelection<Prisma.$SupportTicketPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model PricingPlan
 * 
 */
export type PricingPlan = $Result.DefaultSelection<Prisma.$PricingPlanPayload>
/**
 * Model SystemSettings
 * 
 */
export type SystemSettings = $Result.DefaultSelection<Prisma.$SystemSettingsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SubscriptionPlan: {
  TRIAL: 'TRIAL',
  BASIC: 'BASIC',
  STANDARD: 'STANDARD',
  PREMIUM: 'PREMIUM'
};

export type SubscriptionPlan = (typeof SubscriptionPlan)[keyof typeof SubscriptionPlan]


export const SubscriptionStatus: {
  TRIALING: 'TRIALING',
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const UserRole: {
  SUPERADMIN: 'SUPERADMIN',
  VENDOR: 'VENDOR',
  CASHIER: 'CASHIER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const PaymentMethod: {
  CASH: 'CASH',
  CARD: 'CARD',
  MOBILE: 'MOBILE',
  LOYALTY: 'LOYALTY'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const SaleStatus: {
  COMPLETED: 'COMPLETED',
  REFUNDED: 'REFUNDED',
  PARTIAL_REFUND: 'PARTIAL_REFUND'
};

export type SaleStatus = (typeof SaleStatus)[keyof typeof SaleStatus]


export const PurchaseStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type PurchaseStatus = (typeof PurchaseStatus)[keyof typeof PurchaseStatus]


export const StockMovementType: {
  SALE: 'SALE',
  PURCHASE: 'PURCHASE',
  ADJUSTMENT: 'ADJUSTMENT',
  TRANSFER: 'TRANSFER',
  RETURN: 'RETURN'
};

export type StockMovementType = (typeof StockMovementType)[keyof typeof StockMovementType]


export const StockTakeStatus: {
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type StockTakeStatus = (typeof StockTakeStatus)[keyof typeof StockTakeStatus]


export const NotificationType: {
  LOW_STOCK: 'LOW_STOCK',
  PURCHASE_RECEIVED: 'PURCHASE_RECEIVED',
  STOCK_TAKE_COMPLETE: 'STOCK_TAKE_COMPLETE',
  SYSTEM: 'SYSTEM',
  TRANSFER_COMPLETE: 'TRANSFER_COMPLETE'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const TicketStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  CLOSED: 'CLOSED'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]


export const TicketPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type TicketPriority = (typeof TicketPriority)[keyof typeof TicketPriority]


export const ReportType: {
  SALES: 'SALES',
  INVENTORY: 'INVENTORY',
  CUSTOMER: 'CUSTOMER',
  PROFIT: 'PROFIT'
};

export type ReportType = (typeof ReportType)[keyof typeof ReportType]


export const ReportPeriod: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  YEARLY: 'YEARLY',
  CUSTOM: 'CUSTOM'
};

export type ReportPeriod = (typeof ReportPeriod)[keyof typeof ReportPeriod]

}

export type SubscriptionPlan = $Enums.SubscriptionPlan

export const SubscriptionPlan: typeof $Enums.SubscriptionPlan

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type SaleStatus = $Enums.SaleStatus

export const SaleStatus: typeof $Enums.SaleStatus

export type PurchaseStatus = $Enums.PurchaseStatus

export const PurchaseStatus: typeof $Enums.PurchaseStatus

export type StockMovementType = $Enums.StockMovementType

export const StockMovementType: typeof $Enums.StockMovementType

export type StockTakeStatus = $Enums.StockTakeStatus

export const StockTakeStatus: typeof $Enums.StockTakeStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

export type TicketPriority = $Enums.TicketPriority

export const TicketPriority: typeof $Enums.TicketPriority

export type ReportType = $Enums.ReportType

export const ReportType: typeof $Enums.ReportType

export type ReportPeriod = $Enums.ReportPeriod

export const ReportPeriod: typeof $Enums.ReportPeriod

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Vendors
 * const vendors = await prisma.vendor.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Vendors
   * const vendors = await prisma.vendor.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs>;

  /**
   * `prisma.vendorSettings`: Exposes CRUD operations for the **VendorSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorSettings
    * const vendorSettings = await prisma.vendorSettings.findMany()
    * ```
    */
  get vendorSettings(): Prisma.VendorSettingsDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.cashierSchedule`: Exposes CRUD operations for the **CashierSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashierSchedules
    * const cashierSchedules = await prisma.cashierSchedule.findMany()
    * ```
    */
  get cashierSchedule(): Prisma.CashierScheduleDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.productVariant`: Exposes CRUD operations for the **ProductVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductVariants
    * const productVariants = await prisma.productVariant.findMany()
    * ```
    */
  get productVariant(): Prisma.ProductVariantDelegate<ExtArgs>;

  /**
   * `prisma.productStockLocation`: Exposes CRUD operations for the **ProductStockLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductStockLocations
    * const productStockLocations = await prisma.productStockLocation.findMany()
    * ```
    */
  get productStockLocation(): Prisma.ProductStockLocationDelegate<ExtArgs>;

  /**
   * `prisma.cashierProductAssignment`: Exposes CRUD operations for the **CashierProductAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashierProductAssignments
    * const cashierProductAssignments = await prisma.cashierProductAssignment.findMany()
    * ```
    */
  get cashierProductAssignment(): Prisma.CashierProductAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs>;

  /**
   * `prisma.sale`: Exposes CRUD operations for the **Sale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales
    * const sales = await prisma.sale.findMany()
    * ```
    */
  get sale(): Prisma.SaleDelegate<ExtArgs>;

  /**
   * `prisma.saleItem`: Exposes CRUD operations for the **SaleItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleItems
    * const saleItems = await prisma.saleItem.findMany()
    * ```
    */
  get saleItem(): Prisma.SaleItemDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs>;

  /**
   * `prisma.purchaseItem`: Exposes CRUD operations for the **PurchaseItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseItems
    * const purchaseItems = await prisma.purchaseItem.findMany()
    * ```
    */
  get purchaseItem(): Prisma.PurchaseItemDelegate<ExtArgs>;

  /**
   * `prisma.stockMovement`: Exposes CRUD operations for the **StockMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockMovements
    * const stockMovements = await prisma.stockMovement.findMany()
    * ```
    */
  get stockMovement(): Prisma.StockMovementDelegate<ExtArgs>;

  /**
   * `prisma.stockTake`: Exposes CRUD operations for the **StockTake** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockTakes
    * const stockTakes = await prisma.stockTake.findMany()
    * ```
    */
  get stockTake(): Prisma.StockTakeDelegate<ExtArgs>;

  /**
   * `prisma.stockTakeItem`: Exposes CRUD operations for the **StockTakeItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockTakeItems
    * const stockTakeItems = await prisma.stockTakeItem.findMany()
    * ```
    */
  get stockTakeItem(): Prisma.StockTakeItemDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.supportTicket`: Exposes CRUD operations for the **SupportTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportTickets
    * const supportTickets = await prisma.supportTicket.findMany()
    * ```
    */
  get supportTicket(): Prisma.SupportTicketDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.pricingPlan`: Exposes CRUD operations for the **PricingPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PricingPlans
    * const pricingPlans = await prisma.pricingPlan.findMany()
    * ```
    */
  get pricingPlan(): Prisma.PricingPlanDelegate<ExtArgs>;

  /**
   * `prisma.systemSettings`: Exposes CRUD operations for the **SystemSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSettings.findMany()
    * ```
    */
  get systemSettings(): Prisma.SystemSettingsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Vendor: 'Vendor',
    VendorSettings: 'VendorSettings',
    User: 'User',
    CashierSchedule: 'CashierSchedule',
    Product: 'Product',
    ProductVariant: 'ProductVariant',
    ProductStockLocation: 'ProductStockLocation',
    CashierProductAssignment: 'CashierProductAssignment',
    Customer: 'Customer',
    Sale: 'Sale',
    SaleItem: 'SaleItem',
    Supplier: 'Supplier',
    Purchase: 'Purchase',
    PurchaseItem: 'PurchaseItem',
    StockMovement: 'StockMovement',
    StockTake: 'StockTake',
    StockTakeItem: 'StockTakeItem',
    Notification: 'Notification',
    AuditLog: 'AuditLog',
    SupportTicket: 'SupportTicket',
    Report: 'Report',
    PricingPlan: 'PricingPlan',
    SystemSettings: 'SystemSettings'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "vendor" | "vendorSettings" | "user" | "cashierSchedule" | "product" | "productVariant" | "productStockLocation" | "cashierProductAssignment" | "customer" | "sale" | "saleItem" | "supplier" | "purchase" | "purchaseItem" | "stockMovement" | "stockTake" | "stockTakeItem" | "notification" | "auditLog" | "supportTicket" | "report" | "pricingPlan" | "systemSettings"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      VendorSettings: {
        payload: Prisma.$VendorSettingsPayload<ExtArgs>
        fields: Prisma.VendorSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorSettingsPayload>
          }
          findFirst: {
            args: Prisma.VendorSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorSettingsPayload>
          }
          findMany: {
            args: Prisma.VendorSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorSettingsPayload>[]
          }
          create: {
            args: Prisma.VendorSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorSettingsPayload>
          }
          createMany: {
            args: Prisma.VendorSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VendorSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorSettingsPayload>
          }
          update: {
            args: Prisma.VendorSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorSettingsPayload>
          }
          deleteMany: {
            args: Prisma.VendorSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorSettingsPayload>
          }
          aggregate: {
            args: Prisma.VendorSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorSettings>
          }
          groupBy: {
            args: Prisma.VendorSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<VendorSettingsCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      CashierSchedule: {
        payload: Prisma.$CashierSchedulePayload<ExtArgs>
        fields: Prisma.CashierScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashierScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashierScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierSchedulePayload>
          }
          findFirst: {
            args: Prisma.CashierScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashierScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierSchedulePayload>
          }
          findMany: {
            args: Prisma.CashierScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierSchedulePayload>[]
          }
          create: {
            args: Prisma.CashierScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierSchedulePayload>
          }
          createMany: {
            args: Prisma.CashierScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CashierScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierSchedulePayload>
          }
          update: {
            args: Prisma.CashierScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierSchedulePayload>
          }
          deleteMany: {
            args: Prisma.CashierScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashierScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CashierScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierSchedulePayload>
          }
          aggregate: {
            args: Prisma.CashierScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashierSchedule>
          }
          groupBy: {
            args: Prisma.CashierScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashierScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashierScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<CashierScheduleCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductVariant: {
        payload: Prisma.$ProductVariantPayload<ExtArgs>
        fields: Prisma.ProductVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductVariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductVariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          findFirst: {
            args: Prisma.ProductVariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductVariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          findMany: {
            args: Prisma.ProductVariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          create: {
            args: Prisma.ProductVariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          createMany: {
            args: Prisma.ProductVariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductVariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          update: {
            args: Prisma.ProductVariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          deleteMany: {
            args: Prisma.ProductVariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductVariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductVariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          aggregate: {
            args: Prisma.ProductVariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductVariant>
          }
          groupBy: {
            args: Prisma.ProductVariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductVariantCountArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantCountAggregateOutputType> | number
          }
        }
      }
      ProductStockLocation: {
        payload: Prisma.$ProductStockLocationPayload<ExtArgs>
        fields: Prisma.ProductStockLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductStockLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductStockLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockLocationPayload>
          }
          findFirst: {
            args: Prisma.ProductStockLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductStockLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockLocationPayload>
          }
          findMany: {
            args: Prisma.ProductStockLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockLocationPayload>[]
          }
          create: {
            args: Prisma.ProductStockLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockLocationPayload>
          }
          createMany: {
            args: Prisma.ProductStockLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductStockLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockLocationPayload>
          }
          update: {
            args: Prisma.ProductStockLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockLocationPayload>
          }
          deleteMany: {
            args: Prisma.ProductStockLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductStockLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductStockLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockLocationPayload>
          }
          aggregate: {
            args: Prisma.ProductStockLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductStockLocation>
          }
          groupBy: {
            args: Prisma.ProductStockLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductStockLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductStockLocationCountArgs<ExtArgs>
            result: $Utils.Optional<ProductStockLocationCountAggregateOutputType> | number
          }
        }
      }
      CashierProductAssignment: {
        payload: Prisma.$CashierProductAssignmentPayload<ExtArgs>
        fields: Prisma.CashierProductAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashierProductAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierProductAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashierProductAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierProductAssignmentPayload>
          }
          findFirst: {
            args: Prisma.CashierProductAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierProductAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashierProductAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierProductAssignmentPayload>
          }
          findMany: {
            args: Prisma.CashierProductAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierProductAssignmentPayload>[]
          }
          create: {
            args: Prisma.CashierProductAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierProductAssignmentPayload>
          }
          createMany: {
            args: Prisma.CashierProductAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CashierProductAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierProductAssignmentPayload>
          }
          update: {
            args: Prisma.CashierProductAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierProductAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.CashierProductAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashierProductAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CashierProductAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashierProductAssignmentPayload>
          }
          aggregate: {
            args: Prisma.CashierProductAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashierProductAssignment>
          }
          groupBy: {
            args: Prisma.CashierProductAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashierProductAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashierProductAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<CashierProductAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Sale: {
        payload: Prisma.$SalePayload<ExtArgs>
        fields: Prisma.SaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findFirst: {
            args: Prisma.SaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findMany: {
            args: Prisma.SaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          create: {
            args: Prisma.SaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          createMany: {
            args: Prisma.SaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          update: {
            args: Prisma.SaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          deleteMany: {
            args: Prisma.SaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          aggregate: {
            args: Prisma.SaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSale>
          }
          groupBy: {
            args: Prisma.SaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleCountArgs<ExtArgs>
            result: $Utils.Optional<SaleCountAggregateOutputType> | number
          }
        }
      }
      SaleItem: {
        payload: Prisma.$SaleItemPayload<ExtArgs>
        fields: Prisma.SaleItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          findFirst: {
            args: Prisma.SaleItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          findMany: {
            args: Prisma.SaleItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>[]
          }
          create: {
            args: Prisma.SaleItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          createMany: {
            args: Prisma.SaleItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SaleItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          update: {
            args: Prisma.SaleItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          deleteMany: {
            args: Prisma.SaleItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaleItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          aggregate: {
            args: Prisma.SaleItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleItem>
          }
          groupBy: {
            args: Prisma.SaleItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleItemCountArgs<ExtArgs>
            result: $Utils.Optional<SaleItemCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          createMany: {
            args: Prisma.PurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      PurchaseItem: {
        payload: Prisma.$PurchaseItemPayload<ExtArgs>
        fields: Prisma.PurchaseItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PurchaseItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          update: {
            args: Prisma.PurchaseItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseItem>
          }
          groupBy: {
            args: Prisma.PurchaseItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseItemCountAggregateOutputType> | number
          }
        }
      }
      StockMovement: {
        payload: Prisma.$StockMovementPayload<ExtArgs>
        fields: Prisma.StockMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findFirst: {
            args: Prisma.StockMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findMany: {
            args: Prisma.StockMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
          }
          create: {
            args: Prisma.StockMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          createMany: {
            args: Prisma.StockMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StockMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          update: {
            args: Prisma.StockMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          deleteMany: {
            args: Prisma.StockMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          aggregate: {
            args: Prisma.StockMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockMovement>
          }
          groupBy: {
            args: Prisma.StockMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockMovementCountArgs<ExtArgs>
            result: $Utils.Optional<StockMovementCountAggregateOutputType> | number
          }
        }
      }
      StockTake: {
        payload: Prisma.$StockTakePayload<ExtArgs>
        fields: Prisma.StockTakeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockTakeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockTakeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakePayload>
          }
          findFirst: {
            args: Prisma.StockTakeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockTakeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakePayload>
          }
          findMany: {
            args: Prisma.StockTakeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakePayload>[]
          }
          create: {
            args: Prisma.StockTakeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakePayload>
          }
          createMany: {
            args: Prisma.StockTakeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StockTakeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakePayload>
          }
          update: {
            args: Prisma.StockTakeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakePayload>
          }
          deleteMany: {
            args: Prisma.StockTakeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockTakeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockTakeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakePayload>
          }
          aggregate: {
            args: Prisma.StockTakeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockTake>
          }
          groupBy: {
            args: Prisma.StockTakeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockTakeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockTakeCountArgs<ExtArgs>
            result: $Utils.Optional<StockTakeCountAggregateOutputType> | number
          }
        }
      }
      StockTakeItem: {
        payload: Prisma.$StockTakeItemPayload<ExtArgs>
        fields: Prisma.StockTakeItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockTakeItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakeItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockTakeItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakeItemPayload>
          }
          findFirst: {
            args: Prisma.StockTakeItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakeItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockTakeItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakeItemPayload>
          }
          findMany: {
            args: Prisma.StockTakeItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakeItemPayload>[]
          }
          create: {
            args: Prisma.StockTakeItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakeItemPayload>
          }
          createMany: {
            args: Prisma.StockTakeItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StockTakeItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakeItemPayload>
          }
          update: {
            args: Prisma.StockTakeItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakeItemPayload>
          }
          deleteMany: {
            args: Prisma.StockTakeItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockTakeItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockTakeItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTakeItemPayload>
          }
          aggregate: {
            args: Prisma.StockTakeItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockTakeItem>
          }
          groupBy: {
            args: Prisma.StockTakeItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockTakeItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockTakeItemCountArgs<ExtArgs>
            result: $Utils.Optional<StockTakeItemCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      SupportTicket: {
        payload: Prisma.$SupportTicketPayload<ExtArgs>
        fields: Prisma.SupportTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findFirst: {
            args: Prisma.SupportTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findMany: {
            args: Prisma.SupportTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          create: {
            args: Prisma.SupportTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          createMany: {
            args: Prisma.SupportTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SupportTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          update: {
            args: Prisma.SupportTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          deleteMany: {
            args: Prisma.SupportTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupportTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          aggregate: {
            args: Prisma.SupportTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportTicket>
          }
          groupBy: {
            args: Prisma.SupportTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportTicketCountArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      PricingPlan: {
        payload: Prisma.$PricingPlanPayload<ExtArgs>
        fields: Prisma.PricingPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PricingPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PricingPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          findFirst: {
            args: Prisma.PricingPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PricingPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          findMany: {
            args: Prisma.PricingPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>[]
          }
          create: {
            args: Prisma.PricingPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          createMany: {
            args: Prisma.PricingPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PricingPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          update: {
            args: Prisma.PricingPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          deleteMany: {
            args: Prisma.PricingPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PricingPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PricingPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          aggregate: {
            args: Prisma.PricingPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePricingPlan>
          }
          groupBy: {
            args: Prisma.PricingPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PricingPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PricingPlanCountArgs<ExtArgs>
            result: $Utils.Optional<PricingPlanCountAggregateOutputType> | number
          }
        }
      }
      SystemSettings: {
        payload: Prisma.$SystemSettingsPayload<ExtArgs>
        fields: Prisma.SystemSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findMany: {
            args: Prisma.SystemSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          create: {
            args: Prisma.SystemSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          createMany: {
            args: Prisma.SystemSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          update: {
            args: Prisma.SystemSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSettings>
          }
          groupBy: {
            args: Prisma.SystemSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type VendorCountOutputType
   */

  export type VendorCountOutputType = {
    users: number
    products: number
    customers: number
    sales: number
    suppliers: number
    purchases: number
    stockMovements: number
    stockTakes: number
    notifications: number
    auditLogs: number
    supportTickets: number
    reports: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | VendorCountOutputTypeCountUsersArgs
    products?: boolean | VendorCountOutputTypeCountProductsArgs
    customers?: boolean | VendorCountOutputTypeCountCustomersArgs
    sales?: boolean | VendorCountOutputTypeCountSalesArgs
    suppliers?: boolean | VendorCountOutputTypeCountSuppliersArgs
    purchases?: boolean | VendorCountOutputTypeCountPurchasesArgs
    stockMovements?: boolean | VendorCountOutputTypeCountStockMovementsArgs
    stockTakes?: boolean | VendorCountOutputTypeCountStockTakesArgs
    notifications?: boolean | VendorCountOutputTypeCountNotificationsArgs
    auditLogs?: boolean | VendorCountOutputTypeCountAuditLogsArgs
    supportTickets?: boolean | VendorCountOutputTypeCountSupportTicketsArgs
    reports?: boolean | VendorCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountStockTakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTakeWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountSupportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sales: number
    stockMovements: number
    stockTakes: number
    auditLogs: number
    reports: number
    productAssignments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | UserCountOutputTypeCountSalesArgs
    stockMovements?: boolean | UserCountOutputTypeCountStockMovementsArgs
    stockTakes?: boolean | UserCountOutputTypeCountStockTakesArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    reports?: boolean | UserCountOutputTypeCountReportsArgs
    productAssignments?: boolean | UserCountOutputTypeCountProductAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStockTakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTakeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashierProductAssignmentWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    variants: number
    stockLocations: number
    saleItems: number
    purchaseItems: number
    stockMovements: number
    stockTakeItems: number
    cashierAssignments: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | ProductCountOutputTypeCountVariantsArgs
    stockLocations?: boolean | ProductCountOutputTypeCountStockLocationsArgs
    saleItems?: boolean | ProductCountOutputTypeCountSaleItemsArgs
    purchaseItems?: boolean | ProductCountOutputTypeCountPurchaseItemsArgs
    stockMovements?: boolean | ProductCountOutputTypeCountStockMovementsArgs
    stockTakeItems?: boolean | ProductCountOutputTypeCountStockTakeItemsArgs
    cashierAssignments?: boolean | ProductCountOutputTypeCountCashierAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStockLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStockLocationWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSaleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStockTakeItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTakeItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCashierAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashierProductAssignmentWhereInput
  }


  /**
   * Count Type ProductVariantCountOutputType
   */

  export type ProductVariantCountOutputType = {
    stockLocations: number
    saleItems: number
    purchaseItems: number
    stockMovements: number
    stockTakeItems: number
  }

  export type ProductVariantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockLocations?: boolean | ProductVariantCountOutputTypeCountStockLocationsArgs
    saleItems?: boolean | ProductVariantCountOutputTypeCountSaleItemsArgs
    purchaseItems?: boolean | ProductVariantCountOutputTypeCountPurchaseItemsArgs
    stockMovements?: boolean | ProductVariantCountOutputTypeCountStockMovementsArgs
    stockTakeItems?: boolean | ProductVariantCountOutputTypeCountStockTakeItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantCountOutputType
     */
    select?: ProductVariantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountStockLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStockLocationWhereInput
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountSaleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountPurchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountStockTakeItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTakeItemWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    sales: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | CustomerCountOutputTypeCountSalesArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }


  /**
   * Count Type SaleCountOutputType
   */

  export type SaleCountOutputType = {
    items: number
  }

  export type SaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SaleCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleCountOutputType
     */
    select?: SaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    purchases: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | SupplierCountOutputTypeCountPurchasesArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }


  /**
   * Count Type PurchaseCountOutputType
   */

  export type PurchaseCountOutputType = {
    items: number
  }

  export type PurchaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseCountOutputType
     */
    select?: PurchaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
  }


  /**
   * Count Type StockTakeCountOutputType
   */

  export type StockTakeCountOutputType = {
    items: number
  }

  export type StockTakeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | StockTakeCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * StockTakeCountOutputType without action
   */
  export type StockTakeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTakeCountOutputType
     */
    select?: StockTakeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StockTakeCountOutputType without action
   */
  export type StockTakeCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTakeItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    businessType: string | null
    subscriptionPlan: $Enums.SubscriptionPlan | null
    subscriptionStatus: $Enums.SubscriptionStatus | null
    subscriptionExpiry: Date | null
    isApproved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    businessType: string | null
    subscriptionPlan: $Enums.SubscriptionPlan | null
    subscriptionStatus: $Enums.SubscriptionStatus | null
    subscriptionExpiry: Date | null
    isApproved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    address: number
    businessType: number
    subscriptionPlan: number
    subscriptionStatus: number
    subscriptionExpiry: number
    isApproved: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    businessType?: true
    subscriptionPlan?: true
    subscriptionStatus?: true
    subscriptionExpiry?: true
    isApproved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    businessType?: true
    subscriptionPlan?: true
    subscriptionStatus?: true
    subscriptionExpiry?: true
    isApproved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    businessType?: true
    subscriptionPlan?: true
    subscriptionStatus?: true
    subscriptionExpiry?: true
    isApproved?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    address: string | null
    businessType: string | null
    subscriptionPlan: $Enums.SubscriptionPlan
    subscriptionStatus: $Enums.SubscriptionStatus
    subscriptionExpiry: Date | null
    isApproved: boolean
    createdAt: Date
    updatedAt: Date
    _count: VendorCountAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    businessType?: boolean
    subscriptionPlan?: boolean
    subscriptionStatus?: boolean
    subscriptionExpiry?: boolean
    isApproved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Vendor$usersArgs<ExtArgs>
    products?: boolean | Vendor$productsArgs<ExtArgs>
    customers?: boolean | Vendor$customersArgs<ExtArgs>
    sales?: boolean | Vendor$salesArgs<ExtArgs>
    suppliers?: boolean | Vendor$suppliersArgs<ExtArgs>
    purchases?: boolean | Vendor$purchasesArgs<ExtArgs>
    stockMovements?: boolean | Vendor$stockMovementsArgs<ExtArgs>
    stockTakes?: boolean | Vendor$stockTakesArgs<ExtArgs>
    notifications?: boolean | Vendor$notificationsArgs<ExtArgs>
    auditLogs?: boolean | Vendor$auditLogsArgs<ExtArgs>
    supportTickets?: boolean | Vendor$supportTicketsArgs<ExtArgs>
    reports?: boolean | Vendor$reportsArgs<ExtArgs>
    vendorSettings?: boolean | Vendor$vendorSettingsArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>


  export type VendorSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    businessType?: boolean
    subscriptionPlan?: boolean
    subscriptionStatus?: boolean
    subscriptionExpiry?: boolean
    isApproved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Vendor$usersArgs<ExtArgs>
    products?: boolean | Vendor$productsArgs<ExtArgs>
    customers?: boolean | Vendor$customersArgs<ExtArgs>
    sales?: boolean | Vendor$salesArgs<ExtArgs>
    suppliers?: boolean | Vendor$suppliersArgs<ExtArgs>
    purchases?: boolean | Vendor$purchasesArgs<ExtArgs>
    stockMovements?: boolean | Vendor$stockMovementsArgs<ExtArgs>
    stockTakes?: boolean | Vendor$stockTakesArgs<ExtArgs>
    notifications?: boolean | Vendor$notificationsArgs<ExtArgs>
    auditLogs?: boolean | Vendor$auditLogsArgs<ExtArgs>
    supportTickets?: boolean | Vendor$supportTicketsArgs<ExtArgs>
    reports?: boolean | Vendor$reportsArgs<ExtArgs>
    vendorSettings?: boolean | Vendor$vendorSettingsArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      sales: Prisma.$SalePayload<ExtArgs>[]
      suppliers: Prisma.$SupplierPayload<ExtArgs>[]
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
      stockMovements: Prisma.$StockMovementPayload<ExtArgs>[]
      stockTakes: Prisma.$StockTakePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      supportTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      vendorSettings: Prisma.$VendorSettingsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      address: string | null
      businessType: string | null
      subscriptionPlan: $Enums.SubscriptionPlan
      subscriptionStatus: $Enums.SubscriptionStatus
      subscriptionExpiry: Date | null
      isApproved: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Vendor$usersArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends Vendor$productsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    customers<T extends Vendor$customersArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany"> | Null>
    sales<T extends Vendor$salesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany"> | Null>
    suppliers<T extends Vendor$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany"> | Null>
    purchases<T extends Vendor$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany"> | Null>
    stockMovements<T extends Vendor$stockMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$stockMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany"> | Null>
    stockTakes<T extends Vendor$stockTakesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$stockTakesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTakePayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends Vendor$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends Vendor$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    supportTickets<T extends Vendor$supportTicketsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$supportTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends Vendor$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    vendorSettings<T extends Vendor$vendorSettingsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$vendorSettingsArgs<ExtArgs>>): Prisma__VendorSettingsClient<$Result.GetResult<Prisma.$VendorSettingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */ 
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'String'>
    readonly name: FieldRef<"Vendor", 'String'>
    readonly email: FieldRef<"Vendor", 'String'>
    readonly phone: FieldRef<"Vendor", 'String'>
    readonly address: FieldRef<"Vendor", 'String'>
    readonly businessType: FieldRef<"Vendor", 'String'>
    readonly subscriptionPlan: FieldRef<"Vendor", 'SubscriptionPlan'>
    readonly subscriptionStatus: FieldRef<"Vendor", 'SubscriptionStatus'>
    readonly subscriptionExpiry: FieldRef<"Vendor", 'DateTime'>
    readonly isApproved: FieldRef<"Vendor", 'Boolean'>
    readonly createdAt: FieldRef<"Vendor", 'DateTime'>
    readonly updatedAt: FieldRef<"Vendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
  }

  /**
   * Vendor.users
   */
  export type Vendor$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Vendor.products
   */
  export type Vendor$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Vendor.customers
   */
  export type Vendor$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Vendor.sales
   */
  export type Vendor$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Vendor.suppliers
   */
  export type Vendor$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    cursor?: SupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Vendor.purchases
   */
  export type Vendor$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Vendor.stockMovements
   */
  export type Vendor$stockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * Vendor.stockTakes
   */
  export type Vendor$stockTakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTake
     */
    select?: StockTakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeInclude<ExtArgs> | null
    where?: StockTakeWhereInput
    orderBy?: StockTakeOrderByWithRelationInput | StockTakeOrderByWithRelationInput[]
    cursor?: StockTakeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTakeScalarFieldEnum | StockTakeScalarFieldEnum[]
  }

  /**
   * Vendor.notifications
   */
  export type Vendor$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Vendor.auditLogs
   */
  export type Vendor$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Vendor.supportTickets
   */
  export type Vendor$supportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * Vendor.reports
   */
  export type Vendor$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Vendor.vendorSettings
   */
  export type Vendor$vendorSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorSettings
     */
    select?: VendorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorSettingsInclude<ExtArgs> | null
    where?: VendorSettingsWhereInput
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model VendorSettings
   */

  export type AggregateVendorSettings = {
    _count: VendorSettingsCountAggregateOutputType | null
    _avg: VendorSettingsAvgAggregateOutputType | null
    _sum: VendorSettingsSumAggregateOutputType | null
    _min: VendorSettingsMinAggregateOutputType | null
    _max: VendorSettingsMaxAggregateOutputType | null
  }

  export type VendorSettingsAvgAggregateOutputType = {
    taxRate: Decimal | null
    loyaltyPointsPerDollar: Decimal | null
    loyaltyRedemptionRate: Decimal | null
    loyaltyMinimumPoints: number | null
    lowStockThreshold: number | null
  }

  export type VendorSettingsSumAggregateOutputType = {
    taxRate: Decimal | null
    loyaltyPointsPerDollar: Decimal | null
    loyaltyRedemptionRate: Decimal | null
    loyaltyMinimumPoints: number | null
    lowStockThreshold: number | null
  }

  export type VendorSettingsMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    taxRate: Decimal | null
    currency: string | null
    timezone: string | null
    receiptHeader: string | null
    receiptFooter: string | null
    loyaltyEnabled: boolean | null
    loyaltyPointsPerDollar: Decimal | null
    loyaltyRedemptionRate: Decimal | null
    loyaltyMinimumPoints: number | null
    lowStockAlert: boolean | null
    lowStockThreshold: number | null
    emailNotifications: boolean | null
    smsNotifications: boolean | null
    dailyReports: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorSettingsMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    taxRate: Decimal | null
    currency: string | null
    timezone: string | null
    receiptHeader: string | null
    receiptFooter: string | null
    loyaltyEnabled: boolean | null
    loyaltyPointsPerDollar: Decimal | null
    loyaltyRedemptionRate: Decimal | null
    loyaltyMinimumPoints: number | null
    lowStockAlert: boolean | null
    lowStockThreshold: number | null
    emailNotifications: boolean | null
    smsNotifications: boolean | null
    dailyReports: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorSettingsCountAggregateOutputType = {
    id: number
    vendorId: number
    taxRate: number
    currency: number
    timezone: number
    receiptHeader: number
    receiptFooter: number
    loyaltyEnabled: number
    loyaltyPointsPerDollar: number
    loyaltyRedemptionRate: number
    loyaltyMinimumPoints: number
    lowStockAlert: number
    lowStockThreshold: number
    emailNotifications: number
    smsNotifications: number
    dailyReports: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorSettingsAvgAggregateInputType = {
    taxRate?: true
    loyaltyPointsPerDollar?: true
    loyaltyRedemptionRate?: true
    loyaltyMinimumPoints?: true
    lowStockThreshold?: true
  }

  export type VendorSettingsSumAggregateInputType = {
    taxRate?: true
    loyaltyPointsPerDollar?: true
    loyaltyRedemptionRate?: true
    loyaltyMinimumPoints?: true
    lowStockThreshold?: true
  }

  export type VendorSettingsMinAggregateInputType = {
    id?: true
    vendorId?: true
    taxRate?: true
    currency?: true
    timezone?: true
    receiptHeader?: true
    receiptFooter?: true
    loyaltyEnabled?: true
    loyaltyPointsPerDollar?: true
    loyaltyRedemptionRate?: true
    loyaltyMinimumPoints?: true
    lowStockAlert?: true
    lowStockThreshold?: true
    emailNotifications?: true
    smsNotifications?: true
    dailyReports?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorSettingsMaxAggregateInputType = {
    id?: true
    vendorId?: true
    taxRate?: true
    currency?: true
    timezone?: true
    receiptHeader?: true
    receiptFooter?: true
    loyaltyEnabled?: true
    loyaltyPointsPerDollar?: true
    loyaltyRedemptionRate?: true
    loyaltyMinimumPoints?: true
    lowStockAlert?: true
    lowStockThreshold?: true
    emailNotifications?: true
    smsNotifications?: true
    dailyReports?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorSettingsCountAggregateInputType = {
    id?: true
    vendorId?: true
    taxRate?: true
    currency?: true
    timezone?: true
    receiptHeader?: true
    receiptFooter?: true
    loyaltyEnabled?: true
    loyaltyPointsPerDollar?: true
    loyaltyRedemptionRate?: true
    loyaltyMinimumPoints?: true
    lowStockAlert?: true
    lowStockThreshold?: true
    emailNotifications?: true
    smsNotifications?: true
    dailyReports?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorSettings to aggregate.
     */
    where?: VendorSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorSettings to fetch.
     */
    orderBy?: VendorSettingsOrderByWithRelationInput | VendorSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorSettings
    **/
    _count?: true | VendorSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorSettingsMaxAggregateInputType
  }

  export type GetVendorSettingsAggregateType<T extends VendorSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorSettings[P]>
      : GetScalarType<T[P], AggregateVendorSettings[P]>
  }




  export type VendorSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorSettingsWhereInput
    orderBy?: VendorSettingsOrderByWithAggregationInput | VendorSettingsOrderByWithAggregationInput[]
    by: VendorSettingsScalarFieldEnum[] | VendorSettingsScalarFieldEnum
    having?: VendorSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorSettingsCountAggregateInputType | true
    _avg?: VendorSettingsAvgAggregateInputType
    _sum?: VendorSettingsSumAggregateInputType
    _min?: VendorSettingsMinAggregateInputType
    _max?: VendorSettingsMaxAggregateInputType
  }

  export type VendorSettingsGroupByOutputType = {
    id: string
    vendorId: string
    taxRate: Decimal
    currency: string
    timezone: string
    receiptHeader: string | null
    receiptFooter: string | null
    loyaltyEnabled: boolean
    loyaltyPointsPerDollar: Decimal
    loyaltyRedemptionRate: Decimal
    loyaltyMinimumPoints: number
    lowStockAlert: boolean
    lowStockThreshold: number
    emailNotifications: boolean
    smsNotifications: boolean
    dailyReports: boolean
    createdAt: Date
    updatedAt: Date
    _count: VendorSettingsCountAggregateOutputType | null
    _avg: VendorSettingsAvgAggregateOutputType | null
    _sum: VendorSettingsSumAggregateOutputType | null
    _min: VendorSettingsMinAggregateOutputType | null
    _max: VendorSettingsMaxAggregateOutputType | null
  }

  type GetVendorSettingsGroupByPayload<T extends VendorSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], VendorSettingsGroupByOutputType[P]>
        }
      >
    >


  export type VendorSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    taxRate?: boolean
    currency?: boolean
    timezone?: boolean
    receiptHeader?: boolean
    receiptFooter?: boolean
    loyaltyEnabled?: boolean
    loyaltyPointsPerDollar?: boolean
    loyaltyRedemptionRate?: boolean
    loyaltyMinimumPoints?: boolean
    lowStockAlert?: boolean
    lowStockThreshold?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    dailyReports?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorSettings"]>


  export type VendorSettingsSelectScalar = {
    id?: boolean
    vendorId?: boolean
    taxRate?: boolean
    currency?: boolean
    timezone?: boolean
    receiptHeader?: boolean
    receiptFooter?: boolean
    loyaltyEnabled?: boolean
    loyaltyPointsPerDollar?: boolean
    loyaltyRedemptionRate?: boolean
    loyaltyMinimumPoints?: boolean
    lowStockAlert?: boolean
    lowStockThreshold?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    dailyReports?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $VendorSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorSettings"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      taxRate: Prisma.Decimal
      currency: string
      timezone: string
      receiptHeader: string | null
      receiptFooter: string | null
      loyaltyEnabled: boolean
      loyaltyPointsPerDollar: Prisma.Decimal
      loyaltyRedemptionRate: Prisma.Decimal
      loyaltyMinimumPoints: number
      lowStockAlert: boolean
      lowStockThreshold: number
      emailNotifications: boolean
      smsNotifications: boolean
      dailyReports: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendorSettings"]>
    composites: {}
  }

  type VendorSettingsGetPayload<S extends boolean | null | undefined | VendorSettingsDefaultArgs> = $Result.GetResult<Prisma.$VendorSettingsPayload, S>

  type VendorSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VendorSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VendorSettingsCountAggregateInputType | true
    }

  export interface VendorSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorSettings'], meta: { name: 'VendorSettings' } }
    /**
     * Find zero or one VendorSettings that matches the filter.
     * @param {VendorSettingsFindUniqueArgs} args - Arguments to find a VendorSettings
     * @example
     * // Get one VendorSettings
     * const vendorSettings = await prisma.vendorSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorSettingsFindUniqueArgs>(args: SelectSubset<T, VendorSettingsFindUniqueArgs<ExtArgs>>): Prisma__VendorSettingsClient<$Result.GetResult<Prisma.$VendorSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VendorSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VendorSettingsFindUniqueOrThrowArgs} args - Arguments to find a VendorSettings
     * @example
     * // Get one VendorSettings
     * const vendorSettings = await prisma.vendorSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorSettingsClient<$Result.GetResult<Prisma.$VendorSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VendorSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorSettingsFindFirstArgs} args - Arguments to find a VendorSettings
     * @example
     * // Get one VendorSettings
     * const vendorSettings = await prisma.vendorSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorSettingsFindFirstArgs>(args?: SelectSubset<T, VendorSettingsFindFirstArgs<ExtArgs>>): Prisma__VendorSettingsClient<$Result.GetResult<Prisma.$VendorSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VendorSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorSettingsFindFirstOrThrowArgs} args - Arguments to find a VendorSettings
     * @example
     * // Get one VendorSettings
     * const vendorSettings = await prisma.vendorSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorSettingsClient<$Result.GetResult<Prisma.$VendorSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VendorSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorSettings
     * const vendorSettings = await prisma.vendorSettings.findMany()
     * 
     * // Get first 10 VendorSettings
     * const vendorSettings = await prisma.vendorSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorSettingsWithIdOnly = await prisma.vendorSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorSettingsFindManyArgs>(args?: SelectSubset<T, VendorSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VendorSettings.
     * @param {VendorSettingsCreateArgs} args - Arguments to create a VendorSettings.
     * @example
     * // Create one VendorSettings
     * const VendorSettings = await prisma.vendorSettings.create({
     *   data: {
     *     // ... data to create a VendorSettings
     *   }
     * })
     * 
     */
    create<T extends VendorSettingsCreateArgs>(args: SelectSubset<T, VendorSettingsCreateArgs<ExtArgs>>): Prisma__VendorSettingsClient<$Result.GetResult<Prisma.$VendorSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VendorSettings.
     * @param {VendorSettingsCreateManyArgs} args - Arguments to create many VendorSettings.
     * @example
     * // Create many VendorSettings
     * const vendorSettings = await prisma.vendorSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorSettingsCreateManyArgs>(args?: SelectSubset<T, VendorSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VendorSettings.
     * @param {VendorSettingsDeleteArgs} args - Arguments to delete one VendorSettings.
     * @example
     * // Delete one VendorSettings
     * const VendorSettings = await prisma.vendorSettings.delete({
     *   where: {
     *     // ... filter to delete one VendorSettings
     *   }
     * })
     * 
     */
    delete<T extends VendorSettingsDeleteArgs>(args: SelectSubset<T, VendorSettingsDeleteArgs<ExtArgs>>): Prisma__VendorSettingsClient<$Result.GetResult<Prisma.$VendorSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VendorSettings.
     * @param {VendorSettingsUpdateArgs} args - Arguments to update one VendorSettings.
     * @example
     * // Update one VendorSettings
     * const vendorSettings = await prisma.vendorSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorSettingsUpdateArgs>(args: SelectSubset<T, VendorSettingsUpdateArgs<ExtArgs>>): Prisma__VendorSettingsClient<$Result.GetResult<Prisma.$VendorSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VendorSettings.
     * @param {VendorSettingsDeleteManyArgs} args - Arguments to filter VendorSettings to delete.
     * @example
     * // Delete a few VendorSettings
     * const { count } = await prisma.vendorSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorSettingsDeleteManyArgs>(args?: SelectSubset<T, VendorSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorSettings
     * const vendorSettings = await prisma.vendorSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorSettingsUpdateManyArgs>(args: SelectSubset<T, VendorSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VendorSettings.
     * @param {VendorSettingsUpsertArgs} args - Arguments to update or create a VendorSettings.
     * @example
     * // Update or create a VendorSettings
     * const vendorSettings = await prisma.vendorSettings.upsert({
     *   create: {
     *     // ... data to create a VendorSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorSettings we want to update
     *   }
     * })
     */
    upsert<T extends VendorSettingsUpsertArgs>(args: SelectSubset<T, VendorSettingsUpsertArgs<ExtArgs>>): Prisma__VendorSettingsClient<$Result.GetResult<Prisma.$VendorSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VendorSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorSettingsCountArgs} args - Arguments to filter VendorSettings to count.
     * @example
     * // Count the number of VendorSettings
     * const count = await prisma.vendorSettings.count({
     *   where: {
     *     // ... the filter for the VendorSettings we want to count
     *   }
     * })
    **/
    count<T extends VendorSettingsCountArgs>(
      args?: Subset<T, VendorSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorSettingsAggregateArgs>(args: Subset<T, VendorSettingsAggregateArgs>): Prisma.PrismaPromise<GetVendorSettingsAggregateType<T>>

    /**
     * Group by VendorSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorSettingsGroupByArgs['orderBy'] }
        : { orderBy?: VendorSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorSettings model
   */
  readonly fields: VendorSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorSettings model
   */ 
  interface VendorSettingsFieldRefs {
    readonly id: FieldRef<"VendorSettings", 'String'>
    readonly vendorId: FieldRef<"VendorSettings", 'String'>
    readonly taxRate: FieldRef<"VendorSettings", 'Decimal'>
    readonly currency: FieldRef<"VendorSettings", 'String'>
    readonly timezone: FieldRef<"VendorSettings", 'String'>
    readonly receiptHeader: FieldRef<"VendorSettings", 'String'>
    readonly receiptFooter: FieldRef<"VendorSettings", 'String'>
    readonly loyaltyEnabled: FieldRef<"VendorSettings", 'Boolean'>
    readonly loyaltyPointsPerDollar: FieldRef<"VendorSettings", 'Decimal'>
    readonly loyaltyRedemptionRate: FieldRef<"VendorSettings", 'Decimal'>
    readonly loyaltyMinimumPoints: FieldRef<"VendorSettings", 'Int'>
    readonly lowStockAlert: FieldRef<"VendorSettings", 'Boolean'>
    readonly lowStockThreshold: FieldRef<"VendorSettings", 'Int'>
    readonly emailNotifications: FieldRef<"VendorSettings", 'Boolean'>
    readonly smsNotifications: FieldRef<"VendorSettings", 'Boolean'>
    readonly dailyReports: FieldRef<"VendorSettings", 'Boolean'>
    readonly createdAt: FieldRef<"VendorSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"VendorSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorSettings findUnique
   */
  export type VendorSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorSettings
     */
    select?: VendorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorSettingsInclude<ExtArgs> | null
    /**
     * Filter, which VendorSettings to fetch.
     */
    where: VendorSettingsWhereUniqueInput
  }

  /**
   * VendorSettings findUniqueOrThrow
   */
  export type VendorSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorSettings
     */
    select?: VendorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorSettingsInclude<ExtArgs> | null
    /**
     * Filter, which VendorSettings to fetch.
     */
    where: VendorSettingsWhereUniqueInput
  }

  /**
   * VendorSettings findFirst
   */
  export type VendorSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorSettings
     */
    select?: VendorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorSettingsInclude<ExtArgs> | null
    /**
     * Filter, which VendorSettings to fetch.
     */
    where?: VendorSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorSettings to fetch.
     */
    orderBy?: VendorSettingsOrderByWithRelationInput | VendorSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorSettings.
     */
    cursor?: VendorSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorSettings.
     */
    distinct?: VendorSettingsScalarFieldEnum | VendorSettingsScalarFieldEnum[]
  }

  /**
   * VendorSettings findFirstOrThrow
   */
  export type VendorSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorSettings
     */
    select?: VendorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorSettingsInclude<ExtArgs> | null
    /**
     * Filter, which VendorSettings to fetch.
     */
    where?: VendorSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorSettings to fetch.
     */
    orderBy?: VendorSettingsOrderByWithRelationInput | VendorSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorSettings.
     */
    cursor?: VendorSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorSettings.
     */
    distinct?: VendorSettingsScalarFieldEnum | VendorSettingsScalarFieldEnum[]
  }

  /**
   * VendorSettings findMany
   */
  export type VendorSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorSettings
     */
    select?: VendorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorSettingsInclude<ExtArgs> | null
    /**
     * Filter, which VendorSettings to fetch.
     */
    where?: VendorSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorSettings to fetch.
     */
    orderBy?: VendorSettingsOrderByWithRelationInput | VendorSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorSettings.
     */
    cursor?: VendorSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorSettings.
     */
    skip?: number
    distinct?: VendorSettingsScalarFieldEnum | VendorSettingsScalarFieldEnum[]
  }

  /**
   * VendorSettings create
   */
  export type VendorSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorSettings
     */
    select?: VendorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorSettings.
     */
    data: XOR<VendorSettingsCreateInput, VendorSettingsUncheckedCreateInput>
  }

  /**
   * VendorSettings createMany
   */
  export type VendorSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorSettings.
     */
    data: VendorSettingsCreateManyInput | VendorSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorSettings update
   */
  export type VendorSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorSettings
     */
    select?: VendorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorSettings.
     */
    data: XOR<VendorSettingsUpdateInput, VendorSettingsUncheckedUpdateInput>
    /**
     * Choose, which VendorSettings to update.
     */
    where: VendorSettingsWhereUniqueInput
  }

  /**
   * VendorSettings updateMany
   */
  export type VendorSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorSettings.
     */
    data: XOR<VendorSettingsUpdateManyMutationInput, VendorSettingsUncheckedUpdateManyInput>
    /**
     * Filter which VendorSettings to update
     */
    where?: VendorSettingsWhereInput
  }

  /**
   * VendorSettings upsert
   */
  export type VendorSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorSettings
     */
    select?: VendorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorSettings to update in case it exists.
     */
    where: VendorSettingsWhereUniqueInput
    /**
     * In case the VendorSettings found by the `where` argument doesn't exist, create a new VendorSettings with this data.
     */
    create: XOR<VendorSettingsCreateInput, VendorSettingsUncheckedCreateInput>
    /**
     * In case the VendorSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorSettingsUpdateInput, VendorSettingsUncheckedUpdateInput>
  }

  /**
   * VendorSettings delete
   */
  export type VendorSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorSettings
     */
    select?: VendorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorSettingsInclude<ExtArgs> | null
    /**
     * Filter which VendorSettings to delete.
     */
    where: VendorSettingsWhereUniqueInput
  }

  /**
   * VendorSettings deleteMany
   */
  export type VendorSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorSettings to delete
     */
    where?: VendorSettingsWhereInput
  }

  /**
   * VendorSettings without action
   */
  export type VendorSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorSettings
     */
    select?: VendorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorSettingsInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    vendorId: string | null
    name: string | null
    avatar: string | null
    isActive: boolean | null
    terminalId: string | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    vendorId: string | null
    name: string | null
    avatar: string | null
    isActive: boolean | null
    terminalId: string | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    role: number
    vendorId: number
    name: number
    avatar: number
    isActive: number
    terminalId: number
    assignedLocations: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    vendorId?: true
    name?: true
    avatar?: true
    isActive?: true
    terminalId?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    vendorId?: true
    name?: true
    avatar?: true
    isActive?: true
    terminalId?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    vendorId?: true
    name?: true
    avatar?: true
    isActive?: true
    terminalId?: true
    assignedLocations?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    vendorId: string | null
    name: string
    avatar: string | null
    isActive: boolean
    terminalId: string | null
    assignedLocations: JsonValue | null
    lastLogin: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    vendorId?: boolean
    name?: boolean
    avatar?: boolean
    isActive?: boolean
    terminalId?: boolean
    assignedLocations?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | User$vendorArgs<ExtArgs>
    cashierSchedule?: boolean | User$cashierScheduleArgs<ExtArgs>
    sales?: boolean | User$salesArgs<ExtArgs>
    stockMovements?: boolean | User$stockMovementsArgs<ExtArgs>
    stockTakes?: boolean | User$stockTakesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    productAssignments?: boolean | User$productAssignmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    vendorId?: boolean
    name?: boolean
    avatar?: boolean
    isActive?: boolean
    terminalId?: boolean
    assignedLocations?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | User$vendorArgs<ExtArgs>
    cashierSchedule?: boolean | User$cashierScheduleArgs<ExtArgs>
    sales?: boolean | User$salesArgs<ExtArgs>
    stockMovements?: boolean | User$stockMovementsArgs<ExtArgs>
    stockTakes?: boolean | User$stockTakesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    productAssignments?: boolean | User$productAssignmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs> | null
      cashierSchedule: Prisma.$CashierSchedulePayload<ExtArgs> | null
      sales: Prisma.$SalePayload<ExtArgs>[]
      stockMovements: Prisma.$StockMovementPayload<ExtArgs>[]
      stockTakes: Prisma.$StockTakePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      productAssignments: Prisma.$CashierProductAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      role: $Enums.UserRole
      vendorId: string | null
      name: string
      avatar: string | null
      isActive: boolean
      terminalId: string | null
      assignedLocations: Prisma.JsonValue | null
      lastLogin: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends User$vendorArgs<ExtArgs> = {}>(args?: Subset<T, User$vendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    cashierSchedule<T extends User$cashierScheduleArgs<ExtArgs> = {}>(args?: Subset<T, User$cashierScheduleArgs<ExtArgs>>): Prisma__CashierScheduleClient<$Result.GetResult<Prisma.$CashierSchedulePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sales<T extends User$salesArgs<ExtArgs> = {}>(args?: Subset<T, User$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany"> | Null>
    stockMovements<T extends User$stockMovementsArgs<ExtArgs> = {}>(args?: Subset<T, User$stockMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany"> | Null>
    stockTakes<T extends User$stockTakesArgs<ExtArgs> = {}>(args?: Subset<T, User$stockTakesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTakePayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends User$reportsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    productAssignments<T extends User$productAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$productAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashierProductAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly vendorId: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly terminalId: FieldRef<"User", 'String'>
    readonly assignedLocations: FieldRef<"User", 'Json'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.vendor
   */
  export type User$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * User.cashierSchedule
   */
  export type User$cashierScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierSchedule
     */
    select?: CashierScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierScheduleInclude<ExtArgs> | null
    where?: CashierScheduleWhereInput
  }

  /**
   * User.sales
   */
  export type User$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * User.stockMovements
   */
  export type User$stockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * User.stockTakes
   */
  export type User$stockTakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTake
     */
    select?: StockTakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeInclude<ExtArgs> | null
    where?: StockTakeWhereInput
    orderBy?: StockTakeOrderByWithRelationInput | StockTakeOrderByWithRelationInput[]
    cursor?: StockTakeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTakeScalarFieldEnum | StockTakeScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.reports
   */
  export type User$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.productAssignments
   */
  export type User$productAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierProductAssignment
     */
    select?: CashierProductAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierProductAssignmentInclude<ExtArgs> | null
    where?: CashierProductAssignmentWhereInput
    orderBy?: CashierProductAssignmentOrderByWithRelationInput | CashierProductAssignmentOrderByWithRelationInput[]
    cursor?: CashierProductAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashierProductAssignmentScalarFieldEnum | CashierProductAssignmentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model CashierSchedule
   */

  export type AggregateCashierSchedule = {
    _count: CashierScheduleCountAggregateOutputType | null
    _min: CashierScheduleMinAggregateOutputType | null
    _max: CashierScheduleMaxAggregateOutputType | null
  }

  export type CashierScheduleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    checkInTime: string | null
    checkOutTime: string | null
    timezone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashierScheduleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    checkInTime: string | null
    checkOutTime: string | null
    timezone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashierScheduleCountAggregateOutputType = {
    id: number
    userId: number
    checkInTime: number
    checkOutTime: number
    workDays: number
    timezone: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CashierScheduleMinAggregateInputType = {
    id?: true
    userId?: true
    checkInTime?: true
    checkOutTime?: true
    timezone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashierScheduleMaxAggregateInputType = {
    id?: true
    userId?: true
    checkInTime?: true
    checkOutTime?: true
    timezone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashierScheduleCountAggregateInputType = {
    id?: true
    userId?: true
    checkInTime?: true
    checkOutTime?: true
    workDays?: true
    timezone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CashierScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashierSchedule to aggregate.
     */
    where?: CashierScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashierSchedules to fetch.
     */
    orderBy?: CashierScheduleOrderByWithRelationInput | CashierScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashierScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashierSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashierSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashierSchedules
    **/
    _count?: true | CashierScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashierScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashierScheduleMaxAggregateInputType
  }

  export type GetCashierScheduleAggregateType<T extends CashierScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateCashierSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashierSchedule[P]>
      : GetScalarType<T[P], AggregateCashierSchedule[P]>
  }




  export type CashierScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashierScheduleWhereInput
    orderBy?: CashierScheduleOrderByWithAggregationInput | CashierScheduleOrderByWithAggregationInput[]
    by: CashierScheduleScalarFieldEnum[] | CashierScheduleScalarFieldEnum
    having?: CashierScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashierScheduleCountAggregateInputType | true
    _min?: CashierScheduleMinAggregateInputType
    _max?: CashierScheduleMaxAggregateInputType
  }

  export type CashierScheduleGroupByOutputType = {
    id: string
    userId: string
    checkInTime: string
    checkOutTime: string
    workDays: JsonValue
    timezone: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CashierScheduleCountAggregateOutputType | null
    _min: CashierScheduleMinAggregateOutputType | null
    _max: CashierScheduleMaxAggregateOutputType | null
  }

  type GetCashierScheduleGroupByPayload<T extends CashierScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashierScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashierScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashierScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], CashierScheduleGroupByOutputType[P]>
        }
      >
    >


  export type CashierScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    workDays?: boolean
    timezone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashierSchedule"]>


  export type CashierScheduleSelectScalar = {
    id?: boolean
    userId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    workDays?: boolean
    timezone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CashierScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CashierSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashierSchedule"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      checkInTime: string
      checkOutTime: string
      workDays: Prisma.JsonValue
      timezone: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cashierSchedule"]>
    composites: {}
  }

  type CashierScheduleGetPayload<S extends boolean | null | undefined | CashierScheduleDefaultArgs> = $Result.GetResult<Prisma.$CashierSchedulePayload, S>

  type CashierScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CashierScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CashierScheduleCountAggregateInputType | true
    }

  export interface CashierScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashierSchedule'], meta: { name: 'CashierSchedule' } }
    /**
     * Find zero or one CashierSchedule that matches the filter.
     * @param {CashierScheduleFindUniqueArgs} args - Arguments to find a CashierSchedule
     * @example
     * // Get one CashierSchedule
     * const cashierSchedule = await prisma.cashierSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashierScheduleFindUniqueArgs>(args: SelectSubset<T, CashierScheduleFindUniqueArgs<ExtArgs>>): Prisma__CashierScheduleClient<$Result.GetResult<Prisma.$CashierSchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CashierSchedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CashierScheduleFindUniqueOrThrowArgs} args - Arguments to find a CashierSchedule
     * @example
     * // Get one CashierSchedule
     * const cashierSchedule = await prisma.cashierSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashierScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, CashierScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashierScheduleClient<$Result.GetResult<Prisma.$CashierSchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CashierSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierScheduleFindFirstArgs} args - Arguments to find a CashierSchedule
     * @example
     * // Get one CashierSchedule
     * const cashierSchedule = await prisma.cashierSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashierScheduleFindFirstArgs>(args?: SelectSubset<T, CashierScheduleFindFirstArgs<ExtArgs>>): Prisma__CashierScheduleClient<$Result.GetResult<Prisma.$CashierSchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CashierSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierScheduleFindFirstOrThrowArgs} args - Arguments to find a CashierSchedule
     * @example
     * // Get one CashierSchedule
     * const cashierSchedule = await prisma.cashierSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashierScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, CashierScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashierScheduleClient<$Result.GetResult<Prisma.$CashierSchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CashierSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashierSchedules
     * const cashierSchedules = await prisma.cashierSchedule.findMany()
     * 
     * // Get first 10 CashierSchedules
     * const cashierSchedules = await prisma.cashierSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashierScheduleWithIdOnly = await prisma.cashierSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashierScheduleFindManyArgs>(args?: SelectSubset<T, CashierScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashierSchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CashierSchedule.
     * @param {CashierScheduleCreateArgs} args - Arguments to create a CashierSchedule.
     * @example
     * // Create one CashierSchedule
     * const CashierSchedule = await prisma.cashierSchedule.create({
     *   data: {
     *     // ... data to create a CashierSchedule
     *   }
     * })
     * 
     */
    create<T extends CashierScheduleCreateArgs>(args: SelectSubset<T, CashierScheduleCreateArgs<ExtArgs>>): Prisma__CashierScheduleClient<$Result.GetResult<Prisma.$CashierSchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CashierSchedules.
     * @param {CashierScheduleCreateManyArgs} args - Arguments to create many CashierSchedules.
     * @example
     * // Create many CashierSchedules
     * const cashierSchedule = await prisma.cashierSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashierScheduleCreateManyArgs>(args?: SelectSubset<T, CashierScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CashierSchedule.
     * @param {CashierScheduleDeleteArgs} args - Arguments to delete one CashierSchedule.
     * @example
     * // Delete one CashierSchedule
     * const CashierSchedule = await prisma.cashierSchedule.delete({
     *   where: {
     *     // ... filter to delete one CashierSchedule
     *   }
     * })
     * 
     */
    delete<T extends CashierScheduleDeleteArgs>(args: SelectSubset<T, CashierScheduleDeleteArgs<ExtArgs>>): Prisma__CashierScheduleClient<$Result.GetResult<Prisma.$CashierSchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CashierSchedule.
     * @param {CashierScheduleUpdateArgs} args - Arguments to update one CashierSchedule.
     * @example
     * // Update one CashierSchedule
     * const cashierSchedule = await prisma.cashierSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashierScheduleUpdateArgs>(args: SelectSubset<T, CashierScheduleUpdateArgs<ExtArgs>>): Prisma__CashierScheduleClient<$Result.GetResult<Prisma.$CashierSchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CashierSchedules.
     * @param {CashierScheduleDeleteManyArgs} args - Arguments to filter CashierSchedules to delete.
     * @example
     * // Delete a few CashierSchedules
     * const { count } = await prisma.cashierSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashierScheduleDeleteManyArgs>(args?: SelectSubset<T, CashierScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashierSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashierSchedules
     * const cashierSchedule = await prisma.cashierSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashierScheduleUpdateManyArgs>(args: SelectSubset<T, CashierScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CashierSchedule.
     * @param {CashierScheduleUpsertArgs} args - Arguments to update or create a CashierSchedule.
     * @example
     * // Update or create a CashierSchedule
     * const cashierSchedule = await prisma.cashierSchedule.upsert({
     *   create: {
     *     // ... data to create a CashierSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashierSchedule we want to update
     *   }
     * })
     */
    upsert<T extends CashierScheduleUpsertArgs>(args: SelectSubset<T, CashierScheduleUpsertArgs<ExtArgs>>): Prisma__CashierScheduleClient<$Result.GetResult<Prisma.$CashierSchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CashierSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierScheduleCountArgs} args - Arguments to filter CashierSchedules to count.
     * @example
     * // Count the number of CashierSchedules
     * const count = await prisma.cashierSchedule.count({
     *   where: {
     *     // ... the filter for the CashierSchedules we want to count
     *   }
     * })
    **/
    count<T extends CashierScheduleCountArgs>(
      args?: Subset<T, CashierScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashierScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashierSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashierScheduleAggregateArgs>(args: Subset<T, CashierScheduleAggregateArgs>): Prisma.PrismaPromise<GetCashierScheduleAggregateType<T>>

    /**
     * Group by CashierSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashierScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashierScheduleGroupByArgs['orderBy'] }
        : { orderBy?: CashierScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashierScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashierScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashierSchedule model
   */
  readonly fields: CashierScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashierSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashierScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashierSchedule model
   */ 
  interface CashierScheduleFieldRefs {
    readonly id: FieldRef<"CashierSchedule", 'String'>
    readonly userId: FieldRef<"CashierSchedule", 'String'>
    readonly checkInTime: FieldRef<"CashierSchedule", 'String'>
    readonly checkOutTime: FieldRef<"CashierSchedule", 'String'>
    readonly workDays: FieldRef<"CashierSchedule", 'Json'>
    readonly timezone: FieldRef<"CashierSchedule", 'String'>
    readonly isActive: FieldRef<"CashierSchedule", 'Boolean'>
    readonly createdAt: FieldRef<"CashierSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"CashierSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashierSchedule findUnique
   */
  export type CashierScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierSchedule
     */
    select?: CashierScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CashierSchedule to fetch.
     */
    where: CashierScheduleWhereUniqueInput
  }

  /**
   * CashierSchedule findUniqueOrThrow
   */
  export type CashierScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierSchedule
     */
    select?: CashierScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CashierSchedule to fetch.
     */
    where: CashierScheduleWhereUniqueInput
  }

  /**
   * CashierSchedule findFirst
   */
  export type CashierScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierSchedule
     */
    select?: CashierScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CashierSchedule to fetch.
     */
    where?: CashierScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashierSchedules to fetch.
     */
    orderBy?: CashierScheduleOrderByWithRelationInput | CashierScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashierSchedules.
     */
    cursor?: CashierScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashierSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashierSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashierSchedules.
     */
    distinct?: CashierScheduleScalarFieldEnum | CashierScheduleScalarFieldEnum[]
  }

  /**
   * CashierSchedule findFirstOrThrow
   */
  export type CashierScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierSchedule
     */
    select?: CashierScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CashierSchedule to fetch.
     */
    where?: CashierScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashierSchedules to fetch.
     */
    orderBy?: CashierScheduleOrderByWithRelationInput | CashierScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashierSchedules.
     */
    cursor?: CashierScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashierSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashierSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashierSchedules.
     */
    distinct?: CashierScheduleScalarFieldEnum | CashierScheduleScalarFieldEnum[]
  }

  /**
   * CashierSchedule findMany
   */
  export type CashierScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierSchedule
     */
    select?: CashierScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CashierSchedules to fetch.
     */
    where?: CashierScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashierSchedules to fetch.
     */
    orderBy?: CashierScheduleOrderByWithRelationInput | CashierScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashierSchedules.
     */
    cursor?: CashierScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashierSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashierSchedules.
     */
    skip?: number
    distinct?: CashierScheduleScalarFieldEnum | CashierScheduleScalarFieldEnum[]
  }

  /**
   * CashierSchedule create
   */
  export type CashierScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierSchedule
     */
    select?: CashierScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a CashierSchedule.
     */
    data: XOR<CashierScheduleCreateInput, CashierScheduleUncheckedCreateInput>
  }

  /**
   * CashierSchedule createMany
   */
  export type CashierScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashierSchedules.
     */
    data: CashierScheduleCreateManyInput | CashierScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashierSchedule update
   */
  export type CashierScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierSchedule
     */
    select?: CashierScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a CashierSchedule.
     */
    data: XOR<CashierScheduleUpdateInput, CashierScheduleUncheckedUpdateInput>
    /**
     * Choose, which CashierSchedule to update.
     */
    where: CashierScheduleWhereUniqueInput
  }

  /**
   * CashierSchedule updateMany
   */
  export type CashierScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashierSchedules.
     */
    data: XOR<CashierScheduleUpdateManyMutationInput, CashierScheduleUncheckedUpdateManyInput>
    /**
     * Filter which CashierSchedules to update
     */
    where?: CashierScheduleWhereInput
  }

  /**
   * CashierSchedule upsert
   */
  export type CashierScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierSchedule
     */
    select?: CashierScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the CashierSchedule to update in case it exists.
     */
    where: CashierScheduleWhereUniqueInput
    /**
     * In case the CashierSchedule found by the `where` argument doesn't exist, create a new CashierSchedule with this data.
     */
    create: XOR<CashierScheduleCreateInput, CashierScheduleUncheckedCreateInput>
    /**
     * In case the CashierSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashierScheduleUpdateInput, CashierScheduleUncheckedUpdateInput>
  }

  /**
   * CashierSchedule delete
   */
  export type CashierScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierSchedule
     */
    select?: CashierScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierScheduleInclude<ExtArgs> | null
    /**
     * Filter which CashierSchedule to delete.
     */
    where: CashierScheduleWhereUniqueInput
  }

  /**
   * CashierSchedule deleteMany
   */
  export type CashierScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashierSchedules to delete
     */
    where?: CashierScheduleWhereInput
  }

  /**
   * CashierSchedule without action
   */
  export type CashierScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierSchedule
     */
    select?: CashierScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierScheduleInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: Decimal | null
    costPrice: Decimal | null
    totalStock: number | null
    minStock: number | null
    maxStock: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: Decimal | null
    costPrice: Decimal | null
    totalStock: number | null
    minStock: number | null
    maxStock: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    name: string | null
    description: string | null
    sku: string | null
    barcode: string | null
    category: string | null
    brand: string | null
    price: Decimal | null
    costPrice: Decimal | null
    totalStock: number | null
    minStock: number | null
    maxStock: number | null
    unit: string | null
    isActive: boolean | null
    expiryDate: Date | null
    trackExpiry: boolean | null
    trackSerial: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    name: string | null
    description: string | null
    sku: string | null
    barcode: string | null
    category: string | null
    brand: string | null
    price: Decimal | null
    costPrice: Decimal | null
    totalStock: number | null
    minStock: number | null
    maxStock: number | null
    unit: string | null
    isActive: boolean | null
    expiryDate: Date | null
    trackExpiry: boolean | null
    trackSerial: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    vendorId: number
    name: number
    description: number
    sku: number
    barcode: number
    category: number
    brand: number
    price: number
    costPrice: number
    totalStock: number
    minStock: number
    maxStock: number
    unit: number
    images: number
    isActive: number
    expiryDate: number
    trackExpiry: number
    trackSerial: number
    tags: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    costPrice?: true
    totalStock?: true
    minStock?: true
    maxStock?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    costPrice?: true
    totalStock?: true
    minStock?: true
    maxStock?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    description?: true
    sku?: true
    barcode?: true
    category?: true
    brand?: true
    price?: true
    costPrice?: true
    totalStock?: true
    minStock?: true
    maxStock?: true
    unit?: true
    isActive?: true
    expiryDate?: true
    trackExpiry?: true
    trackSerial?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    description?: true
    sku?: true
    barcode?: true
    category?: true
    brand?: true
    price?: true
    costPrice?: true
    totalStock?: true
    minStock?: true
    maxStock?: true
    unit?: true
    isActive?: true
    expiryDate?: true
    trackExpiry?: true
    trackSerial?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    description?: true
    sku?: true
    barcode?: true
    category?: true
    brand?: true
    price?: true
    costPrice?: true
    totalStock?: true
    minStock?: true
    maxStock?: true
    unit?: true
    images?: true
    isActive?: true
    expiryDate?: true
    trackExpiry?: true
    trackSerial?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    vendorId: string
    name: string
    description: string | null
    sku: string
    barcode: string | null
    category: string | null
    brand: string | null
    price: Decimal
    costPrice: Decimal
    totalStock: number
    minStock: number
    maxStock: number
    unit: string
    images: JsonValue | null
    isActive: boolean
    expiryDate: Date | null
    trackExpiry: boolean
    trackSerial: boolean
    tags: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    name?: boolean
    description?: boolean
    sku?: boolean
    barcode?: boolean
    category?: boolean
    brand?: boolean
    price?: boolean
    costPrice?: boolean
    totalStock?: boolean
    minStock?: boolean
    maxStock?: boolean
    unit?: boolean
    images?: boolean
    isActive?: boolean
    expiryDate?: boolean
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    variants?: boolean | Product$variantsArgs<ExtArgs>
    stockLocations?: boolean | Product$stockLocationsArgs<ExtArgs>
    saleItems?: boolean | Product$saleItemsArgs<ExtArgs>
    purchaseItems?: boolean | Product$purchaseItemsArgs<ExtArgs>
    stockMovements?: boolean | Product$stockMovementsArgs<ExtArgs>
    stockTakeItems?: boolean | Product$stockTakeItemsArgs<ExtArgs>
    cashierAssignments?: boolean | Product$cashierAssignmentsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>


  export type ProductSelectScalar = {
    id?: boolean
    vendorId?: boolean
    name?: boolean
    description?: boolean
    sku?: boolean
    barcode?: boolean
    category?: boolean
    brand?: boolean
    price?: boolean
    costPrice?: boolean
    totalStock?: boolean
    minStock?: boolean
    maxStock?: boolean
    unit?: boolean
    images?: boolean
    isActive?: boolean
    expiryDate?: boolean
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    variants?: boolean | Product$variantsArgs<ExtArgs>
    stockLocations?: boolean | Product$stockLocationsArgs<ExtArgs>
    saleItems?: boolean | Product$saleItemsArgs<ExtArgs>
    purchaseItems?: boolean | Product$purchaseItemsArgs<ExtArgs>
    stockMovements?: boolean | Product$stockMovementsArgs<ExtArgs>
    stockTakeItems?: boolean | Product$stockTakeItemsArgs<ExtArgs>
    cashierAssignments?: boolean | Product$cashierAssignmentsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      variants: Prisma.$ProductVariantPayload<ExtArgs>[]
      stockLocations: Prisma.$ProductStockLocationPayload<ExtArgs>[]
      saleItems: Prisma.$SaleItemPayload<ExtArgs>[]
      purchaseItems: Prisma.$PurchaseItemPayload<ExtArgs>[]
      stockMovements: Prisma.$StockMovementPayload<ExtArgs>[]
      stockTakeItems: Prisma.$StockTakeItemPayload<ExtArgs>[]
      cashierAssignments: Prisma.$CashierProductAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      name: string
      description: string | null
      sku: string
      barcode: string | null
      category: string | null
      brand: string | null
      price: Prisma.Decimal
      costPrice: Prisma.Decimal
      totalStock: number
      minStock: number
      maxStock: number
      unit: string
      images: Prisma.JsonValue | null
      isActive: boolean
      expiryDate: Date | null
      trackExpiry: boolean
      trackSerial: boolean
      tags: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    variants<T extends Product$variantsArgs<ExtArgs> = {}>(args?: Subset<T, Product$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findMany"> | Null>
    stockLocations<T extends Product$stockLocationsArgs<ExtArgs> = {}>(args?: Subset<T, Product$stockLocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockLocationPayload<ExtArgs>, T, "findMany"> | Null>
    saleItems<T extends Product$saleItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$saleItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany"> | Null>
    purchaseItems<T extends Product$purchaseItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$purchaseItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany"> | Null>
    stockMovements<T extends Product$stockMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Product$stockMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany"> | Null>
    stockTakeItems<T extends Product$stockTakeItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$stockTakeItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTakeItemPayload<ExtArgs>, T, "findMany"> | Null>
    cashierAssignments<T extends Product$cashierAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Product$cashierAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashierProductAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly vendorId: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly barcode: FieldRef<"Product", 'String'>
    readonly category: FieldRef<"Product", 'String'>
    readonly brand: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Decimal'>
    readonly costPrice: FieldRef<"Product", 'Decimal'>
    readonly totalStock: FieldRef<"Product", 'Int'>
    readonly minStock: FieldRef<"Product", 'Int'>
    readonly maxStock: FieldRef<"Product", 'Int'>
    readonly unit: FieldRef<"Product", 'String'>
    readonly images: FieldRef<"Product", 'Json'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly expiryDate: FieldRef<"Product", 'DateTime'>
    readonly trackExpiry: FieldRef<"Product", 'Boolean'>
    readonly trackSerial: FieldRef<"Product", 'Boolean'>
    readonly tags: FieldRef<"Product", 'Json'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.variants
   */
  export type Product$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    where?: ProductVariantWhereInput
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    cursor?: ProductVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * Product.stockLocations
   */
  export type Product$stockLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockLocation
     */
    select?: ProductStockLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockLocationInclude<ExtArgs> | null
    where?: ProductStockLocationWhereInput
    orderBy?: ProductStockLocationOrderByWithRelationInput | ProductStockLocationOrderByWithRelationInput[]
    cursor?: ProductStockLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductStockLocationScalarFieldEnum | ProductStockLocationScalarFieldEnum[]
  }

  /**
   * Product.saleItems
   */
  export type Product$saleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    cursor?: SaleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * Product.purchaseItems
   */
  export type Product$purchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    cursor?: PurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * Product.stockMovements
   */
  export type Product$stockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * Product.stockTakeItems
   */
  export type Product$stockTakeItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTakeItem
     */
    select?: StockTakeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeItemInclude<ExtArgs> | null
    where?: StockTakeItemWhereInput
    orderBy?: StockTakeItemOrderByWithRelationInput | StockTakeItemOrderByWithRelationInput[]
    cursor?: StockTakeItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTakeItemScalarFieldEnum | StockTakeItemScalarFieldEnum[]
  }

  /**
   * Product.cashierAssignments
   */
  export type Product$cashierAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierProductAssignment
     */
    select?: CashierProductAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierProductAssignmentInclude<ExtArgs> | null
    where?: CashierProductAssignmentWhereInput
    orderBy?: CashierProductAssignmentOrderByWithRelationInput | CashierProductAssignmentOrderByWithRelationInput[]
    cursor?: CashierProductAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashierProductAssignmentScalarFieldEnum | CashierProductAssignmentScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductVariant
   */

  export type AggregateProductVariant = {
    _count: ProductVariantCountAggregateOutputType | null
    _avg: ProductVariantAvgAggregateOutputType | null
    _sum: ProductVariantSumAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  export type ProductVariantAvgAggregateOutputType = {
    priceModifier: Decimal | null
    stock: number | null
  }

  export type ProductVariantSumAggregateOutputType = {
    priceModifier: Decimal | null
    stock: number | null
  }

  export type ProductVariantMinAggregateOutputType = {
    id: string | null
    productId: string | null
    name: string | null
    value: string | null
    priceModifier: Decimal | null
    stock: number | null
    sku: string | null
    barcode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    name: string | null
    value: string | null
    priceModifier: Decimal | null
    stock: number | null
    sku: string | null
    barcode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantCountAggregateOutputType = {
    id: number
    productId: number
    name: number
    value: number
    priceModifier: number
    stock: number
    sku: number
    barcode: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductVariantAvgAggregateInputType = {
    priceModifier?: true
    stock?: true
  }

  export type ProductVariantSumAggregateInputType = {
    priceModifier?: true
    stock?: true
  }

  export type ProductVariantMinAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    value?: true
    priceModifier?: true
    stock?: true
    sku?: true
    barcode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantMaxAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    value?: true
    priceModifier?: true
    stock?: true
    sku?: true
    barcode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantCountAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    value?: true
    priceModifier?: true
    stock?: true
    sku?: true
    barcode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariant to aggregate.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductVariants
    **/
    _count?: true | ProductVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductVariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductVariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductVariantMaxAggregateInputType
  }

  export type GetProductVariantAggregateType<T extends ProductVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateProductVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductVariant[P]>
      : GetScalarType<T[P], AggregateProductVariant[P]>
  }




  export type ProductVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantWhereInput
    orderBy?: ProductVariantOrderByWithAggregationInput | ProductVariantOrderByWithAggregationInput[]
    by: ProductVariantScalarFieldEnum[] | ProductVariantScalarFieldEnum
    having?: ProductVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductVariantCountAggregateInputType | true
    _avg?: ProductVariantAvgAggregateInputType
    _sum?: ProductVariantSumAggregateInputType
    _min?: ProductVariantMinAggregateInputType
    _max?: ProductVariantMaxAggregateInputType
  }

  export type ProductVariantGroupByOutputType = {
    id: string
    productId: string
    name: string
    value: string
    priceModifier: Decimal
    stock: number
    sku: string
    barcode: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductVariantCountAggregateOutputType | null
    _avg: ProductVariantAvgAggregateOutputType | null
    _sum: ProductVariantSumAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  type GetProductVariantGroupByPayload<T extends ProductVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
            : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
        }
      >
    >


  export type ProductVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    name?: boolean
    value?: boolean
    priceModifier?: boolean
    stock?: boolean
    sku?: boolean
    barcode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    stockLocations?: boolean | ProductVariant$stockLocationsArgs<ExtArgs>
    saleItems?: boolean | ProductVariant$saleItemsArgs<ExtArgs>
    purchaseItems?: boolean | ProductVariant$purchaseItemsArgs<ExtArgs>
    stockMovements?: boolean | ProductVariant$stockMovementsArgs<ExtArgs>
    stockTakeItems?: boolean | ProductVariant$stockTakeItemsArgs<ExtArgs>
    _count?: boolean | ProductVariantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariant"]>


  export type ProductVariantSelectScalar = {
    id?: boolean
    productId?: boolean
    name?: boolean
    value?: boolean
    priceModifier?: boolean
    stock?: boolean
    sku?: boolean
    barcode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    stockLocations?: boolean | ProductVariant$stockLocationsArgs<ExtArgs>
    saleItems?: boolean | ProductVariant$saleItemsArgs<ExtArgs>
    purchaseItems?: boolean | ProductVariant$purchaseItemsArgs<ExtArgs>
    stockMovements?: boolean | ProductVariant$stockMovementsArgs<ExtArgs>
    stockTakeItems?: boolean | ProductVariant$stockTakeItemsArgs<ExtArgs>
    _count?: boolean | ProductVariantCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductVariant"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      stockLocations: Prisma.$ProductStockLocationPayload<ExtArgs>[]
      saleItems: Prisma.$SaleItemPayload<ExtArgs>[]
      purchaseItems: Prisma.$PurchaseItemPayload<ExtArgs>[]
      stockMovements: Prisma.$StockMovementPayload<ExtArgs>[]
      stockTakeItems: Prisma.$StockTakeItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      name: string
      value: string
      priceModifier: Prisma.Decimal
      stock: number
      sku: string
      barcode: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productVariant"]>
    composites: {}
  }

  type ProductVariantGetPayload<S extends boolean | null | undefined | ProductVariantDefaultArgs> = $Result.GetResult<Prisma.$ProductVariantPayload, S>

  type ProductVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductVariantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductVariantCountAggregateInputType | true
    }

  export interface ProductVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductVariant'], meta: { name: 'ProductVariant' } }
    /**
     * Find zero or one ProductVariant that matches the filter.
     * @param {ProductVariantFindUniqueArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductVariantFindUniqueArgs>(args: SelectSubset<T, ProductVariantFindUniqueArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductVariant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductVariantFindUniqueOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductVariantFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductVariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductVariantFindFirstArgs>(args?: SelectSubset<T, ProductVariantFindFirstArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductVariantFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductVariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductVariants
     * const productVariants = await prisma.productVariant.findMany()
     * 
     * // Get first 10 ProductVariants
     * const productVariants = await prisma.productVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductVariantFindManyArgs>(args?: SelectSubset<T, ProductVariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductVariant.
     * @param {ProductVariantCreateArgs} args - Arguments to create a ProductVariant.
     * @example
     * // Create one ProductVariant
     * const ProductVariant = await prisma.productVariant.create({
     *   data: {
     *     // ... data to create a ProductVariant
     *   }
     * })
     * 
     */
    create<T extends ProductVariantCreateArgs>(args: SelectSubset<T, ProductVariantCreateArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductVariants.
     * @param {ProductVariantCreateManyArgs} args - Arguments to create many ProductVariants.
     * @example
     * // Create many ProductVariants
     * const productVariant = await prisma.productVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductVariantCreateManyArgs>(args?: SelectSubset<T, ProductVariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductVariant.
     * @param {ProductVariantDeleteArgs} args - Arguments to delete one ProductVariant.
     * @example
     * // Delete one ProductVariant
     * const ProductVariant = await prisma.productVariant.delete({
     *   where: {
     *     // ... filter to delete one ProductVariant
     *   }
     * })
     * 
     */
    delete<T extends ProductVariantDeleteArgs>(args: SelectSubset<T, ProductVariantDeleteArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductVariant.
     * @param {ProductVariantUpdateArgs} args - Arguments to update one ProductVariant.
     * @example
     * // Update one ProductVariant
     * const productVariant = await prisma.productVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductVariantUpdateArgs>(args: SelectSubset<T, ProductVariantUpdateArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductVariants.
     * @param {ProductVariantDeleteManyArgs} args - Arguments to filter ProductVariants to delete.
     * @example
     * // Delete a few ProductVariants
     * const { count } = await prisma.productVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductVariantDeleteManyArgs>(args?: SelectSubset<T, ProductVariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductVariants
     * const productVariant = await prisma.productVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductVariantUpdateManyArgs>(args: SelectSubset<T, ProductVariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductVariant.
     * @param {ProductVariantUpsertArgs} args - Arguments to update or create a ProductVariant.
     * @example
     * // Update or create a ProductVariant
     * const productVariant = await prisma.productVariant.upsert({
     *   create: {
     *     // ... data to create a ProductVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductVariant we want to update
     *   }
     * })
     */
    upsert<T extends ProductVariantUpsertArgs>(args: SelectSubset<T, ProductVariantUpsertArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantCountArgs} args - Arguments to filter ProductVariants to count.
     * @example
     * // Count the number of ProductVariants
     * const count = await prisma.productVariant.count({
     *   where: {
     *     // ... the filter for the ProductVariants we want to count
     *   }
     * })
    **/
    count<T extends ProductVariantCountArgs>(
      args?: Subset<T, ProductVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductVariantAggregateArgs>(args: Subset<T, ProductVariantAggregateArgs>): Prisma.PrismaPromise<GetProductVariantAggregateType<T>>

    /**
     * Group by ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductVariantGroupByArgs['orderBy'] }
        : { orderBy?: ProductVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductVariant model
   */
  readonly fields: ProductVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stockLocations<T extends ProductVariant$stockLocationsArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$stockLocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockLocationPayload<ExtArgs>, T, "findMany"> | Null>
    saleItems<T extends ProductVariant$saleItemsArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$saleItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany"> | Null>
    purchaseItems<T extends ProductVariant$purchaseItemsArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$purchaseItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany"> | Null>
    stockMovements<T extends ProductVariant$stockMovementsArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$stockMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany"> | Null>
    stockTakeItems<T extends ProductVariant$stockTakeItemsArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$stockTakeItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTakeItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductVariant model
   */ 
  interface ProductVariantFieldRefs {
    readonly id: FieldRef<"ProductVariant", 'String'>
    readonly productId: FieldRef<"ProductVariant", 'String'>
    readonly name: FieldRef<"ProductVariant", 'String'>
    readonly value: FieldRef<"ProductVariant", 'String'>
    readonly priceModifier: FieldRef<"ProductVariant", 'Decimal'>
    readonly stock: FieldRef<"ProductVariant", 'Int'>
    readonly sku: FieldRef<"ProductVariant", 'String'>
    readonly barcode: FieldRef<"ProductVariant", 'String'>
    readonly isActive: FieldRef<"ProductVariant", 'Boolean'>
    readonly createdAt: FieldRef<"ProductVariant", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductVariant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductVariant findUnique
   */
  export type ProductVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant findUniqueOrThrow
   */
  export type ProductVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant findFirst
   */
  export type ProductVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant findFirstOrThrow
   */
  export type ProductVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant findMany
   */
  export type ProductVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariants to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant create
   */
  export type ProductVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductVariant.
     */
    data: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
  }

  /**
   * ProductVariant createMany
   */
  export type ProductVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductVariants.
     */
    data: ProductVariantCreateManyInput | ProductVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductVariant update
   */
  export type ProductVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductVariant.
     */
    data: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
    /**
     * Choose, which ProductVariant to update.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant updateMany
   */
  export type ProductVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductVariants.
     */
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariants to update
     */
    where?: ProductVariantWhereInput
  }

  /**
   * ProductVariant upsert
   */
  export type ProductVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductVariant to update in case it exists.
     */
    where: ProductVariantWhereUniqueInput
    /**
     * In case the ProductVariant found by the `where` argument doesn't exist, create a new ProductVariant with this data.
     */
    create: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
    /**
     * In case the ProductVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
  }

  /**
   * ProductVariant delete
   */
  export type ProductVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter which ProductVariant to delete.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant deleteMany
   */
  export type ProductVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariants to delete
     */
    where?: ProductVariantWhereInput
  }

  /**
   * ProductVariant.stockLocations
   */
  export type ProductVariant$stockLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockLocation
     */
    select?: ProductStockLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockLocationInclude<ExtArgs> | null
    where?: ProductStockLocationWhereInput
    orderBy?: ProductStockLocationOrderByWithRelationInput | ProductStockLocationOrderByWithRelationInput[]
    cursor?: ProductStockLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductStockLocationScalarFieldEnum | ProductStockLocationScalarFieldEnum[]
  }

  /**
   * ProductVariant.saleItems
   */
  export type ProductVariant$saleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    cursor?: SaleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * ProductVariant.purchaseItems
   */
  export type ProductVariant$purchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    cursor?: PurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * ProductVariant.stockMovements
   */
  export type ProductVariant$stockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * ProductVariant.stockTakeItems
   */
  export type ProductVariant$stockTakeItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTakeItem
     */
    select?: StockTakeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeItemInclude<ExtArgs> | null
    where?: StockTakeItemWhereInput
    orderBy?: StockTakeItemOrderByWithRelationInput | StockTakeItemOrderByWithRelationInput[]
    cursor?: StockTakeItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTakeItemScalarFieldEnum | StockTakeItemScalarFieldEnum[]
  }

  /**
   * ProductVariant without action
   */
  export type ProductVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
  }


  /**
   * Model ProductStockLocation
   */

  export type AggregateProductStockLocation = {
    _count: ProductStockLocationCountAggregateOutputType | null
    _avg: ProductStockLocationAvgAggregateOutputType | null
    _sum: ProductStockLocationSumAggregateOutputType | null
    _min: ProductStockLocationMinAggregateOutputType | null
    _max: ProductStockLocationMaxAggregateOutputType | null
  }

  export type ProductStockLocationAvgAggregateOutputType = {
    quantity: number | null
    reservedQuantity: number | null
  }

  export type ProductStockLocationSumAggregateOutputType = {
    quantity: number | null
    reservedQuantity: number | null
  }

  export type ProductStockLocationMinAggregateOutputType = {
    id: string | null
    productId: string | null
    variantId: string | null
    locationName: string | null
    quantity: number | null
    reservedQuantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductStockLocationMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    variantId: string | null
    locationName: string | null
    quantity: number | null
    reservedQuantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductStockLocationCountAggregateOutputType = {
    id: number
    productId: number
    variantId: number
    locationName: number
    quantity: number
    reservedQuantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductStockLocationAvgAggregateInputType = {
    quantity?: true
    reservedQuantity?: true
  }

  export type ProductStockLocationSumAggregateInputType = {
    quantity?: true
    reservedQuantity?: true
  }

  export type ProductStockLocationMinAggregateInputType = {
    id?: true
    productId?: true
    variantId?: true
    locationName?: true
    quantity?: true
    reservedQuantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductStockLocationMaxAggregateInputType = {
    id?: true
    productId?: true
    variantId?: true
    locationName?: true
    quantity?: true
    reservedQuantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductStockLocationCountAggregateInputType = {
    id?: true
    productId?: true
    variantId?: true
    locationName?: true
    quantity?: true
    reservedQuantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductStockLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductStockLocation to aggregate.
     */
    where?: ProductStockLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStockLocations to fetch.
     */
    orderBy?: ProductStockLocationOrderByWithRelationInput | ProductStockLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductStockLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStockLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStockLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductStockLocations
    **/
    _count?: true | ProductStockLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductStockLocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductStockLocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductStockLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductStockLocationMaxAggregateInputType
  }

  export type GetProductStockLocationAggregateType<T extends ProductStockLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateProductStockLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductStockLocation[P]>
      : GetScalarType<T[P], AggregateProductStockLocation[P]>
  }




  export type ProductStockLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStockLocationWhereInput
    orderBy?: ProductStockLocationOrderByWithAggregationInput | ProductStockLocationOrderByWithAggregationInput[]
    by: ProductStockLocationScalarFieldEnum[] | ProductStockLocationScalarFieldEnum
    having?: ProductStockLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductStockLocationCountAggregateInputType | true
    _avg?: ProductStockLocationAvgAggregateInputType
    _sum?: ProductStockLocationSumAggregateInputType
    _min?: ProductStockLocationMinAggregateInputType
    _max?: ProductStockLocationMaxAggregateInputType
  }

  export type ProductStockLocationGroupByOutputType = {
    id: string
    productId: string
    variantId: string | null
    locationName: string
    quantity: number
    reservedQuantity: number
    createdAt: Date
    updatedAt: Date
    _count: ProductStockLocationCountAggregateOutputType | null
    _avg: ProductStockLocationAvgAggregateOutputType | null
    _sum: ProductStockLocationSumAggregateOutputType | null
    _min: ProductStockLocationMinAggregateOutputType | null
    _max: ProductStockLocationMaxAggregateOutputType | null
  }

  type GetProductStockLocationGroupByPayload<T extends ProductStockLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductStockLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductStockLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductStockLocationGroupByOutputType[P]>
            : GetScalarType<T[P], ProductStockLocationGroupByOutputType[P]>
        }
      >
    >


  export type ProductStockLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    variantId?: boolean
    locationName?: boolean
    quantity?: boolean
    reservedQuantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    variant?: boolean | ProductStockLocation$variantArgs<ExtArgs>
  }, ExtArgs["result"]["productStockLocation"]>


  export type ProductStockLocationSelectScalar = {
    id?: boolean
    productId?: boolean
    variantId?: boolean
    locationName?: boolean
    quantity?: boolean
    reservedQuantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductStockLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    variant?: boolean | ProductStockLocation$variantArgs<ExtArgs>
  }

  export type $ProductStockLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductStockLocation"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      variant: Prisma.$ProductVariantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      variantId: string | null
      locationName: string
      quantity: number
      reservedQuantity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productStockLocation"]>
    composites: {}
  }

  type ProductStockLocationGetPayload<S extends boolean | null | undefined | ProductStockLocationDefaultArgs> = $Result.GetResult<Prisma.$ProductStockLocationPayload, S>

  type ProductStockLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductStockLocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductStockLocationCountAggregateInputType | true
    }

  export interface ProductStockLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductStockLocation'], meta: { name: 'ProductStockLocation' } }
    /**
     * Find zero or one ProductStockLocation that matches the filter.
     * @param {ProductStockLocationFindUniqueArgs} args - Arguments to find a ProductStockLocation
     * @example
     * // Get one ProductStockLocation
     * const productStockLocation = await prisma.productStockLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductStockLocationFindUniqueArgs>(args: SelectSubset<T, ProductStockLocationFindUniqueArgs<ExtArgs>>): Prisma__ProductStockLocationClient<$Result.GetResult<Prisma.$ProductStockLocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductStockLocation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductStockLocationFindUniqueOrThrowArgs} args - Arguments to find a ProductStockLocation
     * @example
     * // Get one ProductStockLocation
     * const productStockLocation = await prisma.productStockLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductStockLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductStockLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductStockLocationClient<$Result.GetResult<Prisma.$ProductStockLocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductStockLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockLocationFindFirstArgs} args - Arguments to find a ProductStockLocation
     * @example
     * // Get one ProductStockLocation
     * const productStockLocation = await prisma.productStockLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductStockLocationFindFirstArgs>(args?: SelectSubset<T, ProductStockLocationFindFirstArgs<ExtArgs>>): Prisma__ProductStockLocationClient<$Result.GetResult<Prisma.$ProductStockLocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductStockLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockLocationFindFirstOrThrowArgs} args - Arguments to find a ProductStockLocation
     * @example
     * // Get one ProductStockLocation
     * const productStockLocation = await prisma.productStockLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductStockLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductStockLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductStockLocationClient<$Result.GetResult<Prisma.$ProductStockLocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductStockLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductStockLocations
     * const productStockLocations = await prisma.productStockLocation.findMany()
     * 
     * // Get first 10 ProductStockLocations
     * const productStockLocations = await prisma.productStockLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productStockLocationWithIdOnly = await prisma.productStockLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductStockLocationFindManyArgs>(args?: SelectSubset<T, ProductStockLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockLocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductStockLocation.
     * @param {ProductStockLocationCreateArgs} args - Arguments to create a ProductStockLocation.
     * @example
     * // Create one ProductStockLocation
     * const ProductStockLocation = await prisma.productStockLocation.create({
     *   data: {
     *     // ... data to create a ProductStockLocation
     *   }
     * })
     * 
     */
    create<T extends ProductStockLocationCreateArgs>(args: SelectSubset<T, ProductStockLocationCreateArgs<ExtArgs>>): Prisma__ProductStockLocationClient<$Result.GetResult<Prisma.$ProductStockLocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductStockLocations.
     * @param {ProductStockLocationCreateManyArgs} args - Arguments to create many ProductStockLocations.
     * @example
     * // Create many ProductStockLocations
     * const productStockLocation = await prisma.productStockLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductStockLocationCreateManyArgs>(args?: SelectSubset<T, ProductStockLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductStockLocation.
     * @param {ProductStockLocationDeleteArgs} args - Arguments to delete one ProductStockLocation.
     * @example
     * // Delete one ProductStockLocation
     * const ProductStockLocation = await prisma.productStockLocation.delete({
     *   where: {
     *     // ... filter to delete one ProductStockLocation
     *   }
     * })
     * 
     */
    delete<T extends ProductStockLocationDeleteArgs>(args: SelectSubset<T, ProductStockLocationDeleteArgs<ExtArgs>>): Prisma__ProductStockLocationClient<$Result.GetResult<Prisma.$ProductStockLocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductStockLocation.
     * @param {ProductStockLocationUpdateArgs} args - Arguments to update one ProductStockLocation.
     * @example
     * // Update one ProductStockLocation
     * const productStockLocation = await prisma.productStockLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductStockLocationUpdateArgs>(args: SelectSubset<T, ProductStockLocationUpdateArgs<ExtArgs>>): Prisma__ProductStockLocationClient<$Result.GetResult<Prisma.$ProductStockLocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductStockLocations.
     * @param {ProductStockLocationDeleteManyArgs} args - Arguments to filter ProductStockLocations to delete.
     * @example
     * // Delete a few ProductStockLocations
     * const { count } = await prisma.productStockLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductStockLocationDeleteManyArgs>(args?: SelectSubset<T, ProductStockLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductStockLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductStockLocations
     * const productStockLocation = await prisma.productStockLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductStockLocationUpdateManyArgs>(args: SelectSubset<T, ProductStockLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductStockLocation.
     * @param {ProductStockLocationUpsertArgs} args - Arguments to update or create a ProductStockLocation.
     * @example
     * // Update or create a ProductStockLocation
     * const productStockLocation = await prisma.productStockLocation.upsert({
     *   create: {
     *     // ... data to create a ProductStockLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductStockLocation we want to update
     *   }
     * })
     */
    upsert<T extends ProductStockLocationUpsertArgs>(args: SelectSubset<T, ProductStockLocationUpsertArgs<ExtArgs>>): Prisma__ProductStockLocationClient<$Result.GetResult<Prisma.$ProductStockLocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductStockLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockLocationCountArgs} args - Arguments to filter ProductStockLocations to count.
     * @example
     * // Count the number of ProductStockLocations
     * const count = await prisma.productStockLocation.count({
     *   where: {
     *     // ... the filter for the ProductStockLocations we want to count
     *   }
     * })
    **/
    count<T extends ProductStockLocationCountArgs>(
      args?: Subset<T, ProductStockLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductStockLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductStockLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductStockLocationAggregateArgs>(args: Subset<T, ProductStockLocationAggregateArgs>): Prisma.PrismaPromise<GetProductStockLocationAggregateType<T>>

    /**
     * Group by ProductStockLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductStockLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductStockLocationGroupByArgs['orderBy'] }
        : { orderBy?: ProductStockLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductStockLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductStockLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductStockLocation model
   */
  readonly fields: ProductStockLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductStockLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductStockLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    variant<T extends ProductStockLocation$variantArgs<ExtArgs> = {}>(args?: Subset<T, ProductStockLocation$variantArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductStockLocation model
   */ 
  interface ProductStockLocationFieldRefs {
    readonly id: FieldRef<"ProductStockLocation", 'String'>
    readonly productId: FieldRef<"ProductStockLocation", 'String'>
    readonly variantId: FieldRef<"ProductStockLocation", 'String'>
    readonly locationName: FieldRef<"ProductStockLocation", 'String'>
    readonly quantity: FieldRef<"ProductStockLocation", 'Int'>
    readonly reservedQuantity: FieldRef<"ProductStockLocation", 'Int'>
    readonly createdAt: FieldRef<"ProductStockLocation", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductStockLocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductStockLocation findUnique
   */
  export type ProductStockLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockLocation
     */
    select?: ProductStockLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockLocationInclude<ExtArgs> | null
    /**
     * Filter, which ProductStockLocation to fetch.
     */
    where: ProductStockLocationWhereUniqueInput
  }

  /**
   * ProductStockLocation findUniqueOrThrow
   */
  export type ProductStockLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockLocation
     */
    select?: ProductStockLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockLocationInclude<ExtArgs> | null
    /**
     * Filter, which ProductStockLocation to fetch.
     */
    where: ProductStockLocationWhereUniqueInput
  }

  /**
   * ProductStockLocation findFirst
   */
  export type ProductStockLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockLocation
     */
    select?: ProductStockLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockLocationInclude<ExtArgs> | null
    /**
     * Filter, which ProductStockLocation to fetch.
     */
    where?: ProductStockLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStockLocations to fetch.
     */
    orderBy?: ProductStockLocationOrderByWithRelationInput | ProductStockLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductStockLocations.
     */
    cursor?: ProductStockLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStockLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStockLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductStockLocations.
     */
    distinct?: ProductStockLocationScalarFieldEnum | ProductStockLocationScalarFieldEnum[]
  }

  /**
   * ProductStockLocation findFirstOrThrow
   */
  export type ProductStockLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockLocation
     */
    select?: ProductStockLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockLocationInclude<ExtArgs> | null
    /**
     * Filter, which ProductStockLocation to fetch.
     */
    where?: ProductStockLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStockLocations to fetch.
     */
    orderBy?: ProductStockLocationOrderByWithRelationInput | ProductStockLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductStockLocations.
     */
    cursor?: ProductStockLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStockLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStockLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductStockLocations.
     */
    distinct?: ProductStockLocationScalarFieldEnum | ProductStockLocationScalarFieldEnum[]
  }

  /**
   * ProductStockLocation findMany
   */
  export type ProductStockLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockLocation
     */
    select?: ProductStockLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockLocationInclude<ExtArgs> | null
    /**
     * Filter, which ProductStockLocations to fetch.
     */
    where?: ProductStockLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStockLocations to fetch.
     */
    orderBy?: ProductStockLocationOrderByWithRelationInput | ProductStockLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductStockLocations.
     */
    cursor?: ProductStockLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStockLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStockLocations.
     */
    skip?: number
    distinct?: ProductStockLocationScalarFieldEnum | ProductStockLocationScalarFieldEnum[]
  }

  /**
   * ProductStockLocation create
   */
  export type ProductStockLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockLocation
     */
    select?: ProductStockLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductStockLocation.
     */
    data: XOR<ProductStockLocationCreateInput, ProductStockLocationUncheckedCreateInput>
  }

  /**
   * ProductStockLocation createMany
   */
  export type ProductStockLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductStockLocations.
     */
    data: ProductStockLocationCreateManyInput | ProductStockLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductStockLocation update
   */
  export type ProductStockLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockLocation
     */
    select?: ProductStockLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductStockLocation.
     */
    data: XOR<ProductStockLocationUpdateInput, ProductStockLocationUncheckedUpdateInput>
    /**
     * Choose, which ProductStockLocation to update.
     */
    where: ProductStockLocationWhereUniqueInput
  }

  /**
   * ProductStockLocation updateMany
   */
  export type ProductStockLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductStockLocations.
     */
    data: XOR<ProductStockLocationUpdateManyMutationInput, ProductStockLocationUncheckedUpdateManyInput>
    /**
     * Filter which ProductStockLocations to update
     */
    where?: ProductStockLocationWhereInput
  }

  /**
   * ProductStockLocation upsert
   */
  export type ProductStockLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockLocation
     */
    select?: ProductStockLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductStockLocation to update in case it exists.
     */
    where: ProductStockLocationWhereUniqueInput
    /**
     * In case the ProductStockLocation found by the `where` argument doesn't exist, create a new ProductStockLocation with this data.
     */
    create: XOR<ProductStockLocationCreateInput, ProductStockLocationUncheckedCreateInput>
    /**
     * In case the ProductStockLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductStockLocationUpdateInput, ProductStockLocationUncheckedUpdateInput>
  }

  /**
   * ProductStockLocation delete
   */
  export type ProductStockLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockLocation
     */
    select?: ProductStockLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockLocationInclude<ExtArgs> | null
    /**
     * Filter which ProductStockLocation to delete.
     */
    where: ProductStockLocationWhereUniqueInput
  }

  /**
   * ProductStockLocation deleteMany
   */
  export type ProductStockLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductStockLocations to delete
     */
    where?: ProductStockLocationWhereInput
  }

  /**
   * ProductStockLocation.variant
   */
  export type ProductStockLocation$variantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    where?: ProductVariantWhereInput
  }

  /**
   * ProductStockLocation without action
   */
  export type ProductStockLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockLocation
     */
    select?: ProductStockLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockLocationInclude<ExtArgs> | null
  }


  /**
   * Model CashierProductAssignment
   */

  export type AggregateCashierProductAssignment = {
    _count: CashierProductAssignmentCountAggregateOutputType | null
    _min: CashierProductAssignmentMinAggregateOutputType | null
    _max: CashierProductAssignmentMaxAggregateOutputType | null
  }

  export type CashierProductAssignmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    assignedAt: Date | null
  }

  export type CashierProductAssignmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    assignedAt: Date | null
  }

  export type CashierProductAssignmentCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    assignedAt: number
    _all: number
  }


  export type CashierProductAssignmentMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    assignedAt?: true
  }

  export type CashierProductAssignmentMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    assignedAt?: true
  }

  export type CashierProductAssignmentCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    assignedAt?: true
    _all?: true
  }

  export type CashierProductAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashierProductAssignment to aggregate.
     */
    where?: CashierProductAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashierProductAssignments to fetch.
     */
    orderBy?: CashierProductAssignmentOrderByWithRelationInput | CashierProductAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashierProductAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashierProductAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashierProductAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashierProductAssignments
    **/
    _count?: true | CashierProductAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashierProductAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashierProductAssignmentMaxAggregateInputType
  }

  export type GetCashierProductAssignmentAggregateType<T extends CashierProductAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCashierProductAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashierProductAssignment[P]>
      : GetScalarType<T[P], AggregateCashierProductAssignment[P]>
  }




  export type CashierProductAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashierProductAssignmentWhereInput
    orderBy?: CashierProductAssignmentOrderByWithAggregationInput | CashierProductAssignmentOrderByWithAggregationInput[]
    by: CashierProductAssignmentScalarFieldEnum[] | CashierProductAssignmentScalarFieldEnum
    having?: CashierProductAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashierProductAssignmentCountAggregateInputType | true
    _min?: CashierProductAssignmentMinAggregateInputType
    _max?: CashierProductAssignmentMaxAggregateInputType
  }

  export type CashierProductAssignmentGroupByOutputType = {
    id: string
    userId: string
    productId: string
    assignedAt: Date
    _count: CashierProductAssignmentCountAggregateOutputType | null
    _min: CashierProductAssignmentMinAggregateOutputType | null
    _max: CashierProductAssignmentMaxAggregateOutputType | null
  }

  type GetCashierProductAssignmentGroupByPayload<T extends CashierProductAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashierProductAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashierProductAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashierProductAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], CashierProductAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type CashierProductAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    assignedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashierProductAssignment"]>


  export type CashierProductAssignmentSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    assignedAt?: boolean
  }

  export type CashierProductAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $CashierProductAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashierProductAssignment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      productId: string
      assignedAt: Date
    }, ExtArgs["result"]["cashierProductAssignment"]>
    composites: {}
  }

  type CashierProductAssignmentGetPayload<S extends boolean | null | undefined | CashierProductAssignmentDefaultArgs> = $Result.GetResult<Prisma.$CashierProductAssignmentPayload, S>

  type CashierProductAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CashierProductAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CashierProductAssignmentCountAggregateInputType | true
    }

  export interface CashierProductAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashierProductAssignment'], meta: { name: 'CashierProductAssignment' } }
    /**
     * Find zero or one CashierProductAssignment that matches the filter.
     * @param {CashierProductAssignmentFindUniqueArgs} args - Arguments to find a CashierProductAssignment
     * @example
     * // Get one CashierProductAssignment
     * const cashierProductAssignment = await prisma.cashierProductAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashierProductAssignmentFindUniqueArgs>(args: SelectSubset<T, CashierProductAssignmentFindUniqueArgs<ExtArgs>>): Prisma__CashierProductAssignmentClient<$Result.GetResult<Prisma.$CashierProductAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CashierProductAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CashierProductAssignmentFindUniqueOrThrowArgs} args - Arguments to find a CashierProductAssignment
     * @example
     * // Get one CashierProductAssignment
     * const cashierProductAssignment = await prisma.cashierProductAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashierProductAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, CashierProductAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashierProductAssignmentClient<$Result.GetResult<Prisma.$CashierProductAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CashierProductAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierProductAssignmentFindFirstArgs} args - Arguments to find a CashierProductAssignment
     * @example
     * // Get one CashierProductAssignment
     * const cashierProductAssignment = await prisma.cashierProductAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashierProductAssignmentFindFirstArgs>(args?: SelectSubset<T, CashierProductAssignmentFindFirstArgs<ExtArgs>>): Prisma__CashierProductAssignmentClient<$Result.GetResult<Prisma.$CashierProductAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CashierProductAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierProductAssignmentFindFirstOrThrowArgs} args - Arguments to find a CashierProductAssignment
     * @example
     * // Get one CashierProductAssignment
     * const cashierProductAssignment = await prisma.cashierProductAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashierProductAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, CashierProductAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashierProductAssignmentClient<$Result.GetResult<Prisma.$CashierProductAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CashierProductAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierProductAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashierProductAssignments
     * const cashierProductAssignments = await prisma.cashierProductAssignment.findMany()
     * 
     * // Get first 10 CashierProductAssignments
     * const cashierProductAssignments = await prisma.cashierProductAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashierProductAssignmentWithIdOnly = await prisma.cashierProductAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashierProductAssignmentFindManyArgs>(args?: SelectSubset<T, CashierProductAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashierProductAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CashierProductAssignment.
     * @param {CashierProductAssignmentCreateArgs} args - Arguments to create a CashierProductAssignment.
     * @example
     * // Create one CashierProductAssignment
     * const CashierProductAssignment = await prisma.cashierProductAssignment.create({
     *   data: {
     *     // ... data to create a CashierProductAssignment
     *   }
     * })
     * 
     */
    create<T extends CashierProductAssignmentCreateArgs>(args: SelectSubset<T, CashierProductAssignmentCreateArgs<ExtArgs>>): Prisma__CashierProductAssignmentClient<$Result.GetResult<Prisma.$CashierProductAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CashierProductAssignments.
     * @param {CashierProductAssignmentCreateManyArgs} args - Arguments to create many CashierProductAssignments.
     * @example
     * // Create many CashierProductAssignments
     * const cashierProductAssignment = await prisma.cashierProductAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashierProductAssignmentCreateManyArgs>(args?: SelectSubset<T, CashierProductAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CashierProductAssignment.
     * @param {CashierProductAssignmentDeleteArgs} args - Arguments to delete one CashierProductAssignment.
     * @example
     * // Delete one CashierProductAssignment
     * const CashierProductAssignment = await prisma.cashierProductAssignment.delete({
     *   where: {
     *     // ... filter to delete one CashierProductAssignment
     *   }
     * })
     * 
     */
    delete<T extends CashierProductAssignmentDeleteArgs>(args: SelectSubset<T, CashierProductAssignmentDeleteArgs<ExtArgs>>): Prisma__CashierProductAssignmentClient<$Result.GetResult<Prisma.$CashierProductAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CashierProductAssignment.
     * @param {CashierProductAssignmentUpdateArgs} args - Arguments to update one CashierProductAssignment.
     * @example
     * // Update one CashierProductAssignment
     * const cashierProductAssignment = await prisma.cashierProductAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashierProductAssignmentUpdateArgs>(args: SelectSubset<T, CashierProductAssignmentUpdateArgs<ExtArgs>>): Prisma__CashierProductAssignmentClient<$Result.GetResult<Prisma.$CashierProductAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CashierProductAssignments.
     * @param {CashierProductAssignmentDeleteManyArgs} args - Arguments to filter CashierProductAssignments to delete.
     * @example
     * // Delete a few CashierProductAssignments
     * const { count } = await prisma.cashierProductAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashierProductAssignmentDeleteManyArgs>(args?: SelectSubset<T, CashierProductAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashierProductAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierProductAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashierProductAssignments
     * const cashierProductAssignment = await prisma.cashierProductAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashierProductAssignmentUpdateManyArgs>(args: SelectSubset<T, CashierProductAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CashierProductAssignment.
     * @param {CashierProductAssignmentUpsertArgs} args - Arguments to update or create a CashierProductAssignment.
     * @example
     * // Update or create a CashierProductAssignment
     * const cashierProductAssignment = await prisma.cashierProductAssignment.upsert({
     *   create: {
     *     // ... data to create a CashierProductAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashierProductAssignment we want to update
     *   }
     * })
     */
    upsert<T extends CashierProductAssignmentUpsertArgs>(args: SelectSubset<T, CashierProductAssignmentUpsertArgs<ExtArgs>>): Prisma__CashierProductAssignmentClient<$Result.GetResult<Prisma.$CashierProductAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CashierProductAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierProductAssignmentCountArgs} args - Arguments to filter CashierProductAssignments to count.
     * @example
     * // Count the number of CashierProductAssignments
     * const count = await prisma.cashierProductAssignment.count({
     *   where: {
     *     // ... the filter for the CashierProductAssignments we want to count
     *   }
     * })
    **/
    count<T extends CashierProductAssignmentCountArgs>(
      args?: Subset<T, CashierProductAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashierProductAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashierProductAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierProductAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashierProductAssignmentAggregateArgs>(args: Subset<T, CashierProductAssignmentAggregateArgs>): Prisma.PrismaPromise<GetCashierProductAssignmentAggregateType<T>>

    /**
     * Group by CashierProductAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashierProductAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashierProductAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashierProductAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: CashierProductAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashierProductAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashierProductAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashierProductAssignment model
   */
  readonly fields: CashierProductAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashierProductAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashierProductAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashierProductAssignment model
   */ 
  interface CashierProductAssignmentFieldRefs {
    readonly id: FieldRef<"CashierProductAssignment", 'String'>
    readonly userId: FieldRef<"CashierProductAssignment", 'String'>
    readonly productId: FieldRef<"CashierProductAssignment", 'String'>
    readonly assignedAt: FieldRef<"CashierProductAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashierProductAssignment findUnique
   */
  export type CashierProductAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierProductAssignment
     */
    select?: CashierProductAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierProductAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CashierProductAssignment to fetch.
     */
    where: CashierProductAssignmentWhereUniqueInput
  }

  /**
   * CashierProductAssignment findUniqueOrThrow
   */
  export type CashierProductAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierProductAssignment
     */
    select?: CashierProductAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierProductAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CashierProductAssignment to fetch.
     */
    where: CashierProductAssignmentWhereUniqueInput
  }

  /**
   * CashierProductAssignment findFirst
   */
  export type CashierProductAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierProductAssignment
     */
    select?: CashierProductAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierProductAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CashierProductAssignment to fetch.
     */
    where?: CashierProductAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashierProductAssignments to fetch.
     */
    orderBy?: CashierProductAssignmentOrderByWithRelationInput | CashierProductAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashierProductAssignments.
     */
    cursor?: CashierProductAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashierProductAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashierProductAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashierProductAssignments.
     */
    distinct?: CashierProductAssignmentScalarFieldEnum | CashierProductAssignmentScalarFieldEnum[]
  }

  /**
   * CashierProductAssignment findFirstOrThrow
   */
  export type CashierProductAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierProductAssignment
     */
    select?: CashierProductAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierProductAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CashierProductAssignment to fetch.
     */
    where?: CashierProductAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashierProductAssignments to fetch.
     */
    orderBy?: CashierProductAssignmentOrderByWithRelationInput | CashierProductAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashierProductAssignments.
     */
    cursor?: CashierProductAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashierProductAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashierProductAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashierProductAssignments.
     */
    distinct?: CashierProductAssignmentScalarFieldEnum | CashierProductAssignmentScalarFieldEnum[]
  }

  /**
   * CashierProductAssignment findMany
   */
  export type CashierProductAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierProductAssignment
     */
    select?: CashierProductAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierProductAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CashierProductAssignments to fetch.
     */
    where?: CashierProductAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashierProductAssignments to fetch.
     */
    orderBy?: CashierProductAssignmentOrderByWithRelationInput | CashierProductAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashierProductAssignments.
     */
    cursor?: CashierProductAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashierProductAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashierProductAssignments.
     */
    skip?: number
    distinct?: CashierProductAssignmentScalarFieldEnum | CashierProductAssignmentScalarFieldEnum[]
  }

  /**
   * CashierProductAssignment create
   */
  export type CashierProductAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierProductAssignment
     */
    select?: CashierProductAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierProductAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a CashierProductAssignment.
     */
    data: XOR<CashierProductAssignmentCreateInput, CashierProductAssignmentUncheckedCreateInput>
  }

  /**
   * CashierProductAssignment createMany
   */
  export type CashierProductAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashierProductAssignments.
     */
    data: CashierProductAssignmentCreateManyInput | CashierProductAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashierProductAssignment update
   */
  export type CashierProductAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierProductAssignment
     */
    select?: CashierProductAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierProductAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a CashierProductAssignment.
     */
    data: XOR<CashierProductAssignmentUpdateInput, CashierProductAssignmentUncheckedUpdateInput>
    /**
     * Choose, which CashierProductAssignment to update.
     */
    where: CashierProductAssignmentWhereUniqueInput
  }

  /**
   * CashierProductAssignment updateMany
   */
  export type CashierProductAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashierProductAssignments.
     */
    data: XOR<CashierProductAssignmentUpdateManyMutationInput, CashierProductAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which CashierProductAssignments to update
     */
    where?: CashierProductAssignmentWhereInput
  }

  /**
   * CashierProductAssignment upsert
   */
  export type CashierProductAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierProductAssignment
     */
    select?: CashierProductAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierProductAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the CashierProductAssignment to update in case it exists.
     */
    where: CashierProductAssignmentWhereUniqueInput
    /**
     * In case the CashierProductAssignment found by the `where` argument doesn't exist, create a new CashierProductAssignment with this data.
     */
    create: XOR<CashierProductAssignmentCreateInput, CashierProductAssignmentUncheckedCreateInput>
    /**
     * In case the CashierProductAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashierProductAssignmentUpdateInput, CashierProductAssignmentUncheckedUpdateInput>
  }

  /**
   * CashierProductAssignment delete
   */
  export type CashierProductAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierProductAssignment
     */
    select?: CashierProductAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierProductAssignmentInclude<ExtArgs> | null
    /**
     * Filter which CashierProductAssignment to delete.
     */
    where: CashierProductAssignmentWhereUniqueInput
  }

  /**
   * CashierProductAssignment deleteMany
   */
  export type CashierProductAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashierProductAssignments to delete
     */
    where?: CashierProductAssignmentWhereInput
  }

  /**
   * CashierProductAssignment without action
   */
  export type CashierProductAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashierProductAssignment
     */
    select?: CashierProductAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashierProductAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    loyaltyPoints: number | null
    totalSpent: Decimal | null
    visitCount: number | null
  }

  export type CustomerSumAggregateOutputType = {
    loyaltyPoints: number | null
    totalSpent: Decimal | null
    visitCount: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    dateOfBirth: Date | null
    loyaltyPoints: number | null
    totalSpent: Decimal | null
    visitCount: number | null
    lastVisit: Date | null
    isActive: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    dateOfBirth: Date | null
    loyaltyPoints: number | null
    totalSpent: Decimal | null
    visitCount: number | null
    lastVisit: Date | null
    isActive: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    vendorId: number
    name: number
    email: number
    phone: number
    address: number
    dateOfBirth: number
    loyaltyPoints: number
    totalSpent: number
    visitCount: number
    lastVisit: number
    isActive: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    loyaltyPoints?: true
    totalSpent?: true
    visitCount?: true
  }

  export type CustomerSumAggregateInputType = {
    loyaltyPoints?: true
    totalSpent?: true
    visitCount?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    dateOfBirth?: true
    loyaltyPoints?: true
    totalSpent?: true
    visitCount?: true
    lastVisit?: true
    isActive?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    dateOfBirth?: true
    loyaltyPoints?: true
    totalSpent?: true
    visitCount?: true
    lastVisit?: true
    isActive?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    dateOfBirth?: true
    loyaltyPoints?: true
    totalSpent?: true
    visitCount?: true
    lastVisit?: true
    isActive?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    vendorId: string
    name: string
    email: string | null
    phone: string | null
    address: string | null
    dateOfBirth: Date | null
    loyaltyPoints: number
    totalSpent: Decimal
    visitCount: number
    lastVisit: Date | null
    isActive: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    dateOfBirth?: boolean
    loyaltyPoints?: boolean
    totalSpent?: boolean
    visitCount?: boolean
    lastVisit?: boolean
    isActive?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    sales?: boolean | Customer$salesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>


  export type CustomerSelectScalar = {
    id?: boolean
    vendorId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    dateOfBirth?: boolean
    loyaltyPoints?: boolean
    totalSpent?: boolean
    visitCount?: boolean
    lastVisit?: boolean
    isActive?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    sales?: boolean | Customer$salesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      sales: Prisma.$SalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      name: string
      email: string | null
      phone: string | null
      address: string | null
      dateOfBirth: Date | null
      loyaltyPoints: number
      totalSpent: Prisma.Decimal
      visitCount: number
      lastVisit: Date | null
      isActive: boolean
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sales<T extends Customer$salesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */ 
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly vendorId: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly dateOfBirth: FieldRef<"Customer", 'DateTime'>
    readonly loyaltyPoints: FieldRef<"Customer", 'Int'>
    readonly totalSpent: FieldRef<"Customer", 'Decimal'>
    readonly visitCount: FieldRef<"Customer", 'Int'>
    readonly lastVisit: FieldRef<"Customer", 'DateTime'>
    readonly isActive: FieldRef<"Customer", 'Boolean'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer.sales
   */
  export type Customer$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Sale
   */

  export type AggregateSale = {
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  export type SaleAvgAggregateOutputType = {
    subtotal: Decimal | null
    tax: Decimal | null
    discount: Decimal | null
    total: Decimal | null
    paid: Decimal | null
    changeAmount: Decimal | null
    refundAmount: Decimal | null
    loyaltyPointsEarned: number | null
    loyaltyPointsUsed: number | null
  }

  export type SaleSumAggregateOutputType = {
    subtotal: Decimal | null
    tax: Decimal | null
    discount: Decimal | null
    total: Decimal | null
    paid: Decimal | null
    changeAmount: Decimal | null
    refundAmount: Decimal | null
    loyaltyPointsEarned: number | null
    loyaltyPointsUsed: number | null
  }

  export type SaleMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    cashierId: string | null
    terminalId: string | null
    customerId: string | null
    receiptNumber: string | null
    subtotal: Decimal | null
    tax: Decimal | null
    discount: Decimal | null
    total: Decimal | null
    paid: Decimal | null
    changeAmount: Decimal | null
    paymentMethod: $Enums.PaymentMethod | null
    status: $Enums.SaleStatus | null
    refundAmount: Decimal | null
    loyaltyPointsEarned: number | null
    loyaltyPointsUsed: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    cashierId: string | null
    terminalId: string | null
    customerId: string | null
    receiptNumber: string | null
    subtotal: Decimal | null
    tax: Decimal | null
    discount: Decimal | null
    total: Decimal | null
    paid: Decimal | null
    changeAmount: Decimal | null
    paymentMethod: $Enums.PaymentMethod | null
    status: $Enums.SaleStatus | null
    refundAmount: Decimal | null
    loyaltyPointsEarned: number | null
    loyaltyPointsUsed: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleCountAggregateOutputType = {
    id: number
    vendorId: number
    cashierId: number
    terminalId: number
    customerId: number
    receiptNumber: number
    subtotal: number
    tax: number
    discount: number
    total: number
    paid: number
    changeAmount: number
    paymentMethod: number
    status: number
    refundAmount: number
    loyaltyPointsEarned: number
    loyaltyPointsUsed: number
    notes: number
    receiptData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SaleAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paid?: true
    changeAmount?: true
    refundAmount?: true
    loyaltyPointsEarned?: true
    loyaltyPointsUsed?: true
  }

  export type SaleSumAggregateInputType = {
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paid?: true
    changeAmount?: true
    refundAmount?: true
    loyaltyPointsEarned?: true
    loyaltyPointsUsed?: true
  }

  export type SaleMinAggregateInputType = {
    id?: true
    vendorId?: true
    cashierId?: true
    terminalId?: true
    customerId?: true
    receiptNumber?: true
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paid?: true
    changeAmount?: true
    paymentMethod?: true
    status?: true
    refundAmount?: true
    loyaltyPointsEarned?: true
    loyaltyPointsUsed?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleMaxAggregateInputType = {
    id?: true
    vendorId?: true
    cashierId?: true
    terminalId?: true
    customerId?: true
    receiptNumber?: true
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paid?: true
    changeAmount?: true
    paymentMethod?: true
    status?: true
    refundAmount?: true
    loyaltyPointsEarned?: true
    loyaltyPointsUsed?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleCountAggregateInputType = {
    id?: true
    vendorId?: true
    cashierId?: true
    terminalId?: true
    customerId?: true
    receiptNumber?: true
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paid?: true
    changeAmount?: true
    paymentMethod?: true
    status?: true
    refundAmount?: true
    loyaltyPointsEarned?: true
    loyaltyPointsUsed?: true
    notes?: true
    receiptData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sale to aggregate.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sales
    **/
    _count?: true | SaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleMaxAggregateInputType
  }

  export type GetSaleAggregateType<T extends SaleAggregateArgs> = {
        [P in keyof T & keyof AggregateSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSale[P]>
      : GetScalarType<T[P], AggregateSale[P]>
  }




  export type SaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithAggregationInput | SaleOrderByWithAggregationInput[]
    by: SaleScalarFieldEnum[] | SaleScalarFieldEnum
    having?: SaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleCountAggregateInputType | true
    _avg?: SaleAvgAggregateInputType
    _sum?: SaleSumAggregateInputType
    _min?: SaleMinAggregateInputType
    _max?: SaleMaxAggregateInputType
  }

  export type SaleGroupByOutputType = {
    id: string
    vendorId: string
    cashierId: string
    terminalId: string
    customerId: string | null
    receiptNumber: string
    subtotal: Decimal
    tax: Decimal
    discount: Decimal
    total: Decimal
    paid: Decimal
    changeAmount: Decimal
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.SaleStatus
    refundAmount: Decimal
    loyaltyPointsEarned: number
    loyaltyPointsUsed: number
    notes: string | null
    receiptData: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  type GetSaleGroupByPayload<T extends SaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleGroupByOutputType[P]>
            : GetScalarType<T[P], SaleGroupByOutputType[P]>
        }
      >
    >


  export type SaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    cashierId?: boolean
    terminalId?: boolean
    customerId?: boolean
    receiptNumber?: boolean
    subtotal?: boolean
    tax?: boolean
    discount?: boolean
    total?: boolean
    paid?: boolean
    changeAmount?: boolean
    paymentMethod?: boolean
    status?: boolean
    refundAmount?: boolean
    loyaltyPointsEarned?: boolean
    loyaltyPointsUsed?: boolean
    notes?: boolean
    receiptData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    cashier?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    items?: boolean | Sale$itemsArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>


  export type SaleSelectScalar = {
    id?: boolean
    vendorId?: boolean
    cashierId?: boolean
    terminalId?: boolean
    customerId?: boolean
    receiptNumber?: boolean
    subtotal?: boolean
    tax?: boolean
    discount?: boolean
    total?: boolean
    paid?: boolean
    changeAmount?: boolean
    paymentMethod?: boolean
    status?: boolean
    refundAmount?: boolean
    loyaltyPointsEarned?: boolean
    loyaltyPointsUsed?: boolean
    notes?: boolean
    receiptData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    cashier?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    items?: boolean | Sale$itemsArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sale"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      cashier: Prisma.$UserPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      items: Prisma.$SaleItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      cashierId: string
      terminalId: string
      customerId: string | null
      receiptNumber: string
      subtotal: Prisma.Decimal
      tax: Prisma.Decimal
      discount: Prisma.Decimal
      total: Prisma.Decimal
      paid: Prisma.Decimal
      changeAmount: Prisma.Decimal
      paymentMethod: $Enums.PaymentMethod
      status: $Enums.SaleStatus
      refundAmount: Prisma.Decimal
      loyaltyPointsEarned: number
      loyaltyPointsUsed: number
      notes: string | null
      receiptData: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sale"]>
    composites: {}
  }

  type SaleGetPayload<S extends boolean | null | undefined | SaleDefaultArgs> = $Result.GetResult<Prisma.$SalePayload, S>

  type SaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaleCountAggregateInputType | true
    }

  export interface SaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sale'], meta: { name: 'Sale' } }
    /**
     * Find zero or one Sale that matches the filter.
     * @param {SaleFindUniqueArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleFindUniqueArgs>(args: SelectSubset<T, SaleFindUniqueArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sale that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SaleFindUniqueOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleFindFirstArgs>(args?: SelectSubset<T, SaleFindFirstArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales
     * const sales = await prisma.sale.findMany()
     * 
     * // Get first 10 Sales
     * const sales = await prisma.sale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleWithIdOnly = await prisma.sale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleFindManyArgs>(args?: SelectSubset<T, SaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sale.
     * @param {SaleCreateArgs} args - Arguments to create a Sale.
     * @example
     * // Create one Sale
     * const Sale = await prisma.sale.create({
     *   data: {
     *     // ... data to create a Sale
     *   }
     * })
     * 
     */
    create<T extends SaleCreateArgs>(args: SelectSubset<T, SaleCreateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sales.
     * @param {SaleCreateManyArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleCreateManyArgs>(args?: SelectSubset<T, SaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sale.
     * @param {SaleDeleteArgs} args - Arguments to delete one Sale.
     * @example
     * // Delete one Sale
     * const Sale = await prisma.sale.delete({
     *   where: {
     *     // ... filter to delete one Sale
     *   }
     * })
     * 
     */
    delete<T extends SaleDeleteArgs>(args: SelectSubset<T, SaleDeleteArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sale.
     * @param {SaleUpdateArgs} args - Arguments to update one Sale.
     * @example
     * // Update one Sale
     * const sale = await prisma.sale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleUpdateArgs>(args: SelectSubset<T, SaleUpdateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sales.
     * @param {SaleDeleteManyArgs} args - Arguments to filter Sales to delete.
     * @example
     * // Delete a few Sales
     * const { count } = await prisma.sale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleDeleteManyArgs>(args?: SelectSubset<T, SaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleUpdateManyArgs>(args: SelectSubset<T, SaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sale.
     * @param {SaleUpsertArgs} args - Arguments to update or create a Sale.
     * @example
     * // Update or create a Sale
     * const sale = await prisma.sale.upsert({
     *   create: {
     *     // ... data to create a Sale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sale we want to update
     *   }
     * })
     */
    upsert<T extends SaleUpsertArgs>(args: SelectSubset<T, SaleUpsertArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleCountArgs} args - Arguments to filter Sales to count.
     * @example
     * // Count the number of Sales
     * const count = await prisma.sale.count({
     *   where: {
     *     // ... the filter for the Sales we want to count
     *   }
     * })
    **/
    count<T extends SaleCountArgs>(
      args?: Subset<T, SaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleAggregateArgs>(args: Subset<T, SaleAggregateArgs>): Prisma.PrismaPromise<GetSaleAggregateType<T>>

    /**
     * Group by Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleGroupByArgs['orderBy'] }
        : { orderBy?: SaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sale model
   */
  readonly fields: SaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cashier<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    customer<T extends Sale$customerArgs<ExtArgs> = {}>(args?: Subset<T, Sale$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    items<T extends Sale$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Sale$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sale model
   */ 
  interface SaleFieldRefs {
    readonly id: FieldRef<"Sale", 'String'>
    readonly vendorId: FieldRef<"Sale", 'String'>
    readonly cashierId: FieldRef<"Sale", 'String'>
    readonly terminalId: FieldRef<"Sale", 'String'>
    readonly customerId: FieldRef<"Sale", 'String'>
    readonly receiptNumber: FieldRef<"Sale", 'String'>
    readonly subtotal: FieldRef<"Sale", 'Decimal'>
    readonly tax: FieldRef<"Sale", 'Decimal'>
    readonly discount: FieldRef<"Sale", 'Decimal'>
    readonly total: FieldRef<"Sale", 'Decimal'>
    readonly paid: FieldRef<"Sale", 'Decimal'>
    readonly changeAmount: FieldRef<"Sale", 'Decimal'>
    readonly paymentMethod: FieldRef<"Sale", 'PaymentMethod'>
    readonly status: FieldRef<"Sale", 'SaleStatus'>
    readonly refundAmount: FieldRef<"Sale", 'Decimal'>
    readonly loyaltyPointsEarned: FieldRef<"Sale", 'Int'>
    readonly loyaltyPointsUsed: FieldRef<"Sale", 'Int'>
    readonly notes: FieldRef<"Sale", 'String'>
    readonly receiptData: FieldRef<"Sale", 'Json'>
    readonly createdAt: FieldRef<"Sale", 'DateTime'>
    readonly updatedAt: FieldRef<"Sale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sale findUnique
   */
  export type SaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findUniqueOrThrow
   */
  export type SaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findFirst
   */
  export type SaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findFirstOrThrow
   */
  export type SaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findMany
   */
  export type SaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale create
   */
  export type SaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to create a Sale.
     */
    data: XOR<SaleCreateInput, SaleUncheckedCreateInput>
  }

  /**
   * Sale createMany
   */
  export type SaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sale update
   */
  export type SaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to update a Sale.
     */
    data: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
    /**
     * Choose, which Sale to update.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale updateMany
   */
  export type SaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
  }

  /**
   * Sale upsert
   */
  export type SaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The filter to search for the Sale to update in case it exists.
     */
    where: SaleWhereUniqueInput
    /**
     * In case the Sale found by the `where` argument doesn't exist, create a new Sale with this data.
     */
    create: XOR<SaleCreateInput, SaleUncheckedCreateInput>
    /**
     * In case the Sale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
  }

  /**
   * Sale delete
   */
  export type SaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter which Sale to delete.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale deleteMany
   */
  export type SaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sales to delete
     */
    where?: SaleWhereInput
  }

  /**
   * Sale.customer
   */
  export type Sale$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Sale.items
   */
  export type Sale$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    cursor?: SaleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * Sale without action
   */
  export type SaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
  }


  /**
   * Model SaleItem
   */

  export type AggregateSaleItem = {
    _count: SaleItemCountAggregateOutputType | null
    _avg: SaleItemAvgAggregateOutputType | null
    _sum: SaleItemSumAggregateOutputType | null
    _min: SaleItemMinAggregateOutputType | null
    _max: SaleItemMaxAggregateOutputType | null
  }

  export type SaleItemAvgAggregateOutputType = {
    price: Decimal | null
    quantity: number | null
    discount: Decimal | null
    total: Decimal | null
  }

  export type SaleItemSumAggregateOutputType = {
    price: Decimal | null
    quantity: number | null
    discount: Decimal | null
    total: Decimal | null
  }

  export type SaleItemMinAggregateOutputType = {
    id: string | null
    saleId: string | null
    productId: string | null
    variantId: string | null
    name: string | null
    sku: string | null
    price: Decimal | null
    quantity: number | null
    discount: Decimal | null
    total: Decimal | null
    createdAt: Date | null
  }

  export type SaleItemMaxAggregateOutputType = {
    id: string | null
    saleId: string | null
    productId: string | null
    variantId: string | null
    name: string | null
    sku: string | null
    price: Decimal | null
    quantity: number | null
    discount: Decimal | null
    total: Decimal | null
    createdAt: Date | null
  }

  export type SaleItemCountAggregateOutputType = {
    id: number
    saleId: number
    productId: number
    variantId: number
    name: number
    sku: number
    price: number
    quantity: number
    discount: number
    total: number
    createdAt: number
    _all: number
  }


  export type SaleItemAvgAggregateInputType = {
    price?: true
    quantity?: true
    discount?: true
    total?: true
  }

  export type SaleItemSumAggregateInputType = {
    price?: true
    quantity?: true
    discount?: true
    total?: true
  }

  export type SaleItemMinAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    variantId?: true
    name?: true
    sku?: true
    price?: true
    quantity?: true
    discount?: true
    total?: true
    createdAt?: true
  }

  export type SaleItemMaxAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    variantId?: true
    name?: true
    sku?: true
    price?: true
    quantity?: true
    discount?: true
    total?: true
    createdAt?: true
  }

  export type SaleItemCountAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    variantId?: true
    name?: true
    sku?: true
    price?: true
    quantity?: true
    discount?: true
    total?: true
    createdAt?: true
    _all?: true
  }

  export type SaleItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleItem to aggregate.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleItems
    **/
    _count?: true | SaleItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleItemMaxAggregateInputType
  }

  export type GetSaleItemAggregateType<T extends SaleItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleItem[P]>
      : GetScalarType<T[P], AggregateSaleItem[P]>
  }




  export type SaleItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithAggregationInput | SaleItemOrderByWithAggregationInput[]
    by: SaleItemScalarFieldEnum[] | SaleItemScalarFieldEnum
    having?: SaleItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleItemCountAggregateInputType | true
    _avg?: SaleItemAvgAggregateInputType
    _sum?: SaleItemSumAggregateInputType
    _min?: SaleItemMinAggregateInputType
    _max?: SaleItemMaxAggregateInputType
  }

  export type SaleItemGroupByOutputType = {
    id: string
    saleId: string
    productId: string
    variantId: string | null
    name: string
    sku: string
    price: Decimal
    quantity: number
    discount: Decimal
    total: Decimal
    createdAt: Date
    _count: SaleItemCountAggregateOutputType | null
    _avg: SaleItemAvgAggregateOutputType | null
    _sum: SaleItemSumAggregateOutputType | null
    _min: SaleItemMinAggregateOutputType | null
    _max: SaleItemMaxAggregateOutputType | null
  }

  type GetSaleItemGroupByPayload<T extends SaleItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleItemGroupByOutputType[P]>
            : GetScalarType<T[P], SaleItemGroupByOutputType[P]>
        }
      >
    >


  export type SaleItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    productId?: boolean
    variantId?: boolean
    name?: boolean
    sku?: boolean
    price?: boolean
    quantity?: boolean
    discount?: boolean
    total?: boolean
    createdAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    variant?: boolean | SaleItem$variantArgs<ExtArgs>
  }, ExtArgs["result"]["saleItem"]>


  export type SaleItemSelectScalar = {
    id?: boolean
    saleId?: boolean
    productId?: boolean
    variantId?: boolean
    name?: boolean
    sku?: boolean
    price?: boolean
    quantity?: boolean
    discount?: boolean
    total?: boolean
    createdAt?: boolean
  }

  export type SaleItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    variant?: boolean | SaleItem$variantArgs<ExtArgs>
  }

  export type $SaleItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleItem"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      variant: Prisma.$ProductVariantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleId: string
      productId: string
      variantId: string | null
      name: string
      sku: string
      price: Prisma.Decimal
      quantity: number
      discount: Prisma.Decimal
      total: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["saleItem"]>
    composites: {}
  }

  type SaleItemGetPayload<S extends boolean | null | undefined | SaleItemDefaultArgs> = $Result.GetResult<Prisma.$SaleItemPayload, S>

  type SaleItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaleItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaleItemCountAggregateInputType | true
    }

  export interface SaleItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleItem'], meta: { name: 'SaleItem' } }
    /**
     * Find zero or one SaleItem that matches the filter.
     * @param {SaleItemFindUniqueArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleItemFindUniqueArgs>(args: SelectSubset<T, SaleItemFindUniqueArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SaleItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SaleItemFindUniqueOrThrowArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SaleItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemFindFirstArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleItemFindFirstArgs>(args?: SelectSubset<T, SaleItemFindFirstArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SaleItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemFindFirstOrThrowArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SaleItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleItems
     * const saleItems = await prisma.saleItem.findMany()
     * 
     * // Get first 10 SaleItems
     * const saleItems = await prisma.saleItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleItemWithIdOnly = await prisma.saleItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleItemFindManyArgs>(args?: SelectSubset<T, SaleItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SaleItem.
     * @param {SaleItemCreateArgs} args - Arguments to create a SaleItem.
     * @example
     * // Create one SaleItem
     * const SaleItem = await prisma.saleItem.create({
     *   data: {
     *     // ... data to create a SaleItem
     *   }
     * })
     * 
     */
    create<T extends SaleItemCreateArgs>(args: SelectSubset<T, SaleItemCreateArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SaleItems.
     * @param {SaleItemCreateManyArgs} args - Arguments to create many SaleItems.
     * @example
     * // Create many SaleItems
     * const saleItem = await prisma.saleItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleItemCreateManyArgs>(args?: SelectSubset<T, SaleItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SaleItem.
     * @param {SaleItemDeleteArgs} args - Arguments to delete one SaleItem.
     * @example
     * // Delete one SaleItem
     * const SaleItem = await prisma.saleItem.delete({
     *   where: {
     *     // ... filter to delete one SaleItem
     *   }
     * })
     * 
     */
    delete<T extends SaleItemDeleteArgs>(args: SelectSubset<T, SaleItemDeleteArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SaleItem.
     * @param {SaleItemUpdateArgs} args - Arguments to update one SaleItem.
     * @example
     * // Update one SaleItem
     * const saleItem = await prisma.saleItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleItemUpdateArgs>(args: SelectSubset<T, SaleItemUpdateArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SaleItems.
     * @param {SaleItemDeleteManyArgs} args - Arguments to filter SaleItems to delete.
     * @example
     * // Delete a few SaleItems
     * const { count } = await prisma.saleItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleItemDeleteManyArgs>(args?: SelectSubset<T, SaleItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleItems
     * const saleItem = await prisma.saleItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleItemUpdateManyArgs>(args: SelectSubset<T, SaleItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SaleItem.
     * @param {SaleItemUpsertArgs} args - Arguments to update or create a SaleItem.
     * @example
     * // Update or create a SaleItem
     * const saleItem = await prisma.saleItem.upsert({
     *   create: {
     *     // ... data to create a SaleItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleItem we want to update
     *   }
     * })
     */
    upsert<T extends SaleItemUpsertArgs>(args: SelectSubset<T, SaleItemUpsertArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SaleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemCountArgs} args - Arguments to filter SaleItems to count.
     * @example
     * // Count the number of SaleItems
     * const count = await prisma.saleItem.count({
     *   where: {
     *     // ... the filter for the SaleItems we want to count
     *   }
     * })
    **/
    count<T extends SaleItemCountArgs>(
      args?: Subset<T, SaleItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleItemAggregateArgs>(args: Subset<T, SaleItemAggregateArgs>): Prisma.PrismaPromise<GetSaleItemAggregateType<T>>

    /**
     * Group by SaleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleItemGroupByArgs['orderBy'] }
        : { orderBy?: SaleItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleItem model
   */
  readonly fields: SaleItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    variant<T extends SaleItem$variantArgs<ExtArgs> = {}>(args?: Subset<T, SaleItem$variantArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleItem model
   */ 
  interface SaleItemFieldRefs {
    readonly id: FieldRef<"SaleItem", 'String'>
    readonly saleId: FieldRef<"SaleItem", 'String'>
    readonly productId: FieldRef<"SaleItem", 'String'>
    readonly variantId: FieldRef<"SaleItem", 'String'>
    readonly name: FieldRef<"SaleItem", 'String'>
    readonly sku: FieldRef<"SaleItem", 'String'>
    readonly price: FieldRef<"SaleItem", 'Decimal'>
    readonly quantity: FieldRef<"SaleItem", 'Int'>
    readonly discount: FieldRef<"SaleItem", 'Decimal'>
    readonly total: FieldRef<"SaleItem", 'Decimal'>
    readonly createdAt: FieldRef<"SaleItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaleItem findUnique
   */
  export type SaleItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem findUniqueOrThrow
   */
  export type SaleItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem findFirst
   */
  export type SaleItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleItems.
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleItems.
     */
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * SaleItem findFirstOrThrow
   */
  export type SaleItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleItems.
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleItems.
     */
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * SaleItem findMany
   */
  export type SaleItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItems to fetch.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleItems.
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * SaleItem create
   */
  export type SaleItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleItem.
     */
    data: XOR<SaleItemCreateInput, SaleItemUncheckedCreateInput>
  }

  /**
   * SaleItem createMany
   */
  export type SaleItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleItems.
     */
    data: SaleItemCreateManyInput | SaleItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleItem update
   */
  export type SaleItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleItem.
     */
    data: XOR<SaleItemUpdateInput, SaleItemUncheckedUpdateInput>
    /**
     * Choose, which SaleItem to update.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem updateMany
   */
  export type SaleItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleItems.
     */
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyInput>
    /**
     * Filter which SaleItems to update
     */
    where?: SaleItemWhereInput
  }

  /**
   * SaleItem upsert
   */
  export type SaleItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleItem to update in case it exists.
     */
    where: SaleItemWhereUniqueInput
    /**
     * In case the SaleItem found by the `where` argument doesn't exist, create a new SaleItem with this data.
     */
    create: XOR<SaleItemCreateInput, SaleItemUncheckedCreateInput>
    /**
     * In case the SaleItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleItemUpdateInput, SaleItemUncheckedUpdateInput>
  }

  /**
   * SaleItem delete
   */
  export type SaleItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter which SaleItem to delete.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem deleteMany
   */
  export type SaleItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleItems to delete
     */
    where?: SaleItemWhereInput
  }

  /**
   * SaleItem.variant
   */
  export type SaleItem$variantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    where?: ProductVariantWhereInput
  }

  /**
   * SaleItem without action
   */
  export type SaleItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    name: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    address: string | null
    paymentTerms: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    name: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    address: string | null
    paymentTerms: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    vendorId: number
    name: number
    contactPerson: number
    email: number
    phone: number
    address: number
    paymentTerms: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    paymentTerms?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    paymentTerms?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    paymentTerms?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    vendorId: string
    name: string
    contactPerson: string | null
    email: string | null
    phone: string | null
    address: string | null
    paymentTerms: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    paymentTerms?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    purchases?: boolean | Supplier$purchasesArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>


  export type SupplierSelectScalar = {
    id?: boolean
    vendorId?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    paymentTerms?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    purchases?: boolean | Supplier$purchasesArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      name: string
      contactPerson: string | null
      email: string | null
      phone: string | null
      address: string | null
      paymentTerms: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    purchases<T extends Supplier$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly vendorId: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly contactPerson: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'String'>
    readonly paymentTerms: FieldRef<"Supplier", 'String'>
    readonly isActive: FieldRef<"Supplier", 'Boolean'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier.purchases
   */
  export type Supplier$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    subtotal: Decimal | null
    tax: Decimal | null
    total: Decimal | null
  }

  export type PurchaseSumAggregateOutputType = {
    subtotal: Decimal | null
    tax: Decimal | null
    total: Decimal | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    supplierId: string | null
    purchaseNumber: string | null
    subtotal: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    status: $Enums.PurchaseStatus | null
    deliveryDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    supplierId: string | null
    purchaseNumber: string | null
    subtotal: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    status: $Enums.PurchaseStatus | null
    deliveryDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    vendorId: number
    supplierId: number
    purchaseNumber: number
    subtotal: number
    tax: number
    total: number
    status: number
    deliveryDate: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type PurchaseSumAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    vendorId?: true
    supplierId?: true
    purchaseNumber?: true
    subtotal?: true
    tax?: true
    total?: true
    status?: true
    deliveryDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    vendorId?: true
    supplierId?: true
    purchaseNumber?: true
    subtotal?: true
    tax?: true
    total?: true
    status?: true
    deliveryDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    vendorId?: true
    supplierId?: true
    purchaseNumber?: true
    subtotal?: true
    tax?: true
    total?: true
    status?: true
    deliveryDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: string
    vendorId: string
    supplierId: string
    purchaseNumber: string
    subtotal: Decimal
    tax: Decimal
    total: Decimal
    status: $Enums.PurchaseStatus
    deliveryDate: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    supplierId?: boolean
    purchaseNumber?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    status?: boolean
    deliveryDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    items?: boolean | Purchase$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>


  export type PurchaseSelectScalar = {
    id?: boolean
    vendorId?: boolean
    supplierId?: boolean
    purchaseNumber?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    status?: boolean
    deliveryDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    items?: boolean | Purchase$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
      items: Prisma.$PurchaseItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      supplierId: string
      purchaseNumber: string
      subtotal: Prisma.Decimal
      tax: Prisma.Decimal
      total: Prisma.Decimal
      status: $Enums.PurchaseStatus
      deliveryDate: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseFindUniqueArgs>(args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseFindFirstArgs>(args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseFindManyArgs>(args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
     */
    create<T extends PurchaseCreateArgs>(args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Purchases.
     * @param {PurchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseCreateManyArgs>(args?: SelectSubset<T, PurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeleteArgs>(args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseUpdateArgs>(args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseUpdateManyArgs>(args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseUpsertArgs>(args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Purchase$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchase model
   */ 
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'String'>
    readonly vendorId: FieldRef<"Purchase", 'String'>
    readonly supplierId: FieldRef<"Purchase", 'String'>
    readonly purchaseNumber: FieldRef<"Purchase", 'String'>
    readonly subtotal: FieldRef<"Purchase", 'Decimal'>
    readonly tax: FieldRef<"Purchase", 'Decimal'>
    readonly total: FieldRef<"Purchase", 'Decimal'>
    readonly status: FieldRef<"Purchase", 'PurchaseStatus'>
    readonly deliveryDate: FieldRef<"Purchase", 'DateTime'>
    readonly notes: FieldRef<"Purchase", 'String'>
    readonly createdAt: FieldRef<"Purchase", 'DateTime'>
    readonly updatedAt: FieldRef<"Purchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }

  /**
   * Purchase createMany
   */
  export type PurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
  }

  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }

  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
  }

  /**
   * Purchase.items
   */
  export type Purchase$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    cursor?: PurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseItem
   */

  export type AggregatePurchaseItem = {
    _count: PurchaseItemCountAggregateOutputType | null
    _avg: PurchaseItemAvgAggregateOutputType | null
    _sum: PurchaseItemSumAggregateOutputType | null
    _min: PurchaseItemMinAggregateOutputType | null
    _max: PurchaseItemMaxAggregateOutputType | null
  }

  export type PurchaseItemAvgAggregateOutputType = {
    costPrice: Decimal | null
    quantity: number | null
    total: Decimal | null
  }

  export type PurchaseItemSumAggregateOutputType = {
    costPrice: Decimal | null
    quantity: number | null
    total: Decimal | null
  }

  export type PurchaseItemMinAggregateOutputType = {
    id: string | null
    purchaseId: string | null
    productId: string | null
    variantId: string | null
    name: string | null
    sku: string | null
    costPrice: Decimal | null
    quantity: number | null
    total: Decimal | null
    createdAt: Date | null
  }

  export type PurchaseItemMaxAggregateOutputType = {
    id: string | null
    purchaseId: string | null
    productId: string | null
    variantId: string | null
    name: string | null
    sku: string | null
    costPrice: Decimal | null
    quantity: number | null
    total: Decimal | null
    createdAt: Date | null
  }

  export type PurchaseItemCountAggregateOutputType = {
    id: number
    purchaseId: number
    productId: number
    variantId: number
    name: number
    sku: number
    costPrice: number
    quantity: number
    total: number
    createdAt: number
    _all: number
  }


  export type PurchaseItemAvgAggregateInputType = {
    costPrice?: true
    quantity?: true
    total?: true
  }

  export type PurchaseItemSumAggregateInputType = {
    costPrice?: true
    quantity?: true
    total?: true
  }

  export type PurchaseItemMinAggregateInputType = {
    id?: true
    purchaseId?: true
    productId?: true
    variantId?: true
    name?: true
    sku?: true
    costPrice?: true
    quantity?: true
    total?: true
    createdAt?: true
  }

  export type PurchaseItemMaxAggregateInputType = {
    id?: true
    purchaseId?: true
    productId?: true
    variantId?: true
    name?: true
    sku?: true
    costPrice?: true
    quantity?: true
    total?: true
    createdAt?: true
  }

  export type PurchaseItemCountAggregateInputType = {
    id?: true
    purchaseId?: true
    productId?: true
    variantId?: true
    name?: true
    sku?: true
    costPrice?: true
    quantity?: true
    total?: true
    createdAt?: true
    _all?: true
  }

  export type PurchaseItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseItem to aggregate.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseItems
    **/
    _count?: true | PurchaseItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseItemMaxAggregateInputType
  }

  export type GetPurchaseItemAggregateType<T extends PurchaseItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseItem[P]>
      : GetScalarType<T[P], AggregatePurchaseItem[P]>
  }




  export type PurchaseItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithAggregationInput | PurchaseItemOrderByWithAggregationInput[]
    by: PurchaseItemScalarFieldEnum[] | PurchaseItemScalarFieldEnum
    having?: PurchaseItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseItemCountAggregateInputType | true
    _avg?: PurchaseItemAvgAggregateInputType
    _sum?: PurchaseItemSumAggregateInputType
    _min?: PurchaseItemMinAggregateInputType
    _max?: PurchaseItemMaxAggregateInputType
  }

  export type PurchaseItemGroupByOutputType = {
    id: string
    purchaseId: string
    productId: string
    variantId: string | null
    name: string
    sku: string
    costPrice: Decimal
    quantity: number
    total: Decimal
    createdAt: Date
    _count: PurchaseItemCountAggregateOutputType | null
    _avg: PurchaseItemAvgAggregateOutputType | null
    _sum: PurchaseItemSumAggregateOutputType | null
    _min: PurchaseItemMinAggregateOutputType | null
    _max: PurchaseItemMaxAggregateOutputType | null
  }

  type GetPurchaseItemGroupByPayload<T extends PurchaseItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseId?: boolean
    productId?: boolean
    variantId?: boolean
    name?: boolean
    sku?: boolean
    costPrice?: boolean
    quantity?: boolean
    total?: boolean
    createdAt?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    variant?: boolean | PurchaseItem$variantArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItem"]>


  export type PurchaseItemSelectScalar = {
    id?: boolean
    purchaseId?: boolean
    productId?: boolean
    variantId?: boolean
    name?: boolean
    sku?: boolean
    costPrice?: boolean
    quantity?: boolean
    total?: boolean
    createdAt?: boolean
  }

  export type PurchaseItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    variant?: boolean | PurchaseItem$variantArgs<ExtArgs>
  }

  export type $PurchaseItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseItem"
    objects: {
      purchase: Prisma.$PurchasePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      variant: Prisma.$ProductVariantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchaseId: string
      productId: string
      variantId: string | null
      name: string
      sku: string
      costPrice: Prisma.Decimal
      quantity: number
      total: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["purchaseItem"]>
    composites: {}
  }

  type PurchaseItemGetPayload<S extends boolean | null | undefined | PurchaseItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseItemPayload, S>

  type PurchaseItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseItemCountAggregateInputType | true
    }

  export interface PurchaseItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseItem'], meta: { name: 'PurchaseItem' } }
    /**
     * Find zero or one PurchaseItem that matches the filter.
     * @param {PurchaseItemFindUniqueArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseItemFindUniqueArgs>(args: SelectSubset<T, PurchaseItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PurchaseItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PurchaseItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindFirstArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseItemFindFirstArgs>(args?: SelectSubset<T, PurchaseItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PurchaseItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PurchaseItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseItems
     * const purchaseItems = await prisma.purchaseItem.findMany()
     * 
     * // Get first 10 PurchaseItems
     * const purchaseItems = await prisma.purchaseItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseItemWithIdOnly = await prisma.purchaseItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseItemFindManyArgs>(args?: SelectSubset<T, PurchaseItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PurchaseItem.
     * @param {PurchaseItemCreateArgs} args - Arguments to create a PurchaseItem.
     * @example
     * // Create one PurchaseItem
     * const PurchaseItem = await prisma.purchaseItem.create({
     *   data: {
     *     // ... data to create a PurchaseItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseItemCreateArgs>(args: SelectSubset<T, PurchaseItemCreateArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PurchaseItems.
     * @param {PurchaseItemCreateManyArgs} args - Arguments to create many PurchaseItems.
     * @example
     * // Create many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseItemCreateManyArgs>(args?: SelectSubset<T, PurchaseItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PurchaseItem.
     * @param {PurchaseItemDeleteArgs} args - Arguments to delete one PurchaseItem.
     * @example
     * // Delete one PurchaseItem
     * const PurchaseItem = await prisma.purchaseItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseItemDeleteArgs>(args: SelectSubset<T, PurchaseItemDeleteArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PurchaseItem.
     * @param {PurchaseItemUpdateArgs} args - Arguments to update one PurchaseItem.
     * @example
     * // Update one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseItemUpdateArgs>(args: SelectSubset<T, PurchaseItemUpdateArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PurchaseItems.
     * @param {PurchaseItemDeleteManyArgs} args - Arguments to filter PurchaseItems to delete.
     * @example
     * // Delete a few PurchaseItems
     * const { count } = await prisma.purchaseItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseItemUpdateManyArgs>(args: SelectSubset<T, PurchaseItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseItem.
     * @param {PurchaseItemUpsertArgs} args - Arguments to update or create a PurchaseItem.
     * @example
     * // Update or create a PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseItemUpsertArgs>(args: SelectSubset<T, PurchaseItemUpsertArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemCountArgs} args - Arguments to filter PurchaseItems to count.
     * @example
     * // Count the number of PurchaseItems
     * const count = await prisma.purchaseItem.count({
     *   where: {
     *     // ... the filter for the PurchaseItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseItemCountArgs>(
      args?: Subset<T, PurchaseItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseItemAggregateArgs>(args: Subset<T, PurchaseItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseItemAggregateType<T>>

    /**
     * Group by PurchaseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseItem model
   */
  readonly fields: PurchaseItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase<T extends PurchaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseDefaultArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    variant<T extends PurchaseItem$variantArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseItem$variantArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseItem model
   */ 
  interface PurchaseItemFieldRefs {
    readonly id: FieldRef<"PurchaseItem", 'String'>
    readonly purchaseId: FieldRef<"PurchaseItem", 'String'>
    readonly productId: FieldRef<"PurchaseItem", 'String'>
    readonly variantId: FieldRef<"PurchaseItem", 'String'>
    readonly name: FieldRef<"PurchaseItem", 'String'>
    readonly sku: FieldRef<"PurchaseItem", 'String'>
    readonly costPrice: FieldRef<"PurchaseItem", 'Decimal'>
    readonly quantity: FieldRef<"PurchaseItem", 'Int'>
    readonly total: FieldRef<"PurchaseItem", 'Decimal'>
    readonly createdAt: FieldRef<"PurchaseItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseItem findUnique
   */
  export type PurchaseItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem findUniqueOrThrow
   */
  export type PurchaseItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem findFirst
   */
  export type PurchaseItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItems.
     */
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem findFirstOrThrow
   */
  export type PurchaseItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItems.
     */
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem findMany
   */
  export type PurchaseItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItems to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem create
   */
  export type PurchaseItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseItem.
     */
    data: XOR<PurchaseItemCreateInput, PurchaseItemUncheckedCreateInput>
  }

  /**
   * PurchaseItem createMany
   */
  export type PurchaseItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseItems.
     */
    data: PurchaseItemCreateManyInput | PurchaseItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseItem update
   */
  export type PurchaseItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseItem.
     */
    data: XOR<PurchaseItemUpdateInput, PurchaseItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseItem to update.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem updateMany
   */
  export type PurchaseItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseItems.
     */
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseItems to update
     */
    where?: PurchaseItemWhereInput
  }

  /**
   * PurchaseItem upsert
   */
  export type PurchaseItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseItem to update in case it exists.
     */
    where: PurchaseItemWhereUniqueInput
    /**
     * In case the PurchaseItem found by the `where` argument doesn't exist, create a new PurchaseItem with this data.
     */
    create: XOR<PurchaseItemCreateInput, PurchaseItemUncheckedCreateInput>
    /**
     * In case the PurchaseItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseItemUpdateInput, PurchaseItemUncheckedUpdateInput>
  }

  /**
   * PurchaseItem delete
   */
  export type PurchaseItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseItem to delete.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem deleteMany
   */
  export type PurchaseItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseItems to delete
     */
    where?: PurchaseItemWhereInput
  }

  /**
   * PurchaseItem.variant
   */
  export type PurchaseItem$variantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    where?: ProductVariantWhereInput
  }

  /**
   * PurchaseItem without action
   */
  export type PurchaseItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
  }


  /**
   * Model StockMovement
   */

  export type AggregateStockMovement = {
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  export type StockMovementAvgAggregateOutputType = {
    quantity: number | null
  }

  export type StockMovementSumAggregateOutputType = {
    quantity: number | null
  }

  export type StockMovementMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    productId: string | null
    variantId: string | null
    movementType: $Enums.StockMovementType | null
    quantity: number | null
    referenceType: string | null
    referenceId: string | null
    referenceNumber: string | null
    locationFrom: string | null
    locationTo: string | null
    notes: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type StockMovementMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    productId: string | null
    variantId: string | null
    movementType: $Enums.StockMovementType | null
    quantity: number | null
    referenceType: string | null
    referenceId: string | null
    referenceNumber: string | null
    locationFrom: string | null
    locationTo: string | null
    notes: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type StockMovementCountAggregateOutputType = {
    id: number
    vendorId: number
    productId: number
    variantId: number
    movementType: number
    quantity: number
    referenceType: number
    referenceId: number
    referenceNumber: number
    locationFrom: number
    locationTo: number
    notes: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type StockMovementAvgAggregateInputType = {
    quantity?: true
  }

  export type StockMovementSumAggregateInputType = {
    quantity?: true
  }

  export type StockMovementMinAggregateInputType = {
    id?: true
    vendorId?: true
    productId?: true
    variantId?: true
    movementType?: true
    quantity?: true
    referenceType?: true
    referenceId?: true
    referenceNumber?: true
    locationFrom?: true
    locationTo?: true
    notes?: true
    createdBy?: true
    createdAt?: true
  }

  export type StockMovementMaxAggregateInputType = {
    id?: true
    vendorId?: true
    productId?: true
    variantId?: true
    movementType?: true
    quantity?: true
    referenceType?: true
    referenceId?: true
    referenceNumber?: true
    locationFrom?: true
    locationTo?: true
    notes?: true
    createdBy?: true
    createdAt?: true
  }

  export type StockMovementCountAggregateInputType = {
    id?: true
    vendorId?: true
    productId?: true
    variantId?: true
    movementType?: true
    quantity?: true
    referenceType?: true
    referenceId?: true
    referenceNumber?: true
    locationFrom?: true
    locationTo?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type StockMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovement to aggregate.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockMovements
    **/
    _count?: true | StockMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMovementMaxAggregateInputType
  }

  export type GetStockMovementAggregateType<T extends StockMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateStockMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockMovement[P]>
      : GetScalarType<T[P], AggregateStockMovement[P]>
  }




  export type StockMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithAggregationInput | StockMovementOrderByWithAggregationInput[]
    by: StockMovementScalarFieldEnum[] | StockMovementScalarFieldEnum
    having?: StockMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockMovementCountAggregateInputType | true
    _avg?: StockMovementAvgAggregateInputType
    _sum?: StockMovementSumAggregateInputType
    _min?: StockMovementMinAggregateInputType
    _max?: StockMovementMaxAggregateInputType
  }

  export type StockMovementGroupByOutputType = {
    id: string
    vendorId: string
    productId: string
    variantId: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    referenceType: string | null
    referenceId: string | null
    referenceNumber: string | null
    locationFrom: string | null
    locationTo: string | null
    notes: string | null
    createdBy: string
    createdAt: Date
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  type GetStockMovementGroupByPayload<T extends StockMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
            : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
        }
      >
    >


  export type StockMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    productId?: boolean
    variantId?: boolean
    movementType?: boolean
    quantity?: boolean
    referenceType?: boolean
    referenceId?: boolean
    referenceNumber?: boolean
    locationFrom?: boolean
    locationTo?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    variant?: boolean | StockMovement$variantArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockMovement"]>


  export type StockMovementSelectScalar = {
    id?: boolean
    vendorId?: boolean
    productId?: boolean
    variantId?: boolean
    movementType?: boolean
    quantity?: boolean
    referenceType?: boolean
    referenceId?: boolean
    referenceNumber?: boolean
    locationFrom?: boolean
    locationTo?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type StockMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    variant?: boolean | StockMovement$variantArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StockMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockMovement"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      variant: Prisma.$ProductVariantPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      productId: string
      variantId: string | null
      movementType: $Enums.StockMovementType
      quantity: number
      referenceType: string | null
      referenceId: string | null
      referenceNumber: string | null
      locationFrom: string | null
      locationTo: string | null
      notes: string | null
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["stockMovement"]>
    composites: {}
  }

  type StockMovementGetPayload<S extends boolean | null | undefined | StockMovementDefaultArgs> = $Result.GetResult<Prisma.$StockMovementPayload, S>

  type StockMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockMovementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockMovementCountAggregateInputType | true
    }

  export interface StockMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockMovement'], meta: { name: 'StockMovement' } }
    /**
     * Find zero or one StockMovement that matches the filter.
     * @param {StockMovementFindUniqueArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockMovementFindUniqueArgs>(args: SelectSubset<T, StockMovementFindUniqueArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StockMovement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StockMovementFindUniqueOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, StockMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StockMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockMovementFindFirstArgs>(args?: SelectSubset<T, StockMovementFindFirstArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StockMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, StockMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StockMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockMovements
     * const stockMovements = await prisma.stockMovement.findMany()
     * 
     * // Get first 10 StockMovements
     * const stockMovements = await prisma.stockMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockMovementWithIdOnly = await prisma.stockMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockMovementFindManyArgs>(args?: SelectSubset<T, StockMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StockMovement.
     * @param {StockMovementCreateArgs} args - Arguments to create a StockMovement.
     * @example
     * // Create one StockMovement
     * const StockMovement = await prisma.stockMovement.create({
     *   data: {
     *     // ... data to create a StockMovement
     *   }
     * })
     * 
     */
    create<T extends StockMovementCreateArgs>(args: SelectSubset<T, StockMovementCreateArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StockMovements.
     * @param {StockMovementCreateManyArgs} args - Arguments to create many StockMovements.
     * @example
     * // Create many StockMovements
     * const stockMovement = await prisma.stockMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockMovementCreateManyArgs>(args?: SelectSubset<T, StockMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockMovement.
     * @param {StockMovementDeleteArgs} args - Arguments to delete one StockMovement.
     * @example
     * // Delete one StockMovement
     * const StockMovement = await prisma.stockMovement.delete({
     *   where: {
     *     // ... filter to delete one StockMovement
     *   }
     * })
     * 
     */
    delete<T extends StockMovementDeleteArgs>(args: SelectSubset<T, StockMovementDeleteArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StockMovement.
     * @param {StockMovementUpdateArgs} args - Arguments to update one StockMovement.
     * @example
     * // Update one StockMovement
     * const stockMovement = await prisma.stockMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockMovementUpdateArgs>(args: SelectSubset<T, StockMovementUpdateArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StockMovements.
     * @param {StockMovementDeleteManyArgs} args - Arguments to filter StockMovements to delete.
     * @example
     * // Delete a few StockMovements
     * const { count } = await prisma.stockMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockMovementDeleteManyArgs>(args?: SelectSubset<T, StockMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockMovements
     * const stockMovement = await prisma.stockMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockMovementUpdateManyArgs>(args: SelectSubset<T, StockMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockMovement.
     * @param {StockMovementUpsertArgs} args - Arguments to update or create a StockMovement.
     * @example
     * // Update or create a StockMovement
     * const stockMovement = await prisma.stockMovement.upsert({
     *   create: {
     *     // ... data to create a StockMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockMovement we want to update
     *   }
     * })
     */
    upsert<T extends StockMovementUpsertArgs>(args: SelectSubset<T, StockMovementUpsertArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementCountArgs} args - Arguments to filter StockMovements to count.
     * @example
     * // Count the number of StockMovements
     * const count = await prisma.stockMovement.count({
     *   where: {
     *     // ... the filter for the StockMovements we want to count
     *   }
     * })
    **/
    count<T extends StockMovementCountArgs>(
      args?: Subset<T, StockMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockMovementAggregateArgs>(args: Subset<T, StockMovementAggregateArgs>): Prisma.PrismaPromise<GetStockMovementAggregateType<T>>

    /**
     * Group by StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockMovementGroupByArgs['orderBy'] }
        : { orderBy?: StockMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockMovement model
   */
  readonly fields: StockMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    variant<T extends StockMovement$variantArgs<ExtArgs> = {}>(args?: Subset<T, StockMovement$variantArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockMovement model
   */ 
  interface StockMovementFieldRefs {
    readonly id: FieldRef<"StockMovement", 'String'>
    readonly vendorId: FieldRef<"StockMovement", 'String'>
    readonly productId: FieldRef<"StockMovement", 'String'>
    readonly variantId: FieldRef<"StockMovement", 'String'>
    readonly movementType: FieldRef<"StockMovement", 'StockMovementType'>
    readonly quantity: FieldRef<"StockMovement", 'Int'>
    readonly referenceType: FieldRef<"StockMovement", 'String'>
    readonly referenceId: FieldRef<"StockMovement", 'String'>
    readonly referenceNumber: FieldRef<"StockMovement", 'String'>
    readonly locationFrom: FieldRef<"StockMovement", 'String'>
    readonly locationTo: FieldRef<"StockMovement", 'String'>
    readonly notes: FieldRef<"StockMovement", 'String'>
    readonly createdBy: FieldRef<"StockMovement", 'String'>
    readonly createdAt: FieldRef<"StockMovement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockMovement findUnique
   */
  export type StockMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement findUniqueOrThrow
   */
  export type StockMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement findFirst
   */
  export type StockMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement findFirstOrThrow
   */
  export type StockMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement findMany
   */
  export type StockMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovements to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement create
   */
  export type StockMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a StockMovement.
     */
    data: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
  }

  /**
   * StockMovement createMany
   */
  export type StockMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockMovements.
     */
    data: StockMovementCreateManyInput | StockMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockMovement update
   */
  export type StockMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a StockMovement.
     */
    data: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
    /**
     * Choose, which StockMovement to update.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement updateMany
   */
  export type StockMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockMovements.
     */
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyInput>
    /**
     * Filter which StockMovements to update
     */
    where?: StockMovementWhereInput
  }

  /**
   * StockMovement upsert
   */
  export type StockMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the StockMovement to update in case it exists.
     */
    where: StockMovementWhereUniqueInput
    /**
     * In case the StockMovement found by the `where` argument doesn't exist, create a new StockMovement with this data.
     */
    create: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
    /**
     * In case the StockMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
  }

  /**
   * StockMovement delete
   */
  export type StockMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter which StockMovement to delete.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement deleteMany
   */
  export type StockMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovements to delete
     */
    where?: StockMovementWhereInput
  }

  /**
   * StockMovement.variant
   */
  export type StockMovement$variantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    where?: ProductVariantWhereInput
  }

  /**
   * StockMovement without action
   */
  export type StockMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
  }


  /**
   * Model StockTake
   */

  export type AggregateStockTake = {
    _count: StockTakeCountAggregateOutputType | null
    _min: StockTakeMinAggregateOutputType | null
    _max: StockTakeMaxAggregateOutputType | null
  }

  export type StockTakeMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    location: string | null
    status: $Enums.StockTakeStatus | null
    notes: string | null
    createdBy: string | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockTakeMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    location: string | null
    status: $Enums.StockTakeStatus | null
    notes: string | null
    createdBy: string | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockTakeCountAggregateOutputType = {
    id: number
    vendorId: number
    location: number
    status: number
    notes: number
    createdBy: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockTakeMinAggregateInputType = {
    id?: true
    vendorId?: true
    location?: true
    status?: true
    notes?: true
    createdBy?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockTakeMaxAggregateInputType = {
    id?: true
    vendorId?: true
    location?: true
    status?: true
    notes?: true
    createdBy?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockTakeCountAggregateInputType = {
    id?: true
    vendorId?: true
    location?: true
    status?: true
    notes?: true
    createdBy?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockTakeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTake to aggregate.
     */
    where?: StockTakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTakes to fetch.
     */
    orderBy?: StockTakeOrderByWithRelationInput | StockTakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockTakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockTakes
    **/
    _count?: true | StockTakeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockTakeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockTakeMaxAggregateInputType
  }

  export type GetStockTakeAggregateType<T extends StockTakeAggregateArgs> = {
        [P in keyof T & keyof AggregateStockTake]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockTake[P]>
      : GetScalarType<T[P], AggregateStockTake[P]>
  }




  export type StockTakeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTakeWhereInput
    orderBy?: StockTakeOrderByWithAggregationInput | StockTakeOrderByWithAggregationInput[]
    by: StockTakeScalarFieldEnum[] | StockTakeScalarFieldEnum
    having?: StockTakeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockTakeCountAggregateInputType | true
    _min?: StockTakeMinAggregateInputType
    _max?: StockTakeMaxAggregateInputType
  }

  export type StockTakeGroupByOutputType = {
    id: string
    vendorId: string
    location: string
    status: $Enums.StockTakeStatus
    notes: string | null
    createdBy: string
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: StockTakeCountAggregateOutputType | null
    _min: StockTakeMinAggregateOutputType | null
    _max: StockTakeMaxAggregateOutputType | null
  }

  type GetStockTakeGroupByPayload<T extends StockTakeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockTakeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockTakeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockTakeGroupByOutputType[P]>
            : GetScalarType<T[P], StockTakeGroupByOutputType[P]>
        }
      >
    >


  export type StockTakeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    location?: boolean
    status?: boolean
    notes?: boolean
    createdBy?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | StockTake$itemsArgs<ExtArgs>
    _count?: boolean | StockTakeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTake"]>


  export type StockTakeSelectScalar = {
    id?: boolean
    vendorId?: boolean
    location?: boolean
    status?: boolean
    notes?: boolean
    createdBy?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockTakeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | StockTake$itemsArgs<ExtArgs>
    _count?: boolean | StockTakeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StockTakePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockTake"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$StockTakeItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      location: string
      status: $Enums.StockTakeStatus
      notes: string | null
      createdBy: string
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stockTake"]>
    composites: {}
  }

  type StockTakeGetPayload<S extends boolean | null | undefined | StockTakeDefaultArgs> = $Result.GetResult<Prisma.$StockTakePayload, S>

  type StockTakeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockTakeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockTakeCountAggregateInputType | true
    }

  export interface StockTakeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockTake'], meta: { name: 'StockTake' } }
    /**
     * Find zero or one StockTake that matches the filter.
     * @param {StockTakeFindUniqueArgs} args - Arguments to find a StockTake
     * @example
     * // Get one StockTake
     * const stockTake = await prisma.stockTake.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockTakeFindUniqueArgs>(args: SelectSubset<T, StockTakeFindUniqueArgs<ExtArgs>>): Prisma__StockTakeClient<$Result.GetResult<Prisma.$StockTakePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StockTake that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StockTakeFindUniqueOrThrowArgs} args - Arguments to find a StockTake
     * @example
     * // Get one StockTake
     * const stockTake = await prisma.stockTake.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockTakeFindUniqueOrThrowArgs>(args: SelectSubset<T, StockTakeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockTakeClient<$Result.GetResult<Prisma.$StockTakePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StockTake that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTakeFindFirstArgs} args - Arguments to find a StockTake
     * @example
     * // Get one StockTake
     * const stockTake = await prisma.stockTake.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockTakeFindFirstArgs>(args?: SelectSubset<T, StockTakeFindFirstArgs<ExtArgs>>): Prisma__StockTakeClient<$Result.GetResult<Prisma.$StockTakePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StockTake that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTakeFindFirstOrThrowArgs} args - Arguments to find a StockTake
     * @example
     * // Get one StockTake
     * const stockTake = await prisma.stockTake.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockTakeFindFirstOrThrowArgs>(args?: SelectSubset<T, StockTakeFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockTakeClient<$Result.GetResult<Prisma.$StockTakePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StockTakes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTakeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockTakes
     * const stockTakes = await prisma.stockTake.findMany()
     * 
     * // Get first 10 StockTakes
     * const stockTakes = await prisma.stockTake.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockTakeWithIdOnly = await prisma.stockTake.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockTakeFindManyArgs>(args?: SelectSubset<T, StockTakeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTakePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StockTake.
     * @param {StockTakeCreateArgs} args - Arguments to create a StockTake.
     * @example
     * // Create one StockTake
     * const StockTake = await prisma.stockTake.create({
     *   data: {
     *     // ... data to create a StockTake
     *   }
     * })
     * 
     */
    create<T extends StockTakeCreateArgs>(args: SelectSubset<T, StockTakeCreateArgs<ExtArgs>>): Prisma__StockTakeClient<$Result.GetResult<Prisma.$StockTakePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StockTakes.
     * @param {StockTakeCreateManyArgs} args - Arguments to create many StockTakes.
     * @example
     * // Create many StockTakes
     * const stockTake = await prisma.stockTake.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockTakeCreateManyArgs>(args?: SelectSubset<T, StockTakeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockTake.
     * @param {StockTakeDeleteArgs} args - Arguments to delete one StockTake.
     * @example
     * // Delete one StockTake
     * const StockTake = await prisma.stockTake.delete({
     *   where: {
     *     // ... filter to delete one StockTake
     *   }
     * })
     * 
     */
    delete<T extends StockTakeDeleteArgs>(args: SelectSubset<T, StockTakeDeleteArgs<ExtArgs>>): Prisma__StockTakeClient<$Result.GetResult<Prisma.$StockTakePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StockTake.
     * @param {StockTakeUpdateArgs} args - Arguments to update one StockTake.
     * @example
     * // Update one StockTake
     * const stockTake = await prisma.stockTake.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockTakeUpdateArgs>(args: SelectSubset<T, StockTakeUpdateArgs<ExtArgs>>): Prisma__StockTakeClient<$Result.GetResult<Prisma.$StockTakePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StockTakes.
     * @param {StockTakeDeleteManyArgs} args - Arguments to filter StockTakes to delete.
     * @example
     * // Delete a few StockTakes
     * const { count } = await prisma.stockTake.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockTakeDeleteManyArgs>(args?: SelectSubset<T, StockTakeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTakeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockTakes
     * const stockTake = await prisma.stockTake.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockTakeUpdateManyArgs>(args: SelectSubset<T, StockTakeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockTake.
     * @param {StockTakeUpsertArgs} args - Arguments to update or create a StockTake.
     * @example
     * // Update or create a StockTake
     * const stockTake = await prisma.stockTake.upsert({
     *   create: {
     *     // ... data to create a StockTake
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockTake we want to update
     *   }
     * })
     */
    upsert<T extends StockTakeUpsertArgs>(args: SelectSubset<T, StockTakeUpsertArgs<ExtArgs>>): Prisma__StockTakeClient<$Result.GetResult<Prisma.$StockTakePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StockTakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTakeCountArgs} args - Arguments to filter StockTakes to count.
     * @example
     * // Count the number of StockTakes
     * const count = await prisma.stockTake.count({
     *   where: {
     *     // ... the filter for the StockTakes we want to count
     *   }
     * })
    **/
    count<T extends StockTakeCountArgs>(
      args?: Subset<T, StockTakeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockTakeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockTake.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTakeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockTakeAggregateArgs>(args: Subset<T, StockTakeAggregateArgs>): Prisma.PrismaPromise<GetStockTakeAggregateType<T>>

    /**
     * Group by StockTake.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTakeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockTakeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockTakeGroupByArgs['orderBy'] }
        : { orderBy?: StockTakeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockTakeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockTakeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockTake model
   */
  readonly fields: StockTakeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockTake.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockTakeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends StockTake$itemsArgs<ExtArgs> = {}>(args?: Subset<T, StockTake$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTakeItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockTake model
   */ 
  interface StockTakeFieldRefs {
    readonly id: FieldRef<"StockTake", 'String'>
    readonly vendorId: FieldRef<"StockTake", 'String'>
    readonly location: FieldRef<"StockTake", 'String'>
    readonly status: FieldRef<"StockTake", 'StockTakeStatus'>
    readonly notes: FieldRef<"StockTake", 'String'>
    readonly createdBy: FieldRef<"StockTake", 'String'>
    readonly completedAt: FieldRef<"StockTake", 'DateTime'>
    readonly createdAt: FieldRef<"StockTake", 'DateTime'>
    readonly updatedAt: FieldRef<"StockTake", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockTake findUnique
   */
  export type StockTakeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTake
     */
    select?: StockTakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeInclude<ExtArgs> | null
    /**
     * Filter, which StockTake to fetch.
     */
    where: StockTakeWhereUniqueInput
  }

  /**
   * StockTake findUniqueOrThrow
   */
  export type StockTakeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTake
     */
    select?: StockTakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeInclude<ExtArgs> | null
    /**
     * Filter, which StockTake to fetch.
     */
    where: StockTakeWhereUniqueInput
  }

  /**
   * StockTake findFirst
   */
  export type StockTakeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTake
     */
    select?: StockTakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeInclude<ExtArgs> | null
    /**
     * Filter, which StockTake to fetch.
     */
    where?: StockTakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTakes to fetch.
     */
    orderBy?: StockTakeOrderByWithRelationInput | StockTakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTakes.
     */
    cursor?: StockTakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTakes.
     */
    distinct?: StockTakeScalarFieldEnum | StockTakeScalarFieldEnum[]
  }

  /**
   * StockTake findFirstOrThrow
   */
  export type StockTakeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTake
     */
    select?: StockTakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeInclude<ExtArgs> | null
    /**
     * Filter, which StockTake to fetch.
     */
    where?: StockTakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTakes to fetch.
     */
    orderBy?: StockTakeOrderByWithRelationInput | StockTakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTakes.
     */
    cursor?: StockTakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTakes.
     */
    distinct?: StockTakeScalarFieldEnum | StockTakeScalarFieldEnum[]
  }

  /**
   * StockTake findMany
   */
  export type StockTakeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTake
     */
    select?: StockTakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeInclude<ExtArgs> | null
    /**
     * Filter, which StockTakes to fetch.
     */
    where?: StockTakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTakes to fetch.
     */
    orderBy?: StockTakeOrderByWithRelationInput | StockTakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockTakes.
     */
    cursor?: StockTakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTakes.
     */
    skip?: number
    distinct?: StockTakeScalarFieldEnum | StockTakeScalarFieldEnum[]
  }

  /**
   * StockTake create
   */
  export type StockTakeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTake
     */
    select?: StockTakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeInclude<ExtArgs> | null
    /**
     * The data needed to create a StockTake.
     */
    data: XOR<StockTakeCreateInput, StockTakeUncheckedCreateInput>
  }

  /**
   * StockTake createMany
   */
  export type StockTakeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockTakes.
     */
    data: StockTakeCreateManyInput | StockTakeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockTake update
   */
  export type StockTakeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTake
     */
    select?: StockTakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeInclude<ExtArgs> | null
    /**
     * The data needed to update a StockTake.
     */
    data: XOR<StockTakeUpdateInput, StockTakeUncheckedUpdateInput>
    /**
     * Choose, which StockTake to update.
     */
    where: StockTakeWhereUniqueInput
  }

  /**
   * StockTake updateMany
   */
  export type StockTakeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockTakes.
     */
    data: XOR<StockTakeUpdateManyMutationInput, StockTakeUncheckedUpdateManyInput>
    /**
     * Filter which StockTakes to update
     */
    where?: StockTakeWhereInput
  }

  /**
   * StockTake upsert
   */
  export type StockTakeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTake
     */
    select?: StockTakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeInclude<ExtArgs> | null
    /**
     * The filter to search for the StockTake to update in case it exists.
     */
    where: StockTakeWhereUniqueInput
    /**
     * In case the StockTake found by the `where` argument doesn't exist, create a new StockTake with this data.
     */
    create: XOR<StockTakeCreateInput, StockTakeUncheckedCreateInput>
    /**
     * In case the StockTake was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockTakeUpdateInput, StockTakeUncheckedUpdateInput>
  }

  /**
   * StockTake delete
   */
  export type StockTakeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTake
     */
    select?: StockTakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeInclude<ExtArgs> | null
    /**
     * Filter which StockTake to delete.
     */
    where: StockTakeWhereUniqueInput
  }

  /**
   * StockTake deleteMany
   */
  export type StockTakeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTakes to delete
     */
    where?: StockTakeWhereInput
  }

  /**
   * StockTake.items
   */
  export type StockTake$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTakeItem
     */
    select?: StockTakeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeItemInclude<ExtArgs> | null
    where?: StockTakeItemWhereInput
    orderBy?: StockTakeItemOrderByWithRelationInput | StockTakeItemOrderByWithRelationInput[]
    cursor?: StockTakeItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTakeItemScalarFieldEnum | StockTakeItemScalarFieldEnum[]
  }

  /**
   * StockTake without action
   */
  export type StockTakeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTake
     */
    select?: StockTakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeInclude<ExtArgs> | null
  }


  /**
   * Model StockTakeItem
   */

  export type AggregateStockTakeItem = {
    _count: StockTakeItemCountAggregateOutputType | null
    _avg: StockTakeItemAvgAggregateOutputType | null
    _sum: StockTakeItemSumAggregateOutputType | null
    _min: StockTakeItemMinAggregateOutputType | null
    _max: StockTakeItemMaxAggregateOutputType | null
  }

  export type StockTakeItemAvgAggregateOutputType = {
    expectedQuantity: number | null
    countedQuantity: number | null
  }

  export type StockTakeItemSumAggregateOutputType = {
    expectedQuantity: number | null
    countedQuantity: number | null
  }

  export type StockTakeItemMinAggregateOutputType = {
    id: string | null
    stockTakeId: string | null
    productId: string | null
    variantId: string | null
    productName: string | null
    sku: string | null
    expectedQuantity: number | null
    countedQuantity: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type StockTakeItemMaxAggregateOutputType = {
    id: string | null
    stockTakeId: string | null
    productId: string | null
    variantId: string | null
    productName: string | null
    sku: string | null
    expectedQuantity: number | null
    countedQuantity: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type StockTakeItemCountAggregateOutputType = {
    id: number
    stockTakeId: number
    productId: number
    variantId: number
    productName: number
    sku: number
    expectedQuantity: number
    countedQuantity: number
    notes: number
    createdAt: number
    _all: number
  }


  export type StockTakeItemAvgAggregateInputType = {
    expectedQuantity?: true
    countedQuantity?: true
  }

  export type StockTakeItemSumAggregateInputType = {
    expectedQuantity?: true
    countedQuantity?: true
  }

  export type StockTakeItemMinAggregateInputType = {
    id?: true
    stockTakeId?: true
    productId?: true
    variantId?: true
    productName?: true
    sku?: true
    expectedQuantity?: true
    countedQuantity?: true
    notes?: true
    createdAt?: true
  }

  export type StockTakeItemMaxAggregateInputType = {
    id?: true
    stockTakeId?: true
    productId?: true
    variantId?: true
    productName?: true
    sku?: true
    expectedQuantity?: true
    countedQuantity?: true
    notes?: true
    createdAt?: true
  }

  export type StockTakeItemCountAggregateInputType = {
    id?: true
    stockTakeId?: true
    productId?: true
    variantId?: true
    productName?: true
    sku?: true
    expectedQuantity?: true
    countedQuantity?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type StockTakeItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTakeItem to aggregate.
     */
    where?: StockTakeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTakeItems to fetch.
     */
    orderBy?: StockTakeItemOrderByWithRelationInput | StockTakeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockTakeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTakeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTakeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockTakeItems
    **/
    _count?: true | StockTakeItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockTakeItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockTakeItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockTakeItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockTakeItemMaxAggregateInputType
  }

  export type GetStockTakeItemAggregateType<T extends StockTakeItemAggregateArgs> = {
        [P in keyof T & keyof AggregateStockTakeItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockTakeItem[P]>
      : GetScalarType<T[P], AggregateStockTakeItem[P]>
  }




  export type StockTakeItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTakeItemWhereInput
    orderBy?: StockTakeItemOrderByWithAggregationInput | StockTakeItemOrderByWithAggregationInput[]
    by: StockTakeItemScalarFieldEnum[] | StockTakeItemScalarFieldEnum
    having?: StockTakeItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockTakeItemCountAggregateInputType | true
    _avg?: StockTakeItemAvgAggregateInputType
    _sum?: StockTakeItemSumAggregateInputType
    _min?: StockTakeItemMinAggregateInputType
    _max?: StockTakeItemMaxAggregateInputType
  }

  export type StockTakeItemGroupByOutputType = {
    id: string
    stockTakeId: string
    productId: string
    variantId: string | null
    productName: string
    sku: string
    expectedQuantity: number
    countedQuantity: number
    notes: string | null
    createdAt: Date
    _count: StockTakeItemCountAggregateOutputType | null
    _avg: StockTakeItemAvgAggregateOutputType | null
    _sum: StockTakeItemSumAggregateOutputType | null
    _min: StockTakeItemMinAggregateOutputType | null
    _max: StockTakeItemMaxAggregateOutputType | null
  }

  type GetStockTakeItemGroupByPayload<T extends StockTakeItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockTakeItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockTakeItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockTakeItemGroupByOutputType[P]>
            : GetScalarType<T[P], StockTakeItemGroupByOutputType[P]>
        }
      >
    >


  export type StockTakeItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stockTakeId?: boolean
    productId?: boolean
    variantId?: boolean
    productName?: boolean
    sku?: boolean
    expectedQuantity?: boolean
    countedQuantity?: boolean
    notes?: boolean
    createdAt?: boolean
    stockTake?: boolean | StockTakeDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    variant?: boolean | StockTakeItem$variantArgs<ExtArgs>
  }, ExtArgs["result"]["stockTakeItem"]>


  export type StockTakeItemSelectScalar = {
    id?: boolean
    stockTakeId?: boolean
    productId?: boolean
    variantId?: boolean
    productName?: boolean
    sku?: boolean
    expectedQuantity?: boolean
    countedQuantity?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type StockTakeItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockTake?: boolean | StockTakeDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    variant?: boolean | StockTakeItem$variantArgs<ExtArgs>
  }

  export type $StockTakeItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockTakeItem"
    objects: {
      stockTake: Prisma.$StockTakePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      variant: Prisma.$ProductVariantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stockTakeId: string
      productId: string
      variantId: string | null
      productName: string
      sku: string
      expectedQuantity: number
      countedQuantity: number
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["stockTakeItem"]>
    composites: {}
  }

  type StockTakeItemGetPayload<S extends boolean | null | undefined | StockTakeItemDefaultArgs> = $Result.GetResult<Prisma.$StockTakeItemPayload, S>

  type StockTakeItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockTakeItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockTakeItemCountAggregateInputType | true
    }

  export interface StockTakeItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockTakeItem'], meta: { name: 'StockTakeItem' } }
    /**
     * Find zero or one StockTakeItem that matches the filter.
     * @param {StockTakeItemFindUniqueArgs} args - Arguments to find a StockTakeItem
     * @example
     * // Get one StockTakeItem
     * const stockTakeItem = await prisma.stockTakeItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockTakeItemFindUniqueArgs>(args: SelectSubset<T, StockTakeItemFindUniqueArgs<ExtArgs>>): Prisma__StockTakeItemClient<$Result.GetResult<Prisma.$StockTakeItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StockTakeItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StockTakeItemFindUniqueOrThrowArgs} args - Arguments to find a StockTakeItem
     * @example
     * // Get one StockTakeItem
     * const stockTakeItem = await prisma.stockTakeItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockTakeItemFindUniqueOrThrowArgs>(args: SelectSubset<T, StockTakeItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockTakeItemClient<$Result.GetResult<Prisma.$StockTakeItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StockTakeItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTakeItemFindFirstArgs} args - Arguments to find a StockTakeItem
     * @example
     * // Get one StockTakeItem
     * const stockTakeItem = await prisma.stockTakeItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockTakeItemFindFirstArgs>(args?: SelectSubset<T, StockTakeItemFindFirstArgs<ExtArgs>>): Prisma__StockTakeItemClient<$Result.GetResult<Prisma.$StockTakeItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StockTakeItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTakeItemFindFirstOrThrowArgs} args - Arguments to find a StockTakeItem
     * @example
     * // Get one StockTakeItem
     * const stockTakeItem = await prisma.stockTakeItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockTakeItemFindFirstOrThrowArgs>(args?: SelectSubset<T, StockTakeItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockTakeItemClient<$Result.GetResult<Prisma.$StockTakeItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StockTakeItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTakeItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockTakeItems
     * const stockTakeItems = await prisma.stockTakeItem.findMany()
     * 
     * // Get first 10 StockTakeItems
     * const stockTakeItems = await prisma.stockTakeItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockTakeItemWithIdOnly = await prisma.stockTakeItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockTakeItemFindManyArgs>(args?: SelectSubset<T, StockTakeItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTakeItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StockTakeItem.
     * @param {StockTakeItemCreateArgs} args - Arguments to create a StockTakeItem.
     * @example
     * // Create one StockTakeItem
     * const StockTakeItem = await prisma.stockTakeItem.create({
     *   data: {
     *     // ... data to create a StockTakeItem
     *   }
     * })
     * 
     */
    create<T extends StockTakeItemCreateArgs>(args: SelectSubset<T, StockTakeItemCreateArgs<ExtArgs>>): Prisma__StockTakeItemClient<$Result.GetResult<Prisma.$StockTakeItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StockTakeItems.
     * @param {StockTakeItemCreateManyArgs} args - Arguments to create many StockTakeItems.
     * @example
     * // Create many StockTakeItems
     * const stockTakeItem = await prisma.stockTakeItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockTakeItemCreateManyArgs>(args?: SelectSubset<T, StockTakeItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockTakeItem.
     * @param {StockTakeItemDeleteArgs} args - Arguments to delete one StockTakeItem.
     * @example
     * // Delete one StockTakeItem
     * const StockTakeItem = await prisma.stockTakeItem.delete({
     *   where: {
     *     // ... filter to delete one StockTakeItem
     *   }
     * })
     * 
     */
    delete<T extends StockTakeItemDeleteArgs>(args: SelectSubset<T, StockTakeItemDeleteArgs<ExtArgs>>): Prisma__StockTakeItemClient<$Result.GetResult<Prisma.$StockTakeItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StockTakeItem.
     * @param {StockTakeItemUpdateArgs} args - Arguments to update one StockTakeItem.
     * @example
     * // Update one StockTakeItem
     * const stockTakeItem = await prisma.stockTakeItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockTakeItemUpdateArgs>(args: SelectSubset<T, StockTakeItemUpdateArgs<ExtArgs>>): Prisma__StockTakeItemClient<$Result.GetResult<Prisma.$StockTakeItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StockTakeItems.
     * @param {StockTakeItemDeleteManyArgs} args - Arguments to filter StockTakeItems to delete.
     * @example
     * // Delete a few StockTakeItems
     * const { count } = await prisma.stockTakeItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockTakeItemDeleteManyArgs>(args?: SelectSubset<T, StockTakeItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTakeItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTakeItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockTakeItems
     * const stockTakeItem = await prisma.stockTakeItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockTakeItemUpdateManyArgs>(args: SelectSubset<T, StockTakeItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockTakeItem.
     * @param {StockTakeItemUpsertArgs} args - Arguments to update or create a StockTakeItem.
     * @example
     * // Update or create a StockTakeItem
     * const stockTakeItem = await prisma.stockTakeItem.upsert({
     *   create: {
     *     // ... data to create a StockTakeItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockTakeItem we want to update
     *   }
     * })
     */
    upsert<T extends StockTakeItemUpsertArgs>(args: SelectSubset<T, StockTakeItemUpsertArgs<ExtArgs>>): Prisma__StockTakeItemClient<$Result.GetResult<Prisma.$StockTakeItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StockTakeItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTakeItemCountArgs} args - Arguments to filter StockTakeItems to count.
     * @example
     * // Count the number of StockTakeItems
     * const count = await prisma.stockTakeItem.count({
     *   where: {
     *     // ... the filter for the StockTakeItems we want to count
     *   }
     * })
    **/
    count<T extends StockTakeItemCountArgs>(
      args?: Subset<T, StockTakeItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockTakeItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockTakeItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTakeItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockTakeItemAggregateArgs>(args: Subset<T, StockTakeItemAggregateArgs>): Prisma.PrismaPromise<GetStockTakeItemAggregateType<T>>

    /**
     * Group by StockTakeItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTakeItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockTakeItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockTakeItemGroupByArgs['orderBy'] }
        : { orderBy?: StockTakeItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockTakeItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockTakeItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockTakeItem model
   */
  readonly fields: StockTakeItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockTakeItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockTakeItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stockTake<T extends StockTakeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockTakeDefaultArgs<ExtArgs>>): Prisma__StockTakeClient<$Result.GetResult<Prisma.$StockTakePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    variant<T extends StockTakeItem$variantArgs<ExtArgs> = {}>(args?: Subset<T, StockTakeItem$variantArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockTakeItem model
   */ 
  interface StockTakeItemFieldRefs {
    readonly id: FieldRef<"StockTakeItem", 'String'>
    readonly stockTakeId: FieldRef<"StockTakeItem", 'String'>
    readonly productId: FieldRef<"StockTakeItem", 'String'>
    readonly variantId: FieldRef<"StockTakeItem", 'String'>
    readonly productName: FieldRef<"StockTakeItem", 'String'>
    readonly sku: FieldRef<"StockTakeItem", 'String'>
    readonly expectedQuantity: FieldRef<"StockTakeItem", 'Int'>
    readonly countedQuantity: FieldRef<"StockTakeItem", 'Int'>
    readonly notes: FieldRef<"StockTakeItem", 'String'>
    readonly createdAt: FieldRef<"StockTakeItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockTakeItem findUnique
   */
  export type StockTakeItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTakeItem
     */
    select?: StockTakeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeItemInclude<ExtArgs> | null
    /**
     * Filter, which StockTakeItem to fetch.
     */
    where: StockTakeItemWhereUniqueInput
  }

  /**
   * StockTakeItem findUniqueOrThrow
   */
  export type StockTakeItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTakeItem
     */
    select?: StockTakeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeItemInclude<ExtArgs> | null
    /**
     * Filter, which StockTakeItem to fetch.
     */
    where: StockTakeItemWhereUniqueInput
  }

  /**
   * StockTakeItem findFirst
   */
  export type StockTakeItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTakeItem
     */
    select?: StockTakeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeItemInclude<ExtArgs> | null
    /**
     * Filter, which StockTakeItem to fetch.
     */
    where?: StockTakeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTakeItems to fetch.
     */
    orderBy?: StockTakeItemOrderByWithRelationInput | StockTakeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTakeItems.
     */
    cursor?: StockTakeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTakeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTakeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTakeItems.
     */
    distinct?: StockTakeItemScalarFieldEnum | StockTakeItemScalarFieldEnum[]
  }

  /**
   * StockTakeItem findFirstOrThrow
   */
  export type StockTakeItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTakeItem
     */
    select?: StockTakeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeItemInclude<ExtArgs> | null
    /**
     * Filter, which StockTakeItem to fetch.
     */
    where?: StockTakeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTakeItems to fetch.
     */
    orderBy?: StockTakeItemOrderByWithRelationInput | StockTakeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTakeItems.
     */
    cursor?: StockTakeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTakeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTakeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTakeItems.
     */
    distinct?: StockTakeItemScalarFieldEnum | StockTakeItemScalarFieldEnum[]
  }

  /**
   * StockTakeItem findMany
   */
  export type StockTakeItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTakeItem
     */
    select?: StockTakeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeItemInclude<ExtArgs> | null
    /**
     * Filter, which StockTakeItems to fetch.
     */
    where?: StockTakeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTakeItems to fetch.
     */
    orderBy?: StockTakeItemOrderByWithRelationInput | StockTakeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockTakeItems.
     */
    cursor?: StockTakeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTakeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTakeItems.
     */
    skip?: number
    distinct?: StockTakeItemScalarFieldEnum | StockTakeItemScalarFieldEnum[]
  }

  /**
   * StockTakeItem create
   */
  export type StockTakeItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTakeItem
     */
    select?: StockTakeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeItemInclude<ExtArgs> | null
    /**
     * The data needed to create a StockTakeItem.
     */
    data: XOR<StockTakeItemCreateInput, StockTakeItemUncheckedCreateInput>
  }

  /**
   * StockTakeItem createMany
   */
  export type StockTakeItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockTakeItems.
     */
    data: StockTakeItemCreateManyInput | StockTakeItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockTakeItem update
   */
  export type StockTakeItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTakeItem
     */
    select?: StockTakeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeItemInclude<ExtArgs> | null
    /**
     * The data needed to update a StockTakeItem.
     */
    data: XOR<StockTakeItemUpdateInput, StockTakeItemUncheckedUpdateInput>
    /**
     * Choose, which StockTakeItem to update.
     */
    where: StockTakeItemWhereUniqueInput
  }

  /**
   * StockTakeItem updateMany
   */
  export type StockTakeItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockTakeItems.
     */
    data: XOR<StockTakeItemUpdateManyMutationInput, StockTakeItemUncheckedUpdateManyInput>
    /**
     * Filter which StockTakeItems to update
     */
    where?: StockTakeItemWhereInput
  }

  /**
   * StockTakeItem upsert
   */
  export type StockTakeItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTakeItem
     */
    select?: StockTakeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeItemInclude<ExtArgs> | null
    /**
     * The filter to search for the StockTakeItem to update in case it exists.
     */
    where: StockTakeItemWhereUniqueInput
    /**
     * In case the StockTakeItem found by the `where` argument doesn't exist, create a new StockTakeItem with this data.
     */
    create: XOR<StockTakeItemCreateInput, StockTakeItemUncheckedCreateInput>
    /**
     * In case the StockTakeItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockTakeItemUpdateInput, StockTakeItemUncheckedUpdateInput>
  }

  /**
   * StockTakeItem delete
   */
  export type StockTakeItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTakeItem
     */
    select?: StockTakeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeItemInclude<ExtArgs> | null
    /**
     * Filter which StockTakeItem to delete.
     */
    where: StockTakeItemWhereUniqueInput
  }

  /**
   * StockTakeItem deleteMany
   */
  export type StockTakeItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTakeItems to delete
     */
    where?: StockTakeItemWhereInput
  }

  /**
   * StockTakeItem.variant
   */
  export type StockTakeItem$variantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    where?: ProductVariantWhereInput
  }

  /**
   * StockTakeItem without action
   */
  export type StockTakeItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTakeItem
     */
    select?: StockTakeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTakeItemInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    link: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    link: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    vendorId: number
    type: number
    title: number
    message: number
    isRead: number
    link: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    vendorId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    link?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    vendorId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    link?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    vendorId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    link?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    vendorId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead: boolean
    link: string | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    link?: boolean
    createdAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>


  export type NotificationSelectScalar = {
    id?: boolean
    vendorId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    link?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      type: $Enums.NotificationType
      title: string
      message: string
      isRead: boolean
      link: string | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly vendorId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    vendorId: number
    userId: number
    action: number
    resource: number
    resourceId: number
    oldValues: number
    newValues: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    vendorId?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    vendorId?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    vendorId?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    oldValues?: true
    newValues?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    vendorId: string
    userId: string
    action: string
    resource: string
    resourceId: string
    oldValues: JsonValue | null
    newValues: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>


  export type AuditLogSelectScalar = {
    id?: boolean
    vendorId?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      userId: string
      action: string
      resource: string
      resourceId: string
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly vendorId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly oldValues: FieldRef<"AuditLog", 'Json'>
    readonly newValues: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model SupportTicket
   */

  export type AggregateSupportTicket = {
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  export type SupportTicketMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    vendorName: string | null
    subject: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    priority: $Enums.TicketPriority | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportTicketMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    vendorName: string | null
    subject: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    priority: $Enums.TicketPriority | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportTicketCountAggregateOutputType = {
    id: number
    vendorId: number
    vendorName: number
    subject: number
    description: number
    status: number
    priority: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupportTicketMinAggregateInputType = {
    id?: true
    vendorId?: true
    vendorName?: true
    subject?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportTicketMaxAggregateInputType = {
    id?: true
    vendorId?: true
    vendorName?: true
    subject?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportTicketCountAggregateInputType = {
    id?: true
    vendorId?: true
    vendorName?: true
    subject?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupportTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTicket to aggregate.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportTickets
    **/
    _count?: true | SupportTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportTicketMaxAggregateInputType
  }

  export type GetSupportTicketAggregateType<T extends SupportTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportTicket[P]>
      : GetScalarType<T[P], AggregateSupportTicket[P]>
  }




  export type SupportTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithAggregationInput | SupportTicketOrderByWithAggregationInput[]
    by: SupportTicketScalarFieldEnum[] | SupportTicketScalarFieldEnum
    having?: SupportTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportTicketCountAggregateInputType | true
    _min?: SupportTicketMinAggregateInputType
    _max?: SupportTicketMaxAggregateInputType
  }

  export type SupportTicketGroupByOutputType = {
    id: string
    vendorId: string
    vendorName: string
    subject: string
    description: string
    status: $Enums.TicketStatus
    priority: $Enums.TicketPriority
    createdAt: Date
    updatedAt: Date
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  type GetSupportTicketGroupByPayload<T extends SupportTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
            : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
        }
      >
    >


  export type SupportTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    vendorName?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>


  export type SupportTicketSelectScalar = {
    id?: boolean
    vendorId?: boolean
    vendorName?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupportTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $SupportTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportTicket"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      vendorName: string
      subject: string
      description: string
      status: $Enums.TicketStatus
      priority: $Enums.TicketPriority
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supportTicket"]>
    composites: {}
  }

  type SupportTicketGetPayload<S extends boolean | null | undefined | SupportTicketDefaultArgs> = $Result.GetResult<Prisma.$SupportTicketPayload, S>

  type SupportTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupportTicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupportTicketCountAggregateInputType | true
    }

  export interface SupportTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportTicket'], meta: { name: 'SupportTicket' } }
    /**
     * Find zero or one SupportTicket that matches the filter.
     * @param {SupportTicketFindUniqueArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportTicketFindUniqueArgs>(args: SelectSubset<T, SupportTicketFindUniqueArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SupportTicket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupportTicketFindUniqueOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SupportTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportTicketFindFirstArgs>(args?: SelectSubset<T, SupportTicketFindFirstArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SupportTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SupportTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany()
     * 
     * // Get first 10 SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportTicketFindManyArgs>(args?: SelectSubset<T, SupportTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SupportTicket.
     * @param {SupportTicketCreateArgs} args - Arguments to create a SupportTicket.
     * @example
     * // Create one SupportTicket
     * const SupportTicket = await prisma.supportTicket.create({
     *   data: {
     *     // ... data to create a SupportTicket
     *   }
     * })
     * 
     */
    create<T extends SupportTicketCreateArgs>(args: SelectSubset<T, SupportTicketCreateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SupportTickets.
     * @param {SupportTicketCreateManyArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportTicketCreateManyArgs>(args?: SelectSubset<T, SupportTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SupportTicket.
     * @param {SupportTicketDeleteArgs} args - Arguments to delete one SupportTicket.
     * @example
     * // Delete one SupportTicket
     * const SupportTicket = await prisma.supportTicket.delete({
     *   where: {
     *     // ... filter to delete one SupportTicket
     *   }
     * })
     * 
     */
    delete<T extends SupportTicketDeleteArgs>(args: SelectSubset<T, SupportTicketDeleteArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SupportTicket.
     * @param {SupportTicketUpdateArgs} args - Arguments to update one SupportTicket.
     * @example
     * // Update one SupportTicket
     * const supportTicket = await prisma.supportTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportTicketUpdateArgs>(args: SelectSubset<T, SupportTicketUpdateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SupportTickets.
     * @param {SupportTicketDeleteManyArgs} args - Arguments to filter SupportTickets to delete.
     * @example
     * // Delete a few SupportTickets
     * const { count } = await prisma.supportTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportTicketDeleteManyArgs>(args?: SelectSubset<T, SupportTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportTicketUpdateManyArgs>(args: SelectSubset<T, SupportTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SupportTicket.
     * @param {SupportTicketUpsertArgs} args - Arguments to update or create a SupportTicket.
     * @example
     * // Update or create a SupportTicket
     * const supportTicket = await prisma.supportTicket.upsert({
     *   create: {
     *     // ... data to create a SupportTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportTicket we want to update
     *   }
     * })
     */
    upsert<T extends SupportTicketUpsertArgs>(args: SelectSubset<T, SupportTicketUpsertArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketCountArgs} args - Arguments to filter SupportTickets to count.
     * @example
     * // Count the number of SupportTickets
     * const count = await prisma.supportTicket.count({
     *   where: {
     *     // ... the filter for the SupportTickets we want to count
     *   }
     * })
    **/
    count<T extends SupportTicketCountArgs>(
      args?: Subset<T, SupportTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportTicketAggregateArgs>(args: Subset<T, SupportTicketAggregateArgs>): Prisma.PrismaPromise<GetSupportTicketAggregateType<T>>

    /**
     * Group by SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportTicketGroupByArgs['orderBy'] }
        : { orderBy?: SupportTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportTicket model
   */
  readonly fields: SupportTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportTicket model
   */ 
  interface SupportTicketFieldRefs {
    readonly id: FieldRef<"SupportTicket", 'String'>
    readonly vendorId: FieldRef<"SupportTicket", 'String'>
    readonly vendorName: FieldRef<"SupportTicket", 'String'>
    readonly subject: FieldRef<"SupportTicket", 'String'>
    readonly description: FieldRef<"SupportTicket", 'String'>
    readonly status: FieldRef<"SupportTicket", 'TicketStatus'>
    readonly priority: FieldRef<"SupportTicket", 'TicketPriority'>
    readonly createdAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly updatedAt: FieldRef<"SupportTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportTicket findUnique
   */
  export type SupportTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findUniqueOrThrow
   */
  export type SupportTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findFirst
   */
  export type SupportTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findFirstOrThrow
   */
  export type SupportTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findMany
   */
  export type SupportTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTickets to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket create
   */
  export type SupportTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportTicket.
     */
    data: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
  }

  /**
   * SupportTicket createMany
   */
  export type SupportTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportTicket update
   */
  export type SupportTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportTicket.
     */
    data: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
    /**
     * Choose, which SupportTicket to update.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket updateMany
   */
  export type SupportTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
  }

  /**
   * SupportTicket upsert
   */
  export type SupportTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportTicket to update in case it exists.
     */
    where: SupportTicketWhereUniqueInput
    /**
     * In case the SupportTicket found by the `where` argument doesn't exist, create a new SupportTicket with this data.
     */
    create: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
    /**
     * In case the SupportTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
  }

  /**
   * SupportTicket delete
   */
  export type SupportTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter which SupportTicket to delete.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket deleteMany
   */
  export type SupportTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTickets to delete
     */
    where?: SupportTicketWhereInput
  }

  /**
   * SupportTicket without action
   */
  export type SupportTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    type: $Enums.ReportType | null
    period: $Enums.ReportPeriod | null
    startDate: Date | null
    endDate: Date | null
    generatedBy: string | null
    generatedAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    type: $Enums.ReportType | null
    period: $Enums.ReportPeriod | null
    startDate: Date | null
    endDate: Date | null
    generatedBy: string | null
    generatedAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    vendorId: number
    type: number
    period: number
    startDate: number
    endDate: number
    data: number
    generatedBy: number
    generatedAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    vendorId?: true
    type?: true
    period?: true
    startDate?: true
    endDate?: true
    generatedBy?: true
    generatedAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    vendorId?: true
    type?: true
    period?: true
    startDate?: true
    endDate?: true
    generatedBy?: true
    generatedAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    vendorId?: true
    type?: true
    period?: true
    startDate?: true
    endDate?: true
    data?: true
    generatedBy?: true
    generatedAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    vendorId: string
    type: $Enums.ReportType
    period: $Enums.ReportPeriod
    startDate: Date
    endDate: Date
    data: JsonValue
    generatedBy: string
    generatedAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    type?: boolean
    period?: boolean
    startDate?: boolean
    endDate?: boolean
    data?: boolean
    generatedBy?: boolean
    generatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    generator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>


  export type ReportSelectScalar = {
    id?: boolean
    vendorId?: boolean
    type?: boolean
    period?: boolean
    startDate?: boolean
    endDate?: boolean
    data?: boolean
    generatedBy?: boolean
    generatedAt?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    generator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      generator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      type: $Enums.ReportType
      period: $Enums.ReportPeriod
      startDate: Date
      endDate: Date
      data: Prisma.JsonValue
      generatedBy: string
      generatedAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    generator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly vendorId: FieldRef<"Report", 'String'>
    readonly type: FieldRef<"Report", 'ReportType'>
    readonly period: FieldRef<"Report", 'ReportPeriod'>
    readonly startDate: FieldRef<"Report", 'DateTime'>
    readonly endDate: FieldRef<"Report", 'DateTime'>
    readonly data: FieldRef<"Report", 'Json'>
    readonly generatedBy: FieldRef<"Report", 'String'>
    readonly generatedAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model PricingPlan
   */

  export type AggregatePricingPlan = {
    _count: PricingPlanCountAggregateOutputType | null
    _avg: PricingPlanAvgAggregateOutputType | null
    _sum: PricingPlanSumAggregateOutputType | null
    _min: PricingPlanMinAggregateOutputType | null
    _max: PricingPlanMaxAggregateOutputType | null
  }

  export type PricingPlanAvgAggregateOutputType = {
    price: Decimal | null
    duration: number | null
  }

  export type PricingPlanSumAggregateOutputType = {
    price: Decimal | null
    duration: number | null
  }

  export type PricingPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: Decimal | null
    duration: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricingPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: Decimal | null
    duration: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricingPlanCountAggregateOutputType = {
    id: number
    name: number
    price: number
    duration: number
    features: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PricingPlanAvgAggregateInputType = {
    price?: true
    duration?: true
  }

  export type PricingPlanSumAggregateInputType = {
    price?: true
    duration?: true
  }

  export type PricingPlanMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricingPlanMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricingPlanCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    features?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PricingPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PricingPlan to aggregate.
     */
    where?: PricingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingPlans to fetch.
     */
    orderBy?: PricingPlanOrderByWithRelationInput | PricingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PricingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PricingPlans
    **/
    _count?: true | PricingPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricingPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricingPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricingPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricingPlanMaxAggregateInputType
  }

  export type GetPricingPlanAggregateType<T extends PricingPlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePricingPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricingPlan[P]>
      : GetScalarType<T[P], AggregatePricingPlan[P]>
  }




  export type PricingPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PricingPlanWhereInput
    orderBy?: PricingPlanOrderByWithAggregationInput | PricingPlanOrderByWithAggregationInput[]
    by: PricingPlanScalarFieldEnum[] | PricingPlanScalarFieldEnum
    having?: PricingPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricingPlanCountAggregateInputType | true
    _avg?: PricingPlanAvgAggregateInputType
    _sum?: PricingPlanSumAggregateInputType
    _min?: PricingPlanMinAggregateInputType
    _max?: PricingPlanMaxAggregateInputType
  }

  export type PricingPlanGroupByOutputType = {
    id: string
    name: string
    price: Decimal
    duration: number
    features: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PricingPlanCountAggregateOutputType | null
    _avg: PricingPlanAvgAggregateOutputType | null
    _sum: PricingPlanSumAggregateOutputType | null
    _min: PricingPlanMinAggregateOutputType | null
    _max: PricingPlanMaxAggregateOutputType | null
  }

  type GetPricingPlanGroupByPayload<T extends PricingPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PricingPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricingPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricingPlanGroupByOutputType[P]>
            : GetScalarType<T[P], PricingPlanGroupByOutputType[P]>
        }
      >
    >


  export type PricingPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pricingPlan"]>


  export type PricingPlanSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PricingPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PricingPlan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: Prisma.Decimal
      duration: number
      features: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pricingPlan"]>
    composites: {}
  }

  type PricingPlanGetPayload<S extends boolean | null | undefined | PricingPlanDefaultArgs> = $Result.GetResult<Prisma.$PricingPlanPayload, S>

  type PricingPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PricingPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PricingPlanCountAggregateInputType | true
    }

  export interface PricingPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PricingPlan'], meta: { name: 'PricingPlan' } }
    /**
     * Find zero or one PricingPlan that matches the filter.
     * @param {PricingPlanFindUniqueArgs} args - Arguments to find a PricingPlan
     * @example
     * // Get one PricingPlan
     * const pricingPlan = await prisma.pricingPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PricingPlanFindUniqueArgs>(args: SelectSubset<T, PricingPlanFindUniqueArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PricingPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PricingPlanFindUniqueOrThrowArgs} args - Arguments to find a PricingPlan
     * @example
     * // Get one PricingPlan
     * const pricingPlan = await prisma.pricingPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PricingPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PricingPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PricingPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanFindFirstArgs} args - Arguments to find a PricingPlan
     * @example
     * // Get one PricingPlan
     * const pricingPlan = await prisma.pricingPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PricingPlanFindFirstArgs>(args?: SelectSubset<T, PricingPlanFindFirstArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PricingPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanFindFirstOrThrowArgs} args - Arguments to find a PricingPlan
     * @example
     * // Get one PricingPlan
     * const pricingPlan = await prisma.pricingPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PricingPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PricingPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PricingPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PricingPlans
     * const pricingPlans = await prisma.pricingPlan.findMany()
     * 
     * // Get first 10 PricingPlans
     * const pricingPlans = await prisma.pricingPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pricingPlanWithIdOnly = await prisma.pricingPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PricingPlanFindManyArgs>(args?: SelectSubset<T, PricingPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PricingPlan.
     * @param {PricingPlanCreateArgs} args - Arguments to create a PricingPlan.
     * @example
     * // Create one PricingPlan
     * const PricingPlan = await prisma.pricingPlan.create({
     *   data: {
     *     // ... data to create a PricingPlan
     *   }
     * })
     * 
     */
    create<T extends PricingPlanCreateArgs>(args: SelectSubset<T, PricingPlanCreateArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PricingPlans.
     * @param {PricingPlanCreateManyArgs} args - Arguments to create many PricingPlans.
     * @example
     * // Create many PricingPlans
     * const pricingPlan = await prisma.pricingPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PricingPlanCreateManyArgs>(args?: SelectSubset<T, PricingPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PricingPlan.
     * @param {PricingPlanDeleteArgs} args - Arguments to delete one PricingPlan.
     * @example
     * // Delete one PricingPlan
     * const PricingPlan = await prisma.pricingPlan.delete({
     *   where: {
     *     // ... filter to delete one PricingPlan
     *   }
     * })
     * 
     */
    delete<T extends PricingPlanDeleteArgs>(args: SelectSubset<T, PricingPlanDeleteArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PricingPlan.
     * @param {PricingPlanUpdateArgs} args - Arguments to update one PricingPlan.
     * @example
     * // Update one PricingPlan
     * const pricingPlan = await prisma.pricingPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PricingPlanUpdateArgs>(args: SelectSubset<T, PricingPlanUpdateArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PricingPlans.
     * @param {PricingPlanDeleteManyArgs} args - Arguments to filter PricingPlans to delete.
     * @example
     * // Delete a few PricingPlans
     * const { count } = await prisma.pricingPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PricingPlanDeleteManyArgs>(args?: SelectSubset<T, PricingPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PricingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PricingPlans
     * const pricingPlan = await prisma.pricingPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PricingPlanUpdateManyArgs>(args: SelectSubset<T, PricingPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PricingPlan.
     * @param {PricingPlanUpsertArgs} args - Arguments to update or create a PricingPlan.
     * @example
     * // Update or create a PricingPlan
     * const pricingPlan = await prisma.pricingPlan.upsert({
     *   create: {
     *     // ... data to create a PricingPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PricingPlan we want to update
     *   }
     * })
     */
    upsert<T extends PricingPlanUpsertArgs>(args: SelectSubset<T, PricingPlanUpsertArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PricingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanCountArgs} args - Arguments to filter PricingPlans to count.
     * @example
     * // Count the number of PricingPlans
     * const count = await prisma.pricingPlan.count({
     *   where: {
     *     // ... the filter for the PricingPlans we want to count
     *   }
     * })
    **/
    count<T extends PricingPlanCountArgs>(
      args?: Subset<T, PricingPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricingPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PricingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricingPlanAggregateArgs>(args: Subset<T, PricingPlanAggregateArgs>): Prisma.PrismaPromise<GetPricingPlanAggregateType<T>>

    /**
     * Group by PricingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PricingPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PricingPlanGroupByArgs['orderBy'] }
        : { orderBy?: PricingPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PricingPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricingPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PricingPlan model
   */
  readonly fields: PricingPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PricingPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PricingPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PricingPlan model
   */ 
  interface PricingPlanFieldRefs {
    readonly id: FieldRef<"PricingPlan", 'String'>
    readonly name: FieldRef<"PricingPlan", 'String'>
    readonly price: FieldRef<"PricingPlan", 'Decimal'>
    readonly duration: FieldRef<"PricingPlan", 'Int'>
    readonly features: FieldRef<"PricingPlan", 'Json'>
    readonly isActive: FieldRef<"PricingPlan", 'Boolean'>
    readonly createdAt: FieldRef<"PricingPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"PricingPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PricingPlan findUnique
   */
  export type PricingPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Filter, which PricingPlan to fetch.
     */
    where: PricingPlanWhereUniqueInput
  }

  /**
   * PricingPlan findUniqueOrThrow
   */
  export type PricingPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Filter, which PricingPlan to fetch.
     */
    where: PricingPlanWhereUniqueInput
  }

  /**
   * PricingPlan findFirst
   */
  export type PricingPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Filter, which PricingPlan to fetch.
     */
    where?: PricingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingPlans to fetch.
     */
    orderBy?: PricingPlanOrderByWithRelationInput | PricingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PricingPlans.
     */
    cursor?: PricingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PricingPlans.
     */
    distinct?: PricingPlanScalarFieldEnum | PricingPlanScalarFieldEnum[]
  }

  /**
   * PricingPlan findFirstOrThrow
   */
  export type PricingPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Filter, which PricingPlan to fetch.
     */
    where?: PricingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingPlans to fetch.
     */
    orderBy?: PricingPlanOrderByWithRelationInput | PricingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PricingPlans.
     */
    cursor?: PricingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PricingPlans.
     */
    distinct?: PricingPlanScalarFieldEnum | PricingPlanScalarFieldEnum[]
  }

  /**
   * PricingPlan findMany
   */
  export type PricingPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Filter, which PricingPlans to fetch.
     */
    where?: PricingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingPlans to fetch.
     */
    orderBy?: PricingPlanOrderByWithRelationInput | PricingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PricingPlans.
     */
    cursor?: PricingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingPlans.
     */
    skip?: number
    distinct?: PricingPlanScalarFieldEnum | PricingPlanScalarFieldEnum[]
  }

  /**
   * PricingPlan create
   */
  export type PricingPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * The data needed to create a PricingPlan.
     */
    data: XOR<PricingPlanCreateInput, PricingPlanUncheckedCreateInput>
  }

  /**
   * PricingPlan createMany
   */
  export type PricingPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PricingPlans.
     */
    data: PricingPlanCreateManyInput | PricingPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PricingPlan update
   */
  export type PricingPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * The data needed to update a PricingPlan.
     */
    data: XOR<PricingPlanUpdateInput, PricingPlanUncheckedUpdateInput>
    /**
     * Choose, which PricingPlan to update.
     */
    where: PricingPlanWhereUniqueInput
  }

  /**
   * PricingPlan updateMany
   */
  export type PricingPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PricingPlans.
     */
    data: XOR<PricingPlanUpdateManyMutationInput, PricingPlanUncheckedUpdateManyInput>
    /**
     * Filter which PricingPlans to update
     */
    where?: PricingPlanWhereInput
  }

  /**
   * PricingPlan upsert
   */
  export type PricingPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * The filter to search for the PricingPlan to update in case it exists.
     */
    where: PricingPlanWhereUniqueInput
    /**
     * In case the PricingPlan found by the `where` argument doesn't exist, create a new PricingPlan with this data.
     */
    create: XOR<PricingPlanCreateInput, PricingPlanUncheckedCreateInput>
    /**
     * In case the PricingPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PricingPlanUpdateInput, PricingPlanUncheckedUpdateInput>
  }

  /**
   * PricingPlan delete
   */
  export type PricingPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Filter which PricingPlan to delete.
     */
    where: PricingPlanWhereUniqueInput
  }

  /**
   * PricingPlan deleteMany
   */
  export type PricingPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PricingPlans to delete
     */
    where?: PricingPlanWhereInput
  }

  /**
   * PricingPlan without action
   */
  export type PricingPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
  }


  /**
   * Model SystemSettings
   */

  export type AggregateSystemSettings = {
    _count: SystemSettingsCountAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  export type SystemSettingsMinAggregateOutputType = {
    id: string | null
    settingKey: string | null
    settingValue: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingsMaxAggregateOutputType = {
    id: string | null
    settingKey: string | null
    settingValue: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingsCountAggregateOutputType = {
    id: number
    settingKey: number
    settingValue: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingsMinAggregateInputType = {
    id?: true
    settingKey?: true
    settingValue?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingsMaxAggregateInputType = {
    id?: true
    settingKey?: true
    settingValue?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingsCountAggregateInputType = {
    id?: true
    settingKey?: true
    settingValue?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to aggregate.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type GetSystemSettingsAggregateType<T extends SystemSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSettings[P]>
      : GetScalarType<T[P], AggregateSystemSettings[P]>
  }




  export type SystemSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingsWhereInput
    orderBy?: SystemSettingsOrderByWithAggregationInput | SystemSettingsOrderByWithAggregationInput[]
    by: SystemSettingsScalarFieldEnum[] | SystemSettingsScalarFieldEnum
    having?: SystemSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingsCountAggregateInputType | true
    _min?: SystemSettingsMinAggregateInputType
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type SystemSettingsGroupByOutputType = {
    id: string
    settingKey: string
    settingValue: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: SystemSettingsCountAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  type GetSystemSettingsGroupByPayload<T extends SystemSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    settingKey?: boolean
    settingValue?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSettings"]>


  export type SystemSettingsSelectScalar = {
    id?: boolean
    settingKey?: boolean
    settingValue?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SystemSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      settingKey: string
      settingValue: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemSettings"]>
    composites: {}
  }

  type SystemSettingsGetPayload<S extends boolean | null | undefined | SystemSettingsDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingsPayload, S>

  type SystemSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemSettingsCountAggregateInputType | true
    }

  export interface SystemSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSettings'], meta: { name: 'SystemSettings' } }
    /**
     * Find zero or one SystemSettings that matches the filter.
     * @param {SystemSettingsFindUniqueArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingsFindUniqueArgs>(args: SelectSubset<T, SystemSettingsFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemSettingsFindUniqueOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingsFindFirstArgs>(args?: SelectSubset<T, SystemSettingsFindFirstArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingsFindManyArgs>(args?: SelectSubset<T, SystemSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemSettings.
     * @param {SystemSettingsCreateArgs} args - Arguments to create a SystemSettings.
     * @example
     * // Create one SystemSettings
     * const SystemSettings = await prisma.systemSettings.create({
     *   data: {
     *     // ... data to create a SystemSettings
     *   }
     * })
     * 
     */
    create<T extends SystemSettingsCreateArgs>(args: SelectSubset<T, SystemSettingsCreateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingsCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingsCreateManyArgs>(args?: SelectSubset<T, SystemSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemSettings.
     * @param {SystemSettingsDeleteArgs} args - Arguments to delete one SystemSettings.
     * @example
     * // Delete one SystemSettings
     * const SystemSettings = await prisma.systemSettings.delete({
     *   where: {
     *     // ... filter to delete one SystemSettings
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingsDeleteArgs>(args: SelectSubset<T, SystemSettingsDeleteArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemSettings.
     * @param {SystemSettingsUpdateArgs} args - Arguments to update one SystemSettings.
     * @example
     * // Update one SystemSettings
     * const systemSettings = await prisma.systemSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingsUpdateArgs>(args: SelectSubset<T, SystemSettingsUpdateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingsDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingsDeleteManyArgs>(args?: SelectSubset<T, SystemSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingsUpdateManyArgs>(args: SelectSubset<T, SystemSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemSettings.
     * @param {SystemSettingsUpsertArgs} args - Arguments to update or create a SystemSettings.
     * @example
     * // Update or create a SystemSettings
     * const systemSettings = await prisma.systemSettings.upsert({
     *   create: {
     *     // ... data to create a SystemSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSettings we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingsUpsertArgs>(args: SelectSubset<T, SystemSettingsUpsertArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSettings.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingsCountArgs>(
      args?: Subset<T, SystemSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingsAggregateArgs>(args: Subset<T, SystemSettingsAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingsAggregateType<T>>

    /**
     * Group by SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSettings model
   */
  readonly fields: SystemSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSettings model
   */ 
  interface SystemSettingsFieldRefs {
    readonly id: FieldRef<"SystemSettings", 'String'>
    readonly settingKey: FieldRef<"SystemSettings", 'String'>
    readonly settingValue: FieldRef<"SystemSettings", 'String'>
    readonly description: FieldRef<"SystemSettings", 'String'>
    readonly createdAt: FieldRef<"SystemSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSettings findUnique
   */
  export type SystemSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findUniqueOrThrow
   */
  export type SystemSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findFirst
   */
  export type SystemSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findFirstOrThrow
   */
  export type SystemSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findMany
   */
  export type SystemSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings create
   */
  export type SystemSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemSettings.
     */
    data: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
  }

  /**
   * SystemSettings createMany
   */
  export type SystemSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings update
   */
  export type SystemSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemSettings.
     */
    data: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
    /**
     * Choose, which SystemSettings to update.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings updateMany
   */
  export type SystemSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
  }

  /**
   * SystemSettings upsert
   */
  export type SystemSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemSettings to update in case it exists.
     */
    where: SystemSettingsWhereUniqueInput
    /**
     * In case the SystemSettings found by the `where` argument doesn't exist, create a new SystemSettings with this data.
     */
    create: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
    /**
     * In case the SystemSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
  }

  /**
   * SystemSettings delete
   */
  export type SystemSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter which SystemSettings to delete.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings deleteMany
   */
  export type SystemSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingsWhereInput
  }

  /**
   * SystemSettings without action
   */
  export type SystemSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const VendorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    businessType: 'businessType',
    subscriptionPlan: 'subscriptionPlan',
    subscriptionStatus: 'subscriptionStatus',
    subscriptionExpiry: 'subscriptionExpiry',
    isApproved: 'isApproved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const VendorSettingsScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    taxRate: 'taxRate',
    currency: 'currency',
    timezone: 'timezone',
    receiptHeader: 'receiptHeader',
    receiptFooter: 'receiptFooter',
    loyaltyEnabled: 'loyaltyEnabled',
    loyaltyPointsPerDollar: 'loyaltyPointsPerDollar',
    loyaltyRedemptionRate: 'loyaltyRedemptionRate',
    loyaltyMinimumPoints: 'loyaltyMinimumPoints',
    lowStockAlert: 'lowStockAlert',
    lowStockThreshold: 'lowStockThreshold',
    emailNotifications: 'emailNotifications',
    smsNotifications: 'smsNotifications',
    dailyReports: 'dailyReports',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorSettingsScalarFieldEnum = (typeof VendorSettingsScalarFieldEnum)[keyof typeof VendorSettingsScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    vendorId: 'vendorId',
    name: 'name',
    avatar: 'avatar',
    isActive: 'isActive',
    terminalId: 'terminalId',
    assignedLocations: 'assignedLocations',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CashierScheduleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    checkInTime: 'checkInTime',
    checkOutTime: 'checkOutTime',
    workDays: 'workDays',
    timezone: 'timezone',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CashierScheduleScalarFieldEnum = (typeof CashierScheduleScalarFieldEnum)[keyof typeof CashierScheduleScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    name: 'name',
    description: 'description',
    sku: 'sku',
    barcode: 'barcode',
    category: 'category',
    brand: 'brand',
    price: 'price',
    costPrice: 'costPrice',
    totalStock: 'totalStock',
    minStock: 'minStock',
    maxStock: 'maxStock',
    unit: 'unit',
    images: 'images',
    isActive: 'isActive',
    expiryDate: 'expiryDate',
    trackExpiry: 'trackExpiry',
    trackSerial: 'trackSerial',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductVariantScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    name: 'name',
    value: 'value',
    priceModifier: 'priceModifier',
    stock: 'stock',
    sku: 'sku',
    barcode: 'barcode',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductVariantScalarFieldEnum = (typeof ProductVariantScalarFieldEnum)[keyof typeof ProductVariantScalarFieldEnum]


  export const ProductStockLocationScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    variantId: 'variantId',
    locationName: 'locationName',
    quantity: 'quantity',
    reservedQuantity: 'reservedQuantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductStockLocationScalarFieldEnum = (typeof ProductStockLocationScalarFieldEnum)[keyof typeof ProductStockLocationScalarFieldEnum]


  export const CashierProductAssignmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    assignedAt: 'assignedAt'
  };

  export type CashierProductAssignmentScalarFieldEnum = (typeof CashierProductAssignmentScalarFieldEnum)[keyof typeof CashierProductAssignmentScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    dateOfBirth: 'dateOfBirth',
    loyaltyPoints: 'loyaltyPoints',
    totalSpent: 'totalSpent',
    visitCount: 'visitCount',
    lastVisit: 'lastVisit',
    isActive: 'isActive',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const SaleScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    cashierId: 'cashierId',
    terminalId: 'terminalId',
    customerId: 'customerId',
    receiptNumber: 'receiptNumber',
    subtotal: 'subtotal',
    tax: 'tax',
    discount: 'discount',
    total: 'total',
    paid: 'paid',
    changeAmount: 'changeAmount',
    paymentMethod: 'paymentMethod',
    status: 'status',
    refundAmount: 'refundAmount',
    loyaltyPointsEarned: 'loyaltyPointsEarned',
    loyaltyPointsUsed: 'loyaltyPointsUsed',
    notes: 'notes',
    receiptData: 'receiptData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SaleScalarFieldEnum = (typeof SaleScalarFieldEnum)[keyof typeof SaleScalarFieldEnum]


  export const SaleItemScalarFieldEnum: {
    id: 'id',
    saleId: 'saleId',
    productId: 'productId',
    variantId: 'variantId',
    name: 'name',
    sku: 'sku',
    price: 'price',
    quantity: 'quantity',
    discount: 'discount',
    total: 'total',
    createdAt: 'createdAt'
  };

  export type SaleItemScalarFieldEnum = (typeof SaleItemScalarFieldEnum)[keyof typeof SaleItemScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    name: 'name',
    contactPerson: 'contactPerson',
    email: 'email',
    phone: 'phone',
    address: 'address',
    paymentTerms: 'paymentTerms',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    supplierId: 'supplierId',
    purchaseNumber: 'purchaseNumber',
    subtotal: 'subtotal',
    tax: 'tax',
    total: 'total',
    status: 'status',
    deliveryDate: 'deliveryDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const PurchaseItemScalarFieldEnum: {
    id: 'id',
    purchaseId: 'purchaseId',
    productId: 'productId',
    variantId: 'variantId',
    name: 'name',
    sku: 'sku',
    costPrice: 'costPrice',
    quantity: 'quantity',
    total: 'total',
    createdAt: 'createdAt'
  };

  export type PurchaseItemScalarFieldEnum = (typeof PurchaseItemScalarFieldEnum)[keyof typeof PurchaseItemScalarFieldEnum]


  export const StockMovementScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    productId: 'productId',
    variantId: 'variantId',
    movementType: 'movementType',
    quantity: 'quantity',
    referenceType: 'referenceType',
    referenceId: 'referenceId',
    referenceNumber: 'referenceNumber',
    locationFrom: 'locationFrom',
    locationTo: 'locationTo',
    notes: 'notes',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type StockMovementScalarFieldEnum = (typeof StockMovementScalarFieldEnum)[keyof typeof StockMovementScalarFieldEnum]


  export const StockTakeScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    location: 'location',
    status: 'status',
    notes: 'notes',
    createdBy: 'createdBy',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockTakeScalarFieldEnum = (typeof StockTakeScalarFieldEnum)[keyof typeof StockTakeScalarFieldEnum]


  export const StockTakeItemScalarFieldEnum: {
    id: 'id',
    stockTakeId: 'stockTakeId',
    productId: 'productId',
    variantId: 'variantId',
    productName: 'productName',
    sku: 'sku',
    expectedQuantity: 'expectedQuantity',
    countedQuantity: 'countedQuantity',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type StockTakeItemScalarFieldEnum = (typeof StockTakeItemScalarFieldEnum)[keyof typeof StockTakeItemScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    link: 'link',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    oldValues: 'oldValues',
    newValues: 'newValues',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SupportTicketScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    vendorName: 'vendorName',
    subject: 'subject',
    description: 'description',
    status: 'status',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupportTicketScalarFieldEnum = (typeof SupportTicketScalarFieldEnum)[keyof typeof SupportTicketScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    type: 'type',
    period: 'period',
    startDate: 'startDate',
    endDate: 'endDate',
    data: 'data',
    generatedBy: 'generatedBy',
    generatedAt: 'generatedAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const PricingPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    duration: 'duration',
    features: 'features',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PricingPlanScalarFieldEnum = (typeof PricingPlanScalarFieldEnum)[keyof typeof PricingPlanScalarFieldEnum]


  export const SystemSettingsScalarFieldEnum: {
    id: 'id',
    settingKey: 'settingKey',
    settingValue: 'settingValue',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingsScalarFieldEnum = (typeof SystemSettingsScalarFieldEnum)[keyof typeof SystemSettingsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan'
   */
  export type EnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'SaleStatus'
   */
  export type EnumSaleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SaleStatus'>
    


  /**
   * Reference to a field of type 'PurchaseStatus'
   */
  export type EnumPurchaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseStatus'>
    


  /**
   * Reference to a field of type 'StockMovementType'
   */
  export type EnumStockMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockMovementType'>
    


  /**
   * Reference to a field of type 'StockTakeStatus'
   */
  export type EnumStockTakeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockTakeStatus'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    


  /**
   * Reference to a field of type 'TicketPriority'
   */
  export type EnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority'>
    


  /**
   * Reference to a field of type 'ReportType'
   */
  export type EnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType'>
    


  /**
   * Reference to a field of type 'ReportPeriod'
   */
  export type EnumReportPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportPeriod'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: StringFilter<"Vendor"> | string
    name?: StringFilter<"Vendor"> | string
    email?: StringFilter<"Vendor"> | string
    phone?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    businessType?: StringNullableFilter<"Vendor"> | string | null
    subscriptionPlan?: EnumSubscriptionPlanFilter<"Vendor"> | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFilter<"Vendor"> | $Enums.SubscriptionStatus
    subscriptionExpiry?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    isApproved?: BoolFilter<"Vendor"> | boolean
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    users?: UserListRelationFilter
    products?: ProductListRelationFilter
    customers?: CustomerListRelationFilter
    sales?: SaleListRelationFilter
    suppliers?: SupplierListRelationFilter
    purchases?: PurchaseListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    stockTakes?: StockTakeListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
    reports?: ReportListRelationFilter
    vendorSettings?: XOR<VendorSettingsNullableRelationFilter, VendorSettingsWhereInput> | null
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    businessType?: SortOrderInput | SortOrder
    subscriptionPlan?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionExpiry?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    customers?: CustomerOrderByRelationAggregateInput
    sales?: SaleOrderByRelationAggregateInput
    suppliers?: SupplierOrderByRelationAggregateInput
    purchases?: PurchaseOrderByRelationAggregateInput
    stockMovements?: StockMovementOrderByRelationAggregateInput
    stockTakes?: StockTakeOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    supportTickets?: SupportTicketOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    vendorSettings?: VendorSettingsOrderByWithRelationInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    name?: StringFilter<"Vendor"> | string
    phone?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    businessType?: StringNullableFilter<"Vendor"> | string | null
    subscriptionPlan?: EnumSubscriptionPlanFilter<"Vendor"> | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFilter<"Vendor"> | $Enums.SubscriptionStatus
    subscriptionExpiry?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    isApproved?: BoolFilter<"Vendor"> | boolean
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    users?: UserListRelationFilter
    products?: ProductListRelationFilter
    customers?: CustomerListRelationFilter
    sales?: SaleListRelationFilter
    suppliers?: SupplierListRelationFilter
    purchases?: PurchaseListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    stockTakes?: StockTakeListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
    reports?: ReportListRelationFilter
    vendorSettings?: XOR<VendorSettingsNullableRelationFilter, VendorSettingsWhereInput> | null
  }, "id" | "email">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    businessType?: SortOrderInput | SortOrder
    subscriptionPlan?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionExpiry?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vendor"> | string
    name?: StringWithAggregatesFilter<"Vendor"> | string
    email?: StringWithAggregatesFilter<"Vendor"> | string
    phone?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    address?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    businessType?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    subscriptionPlan?: EnumSubscriptionPlanWithAggregatesFilter<"Vendor"> | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusWithAggregatesFilter<"Vendor"> | $Enums.SubscriptionStatus
    subscriptionExpiry?: DateTimeNullableWithAggregatesFilter<"Vendor"> | Date | string | null
    isApproved?: BoolWithAggregatesFilter<"Vendor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
  }

  export type VendorSettingsWhereInput = {
    AND?: VendorSettingsWhereInput | VendorSettingsWhereInput[]
    OR?: VendorSettingsWhereInput[]
    NOT?: VendorSettingsWhereInput | VendorSettingsWhereInput[]
    id?: StringFilter<"VendorSettings"> | string
    vendorId?: StringFilter<"VendorSettings"> | string
    taxRate?: DecimalFilter<"VendorSettings"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"VendorSettings"> | string
    timezone?: StringFilter<"VendorSettings"> | string
    receiptHeader?: StringNullableFilter<"VendorSettings"> | string | null
    receiptFooter?: StringNullableFilter<"VendorSettings"> | string | null
    loyaltyEnabled?: BoolFilter<"VendorSettings"> | boolean
    loyaltyPointsPerDollar?: DecimalFilter<"VendorSettings"> | Decimal | DecimalJsLike | number | string
    loyaltyRedemptionRate?: DecimalFilter<"VendorSettings"> | Decimal | DecimalJsLike | number | string
    loyaltyMinimumPoints?: IntFilter<"VendorSettings"> | number
    lowStockAlert?: BoolFilter<"VendorSettings"> | boolean
    lowStockThreshold?: IntFilter<"VendorSettings"> | number
    emailNotifications?: BoolFilter<"VendorSettings"> | boolean
    smsNotifications?: BoolFilter<"VendorSettings"> | boolean
    dailyReports?: BoolFilter<"VendorSettings"> | boolean
    createdAt?: DateTimeFilter<"VendorSettings"> | Date | string
    updatedAt?: DateTimeFilter<"VendorSettings"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }

  export type VendorSettingsOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    taxRate?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    receiptHeader?: SortOrderInput | SortOrder
    receiptFooter?: SortOrderInput | SortOrder
    loyaltyEnabled?: SortOrder
    loyaltyPointsPerDollar?: SortOrder
    loyaltyRedemptionRate?: SortOrder
    loyaltyMinimumPoints?: SortOrder
    lowStockAlert?: SortOrder
    lowStockThreshold?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    dailyReports?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type VendorSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vendorId?: string
    AND?: VendorSettingsWhereInput | VendorSettingsWhereInput[]
    OR?: VendorSettingsWhereInput[]
    NOT?: VendorSettingsWhereInput | VendorSettingsWhereInput[]
    taxRate?: DecimalFilter<"VendorSettings"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"VendorSettings"> | string
    timezone?: StringFilter<"VendorSettings"> | string
    receiptHeader?: StringNullableFilter<"VendorSettings"> | string | null
    receiptFooter?: StringNullableFilter<"VendorSettings"> | string | null
    loyaltyEnabled?: BoolFilter<"VendorSettings"> | boolean
    loyaltyPointsPerDollar?: DecimalFilter<"VendorSettings"> | Decimal | DecimalJsLike | number | string
    loyaltyRedemptionRate?: DecimalFilter<"VendorSettings"> | Decimal | DecimalJsLike | number | string
    loyaltyMinimumPoints?: IntFilter<"VendorSettings"> | number
    lowStockAlert?: BoolFilter<"VendorSettings"> | boolean
    lowStockThreshold?: IntFilter<"VendorSettings"> | number
    emailNotifications?: BoolFilter<"VendorSettings"> | boolean
    smsNotifications?: BoolFilter<"VendorSettings"> | boolean
    dailyReports?: BoolFilter<"VendorSettings"> | boolean
    createdAt?: DateTimeFilter<"VendorSettings"> | Date | string
    updatedAt?: DateTimeFilter<"VendorSettings"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }, "id" | "vendorId">

  export type VendorSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    taxRate?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    receiptHeader?: SortOrderInput | SortOrder
    receiptFooter?: SortOrderInput | SortOrder
    loyaltyEnabled?: SortOrder
    loyaltyPointsPerDollar?: SortOrder
    loyaltyRedemptionRate?: SortOrder
    loyaltyMinimumPoints?: SortOrder
    lowStockAlert?: SortOrder
    lowStockThreshold?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    dailyReports?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorSettingsCountOrderByAggregateInput
    _avg?: VendorSettingsAvgOrderByAggregateInput
    _max?: VendorSettingsMaxOrderByAggregateInput
    _min?: VendorSettingsMinOrderByAggregateInput
    _sum?: VendorSettingsSumOrderByAggregateInput
  }

  export type VendorSettingsScalarWhereWithAggregatesInput = {
    AND?: VendorSettingsScalarWhereWithAggregatesInput | VendorSettingsScalarWhereWithAggregatesInput[]
    OR?: VendorSettingsScalarWhereWithAggregatesInput[]
    NOT?: VendorSettingsScalarWhereWithAggregatesInput | VendorSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorSettings"> | string
    vendorId?: StringWithAggregatesFilter<"VendorSettings"> | string
    taxRate?: DecimalWithAggregatesFilter<"VendorSettings"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"VendorSettings"> | string
    timezone?: StringWithAggregatesFilter<"VendorSettings"> | string
    receiptHeader?: StringNullableWithAggregatesFilter<"VendorSettings"> | string | null
    receiptFooter?: StringNullableWithAggregatesFilter<"VendorSettings"> | string | null
    loyaltyEnabled?: BoolWithAggregatesFilter<"VendorSettings"> | boolean
    loyaltyPointsPerDollar?: DecimalWithAggregatesFilter<"VendorSettings"> | Decimal | DecimalJsLike | number | string
    loyaltyRedemptionRate?: DecimalWithAggregatesFilter<"VendorSettings"> | Decimal | DecimalJsLike | number | string
    loyaltyMinimumPoints?: IntWithAggregatesFilter<"VendorSettings"> | number
    lowStockAlert?: BoolWithAggregatesFilter<"VendorSettings"> | boolean
    lowStockThreshold?: IntWithAggregatesFilter<"VendorSettings"> | number
    emailNotifications?: BoolWithAggregatesFilter<"VendorSettings"> | boolean
    smsNotifications?: BoolWithAggregatesFilter<"VendorSettings"> | boolean
    dailyReports?: BoolWithAggregatesFilter<"VendorSettings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"VendorSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VendorSettings"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    vendorId?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    terminalId?: StringNullableFilter<"User"> | string | null
    assignedLocations?: JsonNullableFilter<"User">
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    vendor?: XOR<VendorNullableRelationFilter, VendorWhereInput> | null
    cashierSchedule?: XOR<CashierScheduleNullableRelationFilter, CashierScheduleWhereInput> | null
    sales?: SaleListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    stockTakes?: StockTakeListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    reports?: ReportListRelationFilter
    productAssignments?: CashierProductAssignmentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    isActive?: SortOrder
    terminalId?: SortOrderInput | SortOrder
    assignedLocations?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    cashierSchedule?: CashierScheduleOrderByWithRelationInput
    sales?: SaleOrderByRelationAggregateInput
    stockMovements?: StockMovementOrderByRelationAggregateInput
    stockTakes?: StockTakeOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    productAssignments?: CashierProductAssignmentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    vendorId?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    terminalId?: StringNullableFilter<"User"> | string | null
    assignedLocations?: JsonNullableFilter<"User">
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    vendor?: XOR<VendorNullableRelationFilter, VendorWhereInput> | null
    cashierSchedule?: XOR<CashierScheduleNullableRelationFilter, CashierScheduleWhereInput> | null
    sales?: SaleListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    stockTakes?: StockTakeListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    reports?: ReportListRelationFilter
    productAssignments?: CashierProductAssignmentListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    isActive?: SortOrder
    terminalId?: SortOrderInput | SortOrder
    assignedLocations?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    vendorId?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    terminalId?: StringNullableWithAggregatesFilter<"User"> | string | null
    assignedLocations?: JsonNullableWithAggregatesFilter<"User">
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CashierScheduleWhereInput = {
    AND?: CashierScheduleWhereInput | CashierScheduleWhereInput[]
    OR?: CashierScheduleWhereInput[]
    NOT?: CashierScheduleWhereInput | CashierScheduleWhereInput[]
    id?: StringFilter<"CashierSchedule"> | string
    userId?: StringFilter<"CashierSchedule"> | string
    checkInTime?: StringFilter<"CashierSchedule"> | string
    checkOutTime?: StringFilter<"CashierSchedule"> | string
    workDays?: JsonFilter<"CashierSchedule">
    timezone?: StringFilter<"CashierSchedule"> | string
    isActive?: BoolFilter<"CashierSchedule"> | boolean
    createdAt?: DateTimeFilter<"CashierSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"CashierSchedule"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CashierScheduleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    workDays?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CashierScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: CashierScheduleWhereInput | CashierScheduleWhereInput[]
    OR?: CashierScheduleWhereInput[]
    NOT?: CashierScheduleWhereInput | CashierScheduleWhereInput[]
    checkInTime?: StringFilter<"CashierSchedule"> | string
    checkOutTime?: StringFilter<"CashierSchedule"> | string
    workDays?: JsonFilter<"CashierSchedule">
    timezone?: StringFilter<"CashierSchedule"> | string
    isActive?: BoolFilter<"CashierSchedule"> | boolean
    createdAt?: DateTimeFilter<"CashierSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"CashierSchedule"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type CashierScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    workDays?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CashierScheduleCountOrderByAggregateInput
    _max?: CashierScheduleMaxOrderByAggregateInput
    _min?: CashierScheduleMinOrderByAggregateInput
  }

  export type CashierScheduleScalarWhereWithAggregatesInput = {
    AND?: CashierScheduleScalarWhereWithAggregatesInput | CashierScheduleScalarWhereWithAggregatesInput[]
    OR?: CashierScheduleScalarWhereWithAggregatesInput[]
    NOT?: CashierScheduleScalarWhereWithAggregatesInput | CashierScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CashierSchedule"> | string
    userId?: StringWithAggregatesFilter<"CashierSchedule"> | string
    checkInTime?: StringWithAggregatesFilter<"CashierSchedule"> | string
    checkOutTime?: StringWithAggregatesFilter<"CashierSchedule"> | string
    workDays?: JsonWithAggregatesFilter<"CashierSchedule">
    timezone?: StringWithAggregatesFilter<"CashierSchedule"> | string
    isActive?: BoolWithAggregatesFilter<"CashierSchedule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CashierSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CashierSchedule"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    vendorId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    sku?: StringFilter<"Product"> | string
    barcode?: StringNullableFilter<"Product"> | string | null
    category?: StringNullableFilter<"Product"> | string | null
    brand?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    totalStock?: IntFilter<"Product"> | number
    minStock?: IntFilter<"Product"> | number
    maxStock?: IntFilter<"Product"> | number
    unit?: StringFilter<"Product"> | string
    images?: JsonNullableFilter<"Product">
    isActive?: BoolFilter<"Product"> | boolean
    expiryDate?: DateTimeNullableFilter<"Product"> | Date | string | null
    trackExpiry?: BoolFilter<"Product"> | boolean
    trackSerial?: BoolFilter<"Product"> | boolean
    tags?: JsonNullableFilter<"Product">
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    variants?: ProductVariantListRelationFilter
    stockLocations?: ProductStockLocationListRelationFilter
    saleItems?: SaleItemListRelationFilter
    purchaseItems?: PurchaseItemListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    stockTakeItems?: StockTakeItemListRelationFilter
    cashierAssignments?: CashierProductAssignmentListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sku?: SortOrder
    barcode?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    price?: SortOrder
    costPrice?: SortOrder
    totalStock?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    unit?: SortOrder
    images?: SortOrderInput | SortOrder
    isActive?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    trackExpiry?: SortOrder
    trackSerial?: SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    variants?: ProductVariantOrderByRelationAggregateInput
    stockLocations?: ProductStockLocationOrderByRelationAggregateInput
    saleItems?: SaleItemOrderByRelationAggregateInput
    purchaseItems?: PurchaseItemOrderByRelationAggregateInput
    stockMovements?: StockMovementOrderByRelationAggregateInput
    stockTakeItems?: StockTakeItemOrderByRelationAggregateInput
    cashierAssignments?: CashierProductAssignmentOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vendorId_sku?: ProductVendorIdSkuCompoundUniqueInput
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    vendorId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    sku?: StringFilter<"Product"> | string
    barcode?: StringNullableFilter<"Product"> | string | null
    category?: StringNullableFilter<"Product"> | string | null
    brand?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    totalStock?: IntFilter<"Product"> | number
    minStock?: IntFilter<"Product"> | number
    maxStock?: IntFilter<"Product"> | number
    unit?: StringFilter<"Product"> | string
    images?: JsonNullableFilter<"Product">
    isActive?: BoolFilter<"Product"> | boolean
    expiryDate?: DateTimeNullableFilter<"Product"> | Date | string | null
    trackExpiry?: BoolFilter<"Product"> | boolean
    trackSerial?: BoolFilter<"Product"> | boolean
    tags?: JsonNullableFilter<"Product">
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    variants?: ProductVariantListRelationFilter
    stockLocations?: ProductStockLocationListRelationFilter
    saleItems?: SaleItemListRelationFilter
    purchaseItems?: PurchaseItemListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    stockTakeItems?: StockTakeItemListRelationFilter
    cashierAssignments?: CashierProductAssignmentListRelationFilter
  }, "id" | "vendorId_sku">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sku?: SortOrder
    barcode?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    price?: SortOrder
    costPrice?: SortOrder
    totalStock?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    unit?: SortOrder
    images?: SortOrderInput | SortOrder
    isActive?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    trackExpiry?: SortOrder
    trackSerial?: SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    vendorId?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    sku?: StringWithAggregatesFilter<"Product"> | string
    barcode?: StringNullableWithAggregatesFilter<"Product"> | string | null
    category?: StringNullableWithAggregatesFilter<"Product"> | string | null
    brand?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    totalStock?: IntWithAggregatesFilter<"Product"> | number
    minStock?: IntWithAggregatesFilter<"Product"> | number
    maxStock?: IntWithAggregatesFilter<"Product"> | number
    unit?: StringWithAggregatesFilter<"Product"> | string
    images?: JsonNullableWithAggregatesFilter<"Product">
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    expiryDate?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    trackExpiry?: BoolWithAggregatesFilter<"Product"> | boolean
    trackSerial?: BoolWithAggregatesFilter<"Product"> | boolean
    tags?: JsonNullableWithAggregatesFilter<"Product">
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProductVariantWhereInput = {
    AND?: ProductVariantWhereInput | ProductVariantWhereInput[]
    OR?: ProductVariantWhereInput[]
    NOT?: ProductVariantWhereInput | ProductVariantWhereInput[]
    id?: StringFilter<"ProductVariant"> | string
    productId?: StringFilter<"ProductVariant"> | string
    name?: StringFilter<"ProductVariant"> | string
    value?: StringFilter<"ProductVariant"> | string
    priceModifier?: DecimalFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string
    stock?: IntFilter<"ProductVariant"> | number
    sku?: StringFilter<"ProductVariant"> | string
    barcode?: StringNullableFilter<"ProductVariant"> | string | null
    isActive?: BoolFilter<"ProductVariant"> | boolean
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    stockLocations?: ProductStockLocationListRelationFilter
    saleItems?: SaleItemListRelationFilter
    purchaseItems?: PurchaseItemListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    stockTakeItems?: StockTakeItemListRelationFilter
  }

  export type ProductVariantOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    priceModifier?: SortOrder
    stock?: SortOrder
    sku?: SortOrder
    barcode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    stockLocations?: ProductStockLocationOrderByRelationAggregateInput
    saleItems?: SaleItemOrderByRelationAggregateInput
    purchaseItems?: PurchaseItemOrderByRelationAggregateInput
    stockMovements?: StockMovementOrderByRelationAggregateInput
    stockTakeItems?: StockTakeItemOrderByRelationAggregateInput
  }

  export type ProductVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_sku?: ProductVariantProductIdSkuCompoundUniqueInput
    AND?: ProductVariantWhereInput | ProductVariantWhereInput[]
    OR?: ProductVariantWhereInput[]
    NOT?: ProductVariantWhereInput | ProductVariantWhereInput[]
    productId?: StringFilter<"ProductVariant"> | string
    name?: StringFilter<"ProductVariant"> | string
    value?: StringFilter<"ProductVariant"> | string
    priceModifier?: DecimalFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string
    stock?: IntFilter<"ProductVariant"> | number
    sku?: StringFilter<"ProductVariant"> | string
    barcode?: StringNullableFilter<"ProductVariant"> | string | null
    isActive?: BoolFilter<"ProductVariant"> | boolean
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    stockLocations?: ProductStockLocationListRelationFilter
    saleItems?: SaleItemListRelationFilter
    purchaseItems?: PurchaseItemListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    stockTakeItems?: StockTakeItemListRelationFilter
  }, "id" | "productId_sku">

  export type ProductVariantOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    priceModifier?: SortOrder
    stock?: SortOrder
    sku?: SortOrder
    barcode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductVariantCountOrderByAggregateInput
    _avg?: ProductVariantAvgOrderByAggregateInput
    _max?: ProductVariantMaxOrderByAggregateInput
    _min?: ProductVariantMinOrderByAggregateInput
    _sum?: ProductVariantSumOrderByAggregateInput
  }

  export type ProductVariantScalarWhereWithAggregatesInput = {
    AND?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[]
    OR?: ProductVariantScalarWhereWithAggregatesInput[]
    NOT?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductVariant"> | string
    productId?: StringWithAggregatesFilter<"ProductVariant"> | string
    name?: StringWithAggregatesFilter<"ProductVariant"> | string
    value?: StringWithAggregatesFilter<"ProductVariant"> | string
    priceModifier?: DecimalWithAggregatesFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string
    stock?: IntWithAggregatesFilter<"ProductVariant"> | number
    sku?: StringWithAggregatesFilter<"ProductVariant"> | string
    barcode?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    isActive?: BoolWithAggregatesFilter<"ProductVariant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string
  }

  export type ProductStockLocationWhereInput = {
    AND?: ProductStockLocationWhereInput | ProductStockLocationWhereInput[]
    OR?: ProductStockLocationWhereInput[]
    NOT?: ProductStockLocationWhereInput | ProductStockLocationWhereInput[]
    id?: StringFilter<"ProductStockLocation"> | string
    productId?: StringFilter<"ProductStockLocation"> | string
    variantId?: StringNullableFilter<"ProductStockLocation"> | string | null
    locationName?: StringFilter<"ProductStockLocation"> | string
    quantity?: IntFilter<"ProductStockLocation"> | number
    reservedQuantity?: IntFilter<"ProductStockLocation"> | number
    createdAt?: DateTimeFilter<"ProductStockLocation"> | Date | string
    updatedAt?: DateTimeFilter<"ProductStockLocation"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    variant?: XOR<ProductVariantNullableRelationFilter, ProductVariantWhereInput> | null
  }

  export type ProductStockLocationOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    locationName?: SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    variant?: ProductVariantOrderByWithRelationInput
  }

  export type ProductStockLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_variantId_locationName?: ProductStockLocationProductIdVariantIdLocationNameCompoundUniqueInput
    AND?: ProductStockLocationWhereInput | ProductStockLocationWhereInput[]
    OR?: ProductStockLocationWhereInput[]
    NOT?: ProductStockLocationWhereInput | ProductStockLocationWhereInput[]
    productId?: StringFilter<"ProductStockLocation"> | string
    variantId?: StringNullableFilter<"ProductStockLocation"> | string | null
    locationName?: StringFilter<"ProductStockLocation"> | string
    quantity?: IntFilter<"ProductStockLocation"> | number
    reservedQuantity?: IntFilter<"ProductStockLocation"> | number
    createdAt?: DateTimeFilter<"ProductStockLocation"> | Date | string
    updatedAt?: DateTimeFilter<"ProductStockLocation"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    variant?: XOR<ProductVariantNullableRelationFilter, ProductVariantWhereInput> | null
  }, "id" | "productId_variantId_locationName">

  export type ProductStockLocationOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    locationName?: SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductStockLocationCountOrderByAggregateInput
    _avg?: ProductStockLocationAvgOrderByAggregateInput
    _max?: ProductStockLocationMaxOrderByAggregateInput
    _min?: ProductStockLocationMinOrderByAggregateInput
    _sum?: ProductStockLocationSumOrderByAggregateInput
  }

  export type ProductStockLocationScalarWhereWithAggregatesInput = {
    AND?: ProductStockLocationScalarWhereWithAggregatesInput | ProductStockLocationScalarWhereWithAggregatesInput[]
    OR?: ProductStockLocationScalarWhereWithAggregatesInput[]
    NOT?: ProductStockLocationScalarWhereWithAggregatesInput | ProductStockLocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductStockLocation"> | string
    productId?: StringWithAggregatesFilter<"ProductStockLocation"> | string
    variantId?: StringNullableWithAggregatesFilter<"ProductStockLocation"> | string | null
    locationName?: StringWithAggregatesFilter<"ProductStockLocation"> | string
    quantity?: IntWithAggregatesFilter<"ProductStockLocation"> | number
    reservedQuantity?: IntWithAggregatesFilter<"ProductStockLocation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProductStockLocation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductStockLocation"> | Date | string
  }

  export type CashierProductAssignmentWhereInput = {
    AND?: CashierProductAssignmentWhereInput | CashierProductAssignmentWhereInput[]
    OR?: CashierProductAssignmentWhereInput[]
    NOT?: CashierProductAssignmentWhereInput | CashierProductAssignmentWhereInput[]
    id?: StringFilter<"CashierProductAssignment"> | string
    userId?: StringFilter<"CashierProductAssignment"> | string
    productId?: StringFilter<"CashierProductAssignment"> | string
    assignedAt?: DateTimeFilter<"CashierProductAssignment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type CashierProductAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    assignedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type CashierProductAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_productId?: CashierProductAssignmentUserIdProductIdCompoundUniqueInput
    AND?: CashierProductAssignmentWhereInput | CashierProductAssignmentWhereInput[]
    OR?: CashierProductAssignmentWhereInput[]
    NOT?: CashierProductAssignmentWhereInput | CashierProductAssignmentWhereInput[]
    userId?: StringFilter<"CashierProductAssignment"> | string
    productId?: StringFilter<"CashierProductAssignment"> | string
    assignedAt?: DateTimeFilter<"CashierProductAssignment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id" | "userId_productId">

  export type CashierProductAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    assignedAt?: SortOrder
    _count?: CashierProductAssignmentCountOrderByAggregateInput
    _max?: CashierProductAssignmentMaxOrderByAggregateInput
    _min?: CashierProductAssignmentMinOrderByAggregateInput
  }

  export type CashierProductAssignmentScalarWhereWithAggregatesInput = {
    AND?: CashierProductAssignmentScalarWhereWithAggregatesInput | CashierProductAssignmentScalarWhereWithAggregatesInput[]
    OR?: CashierProductAssignmentScalarWhereWithAggregatesInput[]
    NOT?: CashierProductAssignmentScalarWhereWithAggregatesInput | CashierProductAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CashierProductAssignment"> | string
    userId?: StringWithAggregatesFilter<"CashierProductAssignment"> | string
    productId?: StringWithAggregatesFilter<"CashierProductAssignment"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"CashierProductAssignment"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    vendorId?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Customer"> | Date | string | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    totalSpent?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    visitCount?: IntFilter<"Customer"> | number
    lastVisit?: DateTimeNullableFilter<"Customer"> | Date | string | null
    isActive?: BoolFilter<"Customer"> | boolean
    notes?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    sales?: SaleListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    visitCount?: SortOrder
    lastVisit?: SortOrderInput | SortOrder
    isActive?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    sales?: SaleOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    vendorId?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Customer"> | Date | string | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    totalSpent?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    visitCount?: IntFilter<"Customer"> | number
    lastVisit?: DateTimeNullableFilter<"Customer"> | Date | string | null
    isActive?: BoolFilter<"Customer"> | boolean
    notes?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    sales?: SaleListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    visitCount?: SortOrder
    lastVisit?: SortOrderInput | SortOrder
    isActive?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    vendorId?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    loyaltyPoints?: IntWithAggregatesFilter<"Customer"> | number
    totalSpent?: DecimalWithAggregatesFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    visitCount?: IntWithAggregatesFilter<"Customer"> | number
    lastVisit?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Customer"> | boolean
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type SaleWhereInput = {
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    id?: StringFilter<"Sale"> | string
    vendorId?: StringFilter<"Sale"> | string
    cashierId?: StringFilter<"Sale"> | string
    terminalId?: StringFilter<"Sale"> | string
    customerId?: StringNullableFilter<"Sale"> | string | null
    receiptNumber?: StringFilter<"Sale"> | string
    subtotal?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    paid?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Sale"> | $Enums.PaymentMethod
    status?: EnumSaleStatusFilter<"Sale"> | $Enums.SaleStatus
    refundAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFilter<"Sale"> | number
    loyaltyPointsUsed?: IntFilter<"Sale"> | number
    notes?: StringNullableFilter<"Sale"> | string | null
    receiptData?: JsonNullableFilter<"Sale">
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    cashier?: XOR<UserRelationFilter, UserWhereInput>
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    items?: SaleItemListRelationFilter
  }

  export type SaleOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    cashierId?: SortOrder
    terminalId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    receiptNumber?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paid?: SortOrder
    changeAmount?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    refundAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    loyaltyPointsUsed?: SortOrder
    notes?: SortOrderInput | SortOrder
    receiptData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    cashier?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    items?: SaleItemOrderByRelationAggregateInput
  }

  export type SaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vendorId_receiptNumber?: SaleVendorIdReceiptNumberCompoundUniqueInput
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    vendorId?: StringFilter<"Sale"> | string
    cashierId?: StringFilter<"Sale"> | string
    terminalId?: StringFilter<"Sale"> | string
    customerId?: StringNullableFilter<"Sale"> | string | null
    receiptNumber?: StringFilter<"Sale"> | string
    subtotal?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    paid?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Sale"> | $Enums.PaymentMethod
    status?: EnumSaleStatusFilter<"Sale"> | $Enums.SaleStatus
    refundAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFilter<"Sale"> | number
    loyaltyPointsUsed?: IntFilter<"Sale"> | number
    notes?: StringNullableFilter<"Sale"> | string | null
    receiptData?: JsonNullableFilter<"Sale">
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    cashier?: XOR<UserRelationFilter, UserWhereInput>
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    items?: SaleItemListRelationFilter
  }, "id" | "vendorId_receiptNumber">

  export type SaleOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    cashierId?: SortOrder
    terminalId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    receiptNumber?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paid?: SortOrder
    changeAmount?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    refundAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    loyaltyPointsUsed?: SortOrder
    notes?: SortOrderInput | SortOrder
    receiptData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SaleCountOrderByAggregateInput
    _avg?: SaleAvgOrderByAggregateInput
    _max?: SaleMaxOrderByAggregateInput
    _min?: SaleMinOrderByAggregateInput
    _sum?: SaleSumOrderByAggregateInput
  }

  export type SaleScalarWhereWithAggregatesInput = {
    AND?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    OR?: SaleScalarWhereWithAggregatesInput[]
    NOT?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sale"> | string
    vendorId?: StringWithAggregatesFilter<"Sale"> | string
    cashierId?: StringWithAggregatesFilter<"Sale"> | string
    terminalId?: StringWithAggregatesFilter<"Sale"> | string
    customerId?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    receiptNumber?: StringWithAggregatesFilter<"Sale"> | string
    subtotal?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    paid?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Sale"> | $Enums.PaymentMethod
    status?: EnumSaleStatusWithAggregatesFilter<"Sale"> | $Enums.SaleStatus
    refundAmount?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntWithAggregatesFilter<"Sale"> | number
    loyaltyPointsUsed?: IntWithAggregatesFilter<"Sale"> | number
    notes?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    receiptData?: JsonNullableWithAggregatesFilter<"Sale">
    createdAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
  }

  export type SaleItemWhereInput = {
    AND?: SaleItemWhereInput | SaleItemWhereInput[]
    OR?: SaleItemWhereInput[]
    NOT?: SaleItemWhereInput | SaleItemWhereInput[]
    id?: StringFilter<"SaleItem"> | string
    saleId?: StringFilter<"SaleItem"> | string
    productId?: StringFilter<"SaleItem"> | string
    variantId?: StringNullableFilter<"SaleItem"> | string | null
    name?: StringFilter<"SaleItem"> | string
    sku?: StringFilter<"SaleItem"> | string
    price?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"SaleItem"> | number
    discount?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleItem"> | Date | string
    sale?: XOR<SaleRelationFilter, SaleWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    variant?: XOR<ProductVariantNullableRelationFilter, ProductVariantWhereInput> | null
  }

  export type SaleItemOrderByWithRelationInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    name?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    sale?: SaleOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    variant?: ProductVariantOrderByWithRelationInput
  }

  export type SaleItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleItemWhereInput | SaleItemWhereInput[]
    OR?: SaleItemWhereInput[]
    NOT?: SaleItemWhereInput | SaleItemWhereInput[]
    saleId?: StringFilter<"SaleItem"> | string
    productId?: StringFilter<"SaleItem"> | string
    variantId?: StringNullableFilter<"SaleItem"> | string | null
    name?: StringFilter<"SaleItem"> | string
    sku?: StringFilter<"SaleItem"> | string
    price?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"SaleItem"> | number
    discount?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleItem"> | Date | string
    sale?: XOR<SaleRelationFilter, SaleWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    variant?: XOR<ProductVariantNullableRelationFilter, ProductVariantWhereInput> | null
  }, "id">

  export type SaleItemOrderByWithAggregationInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    name?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    _count?: SaleItemCountOrderByAggregateInput
    _avg?: SaleItemAvgOrderByAggregateInput
    _max?: SaleItemMaxOrderByAggregateInput
    _min?: SaleItemMinOrderByAggregateInput
    _sum?: SaleItemSumOrderByAggregateInput
  }

  export type SaleItemScalarWhereWithAggregatesInput = {
    AND?: SaleItemScalarWhereWithAggregatesInput | SaleItemScalarWhereWithAggregatesInput[]
    OR?: SaleItemScalarWhereWithAggregatesInput[]
    NOT?: SaleItemScalarWhereWithAggregatesInput | SaleItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaleItem"> | string
    saleId?: StringWithAggregatesFilter<"SaleItem"> | string
    productId?: StringWithAggregatesFilter<"SaleItem"> | string
    variantId?: StringNullableWithAggregatesFilter<"SaleItem"> | string | null
    name?: StringWithAggregatesFilter<"SaleItem"> | string
    sku?: StringWithAggregatesFilter<"SaleItem"> | string
    price?: DecimalWithAggregatesFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    quantity?: IntWithAggregatesFilter<"SaleItem"> | number
    discount?: DecimalWithAggregatesFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"SaleItem"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    vendorId?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    paymentTerms?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    purchases?: PurchaseListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    purchases?: PurchaseOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    vendorId?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    paymentTerms?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    purchases?: PurchaseListRelationFilter
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    vendorId?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    contactPerson?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    address?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    paymentTerms?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    isActive?: BoolWithAggregatesFilter<"Supplier"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: StringFilter<"Purchase"> | string
    vendorId?: StringFilter<"Purchase"> | string
    supplierId?: StringFilter<"Purchase"> | string
    purchaseNumber?: StringFilter<"Purchase"> | string
    subtotal?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFilter<"Purchase"> | $Enums.PurchaseStatus
    deliveryDate?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    notes?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    items?: PurchaseItemListRelationFilter
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    supplierId?: SortOrder
    purchaseNumber?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    deliveryDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    items?: PurchaseItemOrderByRelationAggregateInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vendorId_purchaseNumber?: PurchaseVendorIdPurchaseNumberCompoundUniqueInput
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    vendorId?: StringFilter<"Purchase"> | string
    supplierId?: StringFilter<"Purchase"> | string
    purchaseNumber?: StringFilter<"Purchase"> | string
    subtotal?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFilter<"Purchase"> | $Enums.PurchaseStatus
    deliveryDate?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    notes?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    items?: PurchaseItemListRelationFilter
  }, "id" | "vendorId_purchaseNumber">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    supplierId?: SortOrder
    purchaseNumber?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    deliveryDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _avg?: PurchaseAvgOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
    _sum?: PurchaseSumOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Purchase"> | string
    vendorId?: StringWithAggregatesFilter<"Purchase"> | string
    supplierId?: StringWithAggregatesFilter<"Purchase"> | string
    purchaseNumber?: StringWithAggregatesFilter<"Purchase"> | string
    subtotal?: DecimalWithAggregatesFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalWithAggregatesFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusWithAggregatesFilter<"Purchase"> | $Enums.PurchaseStatus
    deliveryDate?: DateTimeNullableWithAggregatesFilter<"Purchase"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
  }

  export type PurchaseItemWhereInput = {
    AND?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    OR?: PurchaseItemWhereInput[]
    NOT?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    id?: StringFilter<"PurchaseItem"> | string
    purchaseId?: StringFilter<"PurchaseItem"> | string
    productId?: StringFilter<"PurchaseItem"> | string
    variantId?: StringNullableFilter<"PurchaseItem"> | string | null
    name?: StringFilter<"PurchaseItem"> | string
    sku?: StringFilter<"PurchaseItem"> | string
    costPrice?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"PurchaseItem"> | number
    total?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    purchase?: XOR<PurchaseRelationFilter, PurchaseWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    variant?: XOR<ProductVariantNullableRelationFilter, ProductVariantWhereInput> | null
  }

  export type PurchaseItemOrderByWithRelationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    name?: SortOrder
    sku?: SortOrder
    costPrice?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    purchase?: PurchaseOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    variant?: ProductVariantOrderByWithRelationInput
  }

  export type PurchaseItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    OR?: PurchaseItemWhereInput[]
    NOT?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    purchaseId?: StringFilter<"PurchaseItem"> | string
    productId?: StringFilter<"PurchaseItem"> | string
    variantId?: StringNullableFilter<"PurchaseItem"> | string | null
    name?: StringFilter<"PurchaseItem"> | string
    sku?: StringFilter<"PurchaseItem"> | string
    costPrice?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"PurchaseItem"> | number
    total?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    purchase?: XOR<PurchaseRelationFilter, PurchaseWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    variant?: XOR<ProductVariantNullableRelationFilter, ProductVariantWhereInput> | null
  }, "id">

  export type PurchaseItemOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    name?: SortOrder
    sku?: SortOrder
    costPrice?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    _count?: PurchaseItemCountOrderByAggregateInput
    _avg?: PurchaseItemAvgOrderByAggregateInput
    _max?: PurchaseItemMaxOrderByAggregateInput
    _min?: PurchaseItemMinOrderByAggregateInput
    _sum?: PurchaseItemSumOrderByAggregateInput
  }

  export type PurchaseItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseItemScalarWhereWithAggregatesInput | PurchaseItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseItemScalarWhereWithAggregatesInput | PurchaseItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseItem"> | string
    purchaseId?: StringWithAggregatesFilter<"PurchaseItem"> | string
    productId?: StringWithAggregatesFilter<"PurchaseItem"> | string
    variantId?: StringNullableWithAggregatesFilter<"PurchaseItem"> | string | null
    name?: StringWithAggregatesFilter<"PurchaseItem"> | string
    sku?: StringWithAggregatesFilter<"PurchaseItem"> | string
    costPrice?: DecimalWithAggregatesFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    quantity?: IntWithAggregatesFilter<"PurchaseItem"> | number
    total?: DecimalWithAggregatesFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseItem"> | Date | string
  }

  export type StockMovementWhereInput = {
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    id?: StringFilter<"StockMovement"> | string
    vendorId?: StringFilter<"StockMovement"> | string
    productId?: StringFilter<"StockMovement"> | string
    variantId?: StringNullableFilter<"StockMovement"> | string | null
    movementType?: EnumStockMovementTypeFilter<"StockMovement"> | $Enums.StockMovementType
    quantity?: IntFilter<"StockMovement"> | number
    referenceType?: StringNullableFilter<"StockMovement"> | string | null
    referenceId?: StringNullableFilter<"StockMovement"> | string | null
    referenceNumber?: StringNullableFilter<"StockMovement"> | string | null
    locationFrom?: StringNullableFilter<"StockMovement"> | string | null
    locationTo?: StringNullableFilter<"StockMovement"> | string | null
    notes?: StringNullableFilter<"StockMovement"> | string | null
    createdBy?: StringFilter<"StockMovement"> | string
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    variant?: XOR<ProductVariantNullableRelationFilter, ProductVariantWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type StockMovementOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    referenceType?: SortOrderInput | SortOrder
    referenceId?: SortOrderInput | SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    locationFrom?: SortOrderInput | SortOrder
    locationTo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    variant?: ProductVariantOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type StockMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    vendorId?: StringFilter<"StockMovement"> | string
    productId?: StringFilter<"StockMovement"> | string
    variantId?: StringNullableFilter<"StockMovement"> | string | null
    movementType?: EnumStockMovementTypeFilter<"StockMovement"> | $Enums.StockMovementType
    quantity?: IntFilter<"StockMovement"> | number
    referenceType?: StringNullableFilter<"StockMovement"> | string | null
    referenceId?: StringNullableFilter<"StockMovement"> | string | null
    referenceNumber?: StringNullableFilter<"StockMovement"> | string | null
    locationFrom?: StringNullableFilter<"StockMovement"> | string | null
    locationTo?: StringNullableFilter<"StockMovement"> | string | null
    notes?: StringNullableFilter<"StockMovement"> | string | null
    createdBy?: StringFilter<"StockMovement"> | string
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    variant?: XOR<ProductVariantNullableRelationFilter, ProductVariantWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type StockMovementOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    referenceType?: SortOrderInput | SortOrder
    referenceId?: SortOrderInput | SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    locationFrom?: SortOrderInput | SortOrder
    locationTo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: StockMovementCountOrderByAggregateInput
    _avg?: StockMovementAvgOrderByAggregateInput
    _max?: StockMovementMaxOrderByAggregateInput
    _min?: StockMovementMinOrderByAggregateInput
    _sum?: StockMovementSumOrderByAggregateInput
  }

  export type StockMovementScalarWhereWithAggregatesInput = {
    AND?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    OR?: StockMovementScalarWhereWithAggregatesInput[]
    NOT?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockMovement"> | string
    vendorId?: StringWithAggregatesFilter<"StockMovement"> | string
    productId?: StringWithAggregatesFilter<"StockMovement"> | string
    variantId?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    movementType?: EnumStockMovementTypeWithAggregatesFilter<"StockMovement"> | $Enums.StockMovementType
    quantity?: IntWithAggregatesFilter<"StockMovement"> | number
    referenceType?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    referenceId?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    referenceNumber?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    locationFrom?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    locationTo?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    notes?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    createdBy?: StringWithAggregatesFilter<"StockMovement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StockMovement"> | Date | string
  }

  export type StockTakeWhereInput = {
    AND?: StockTakeWhereInput | StockTakeWhereInput[]
    OR?: StockTakeWhereInput[]
    NOT?: StockTakeWhereInput | StockTakeWhereInput[]
    id?: StringFilter<"StockTake"> | string
    vendorId?: StringFilter<"StockTake"> | string
    location?: StringFilter<"StockTake"> | string
    status?: EnumStockTakeStatusFilter<"StockTake"> | $Enums.StockTakeStatus
    notes?: StringNullableFilter<"StockTake"> | string | null
    createdBy?: StringFilter<"StockTake"> | string
    completedAt?: DateTimeNullableFilter<"StockTake"> | Date | string | null
    createdAt?: DateTimeFilter<"StockTake"> | Date | string
    updatedAt?: DateTimeFilter<"StockTake"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    items?: StockTakeItemListRelationFilter
  }

  export type StockTakeOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    location?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    items?: StockTakeItemOrderByRelationAggregateInput
  }

  export type StockTakeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockTakeWhereInput | StockTakeWhereInput[]
    OR?: StockTakeWhereInput[]
    NOT?: StockTakeWhereInput | StockTakeWhereInput[]
    vendorId?: StringFilter<"StockTake"> | string
    location?: StringFilter<"StockTake"> | string
    status?: EnumStockTakeStatusFilter<"StockTake"> | $Enums.StockTakeStatus
    notes?: StringNullableFilter<"StockTake"> | string | null
    createdBy?: StringFilter<"StockTake"> | string
    completedAt?: DateTimeNullableFilter<"StockTake"> | Date | string | null
    createdAt?: DateTimeFilter<"StockTake"> | Date | string
    updatedAt?: DateTimeFilter<"StockTake"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    items?: StockTakeItemListRelationFilter
  }, "id">

  export type StockTakeOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    location?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StockTakeCountOrderByAggregateInput
    _max?: StockTakeMaxOrderByAggregateInput
    _min?: StockTakeMinOrderByAggregateInput
  }

  export type StockTakeScalarWhereWithAggregatesInput = {
    AND?: StockTakeScalarWhereWithAggregatesInput | StockTakeScalarWhereWithAggregatesInput[]
    OR?: StockTakeScalarWhereWithAggregatesInput[]
    NOT?: StockTakeScalarWhereWithAggregatesInput | StockTakeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockTake"> | string
    vendorId?: StringWithAggregatesFilter<"StockTake"> | string
    location?: StringWithAggregatesFilter<"StockTake"> | string
    status?: EnumStockTakeStatusWithAggregatesFilter<"StockTake"> | $Enums.StockTakeStatus
    notes?: StringNullableWithAggregatesFilter<"StockTake"> | string | null
    createdBy?: StringWithAggregatesFilter<"StockTake"> | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"StockTake"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StockTake"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StockTake"> | Date | string
  }

  export type StockTakeItemWhereInput = {
    AND?: StockTakeItemWhereInput | StockTakeItemWhereInput[]
    OR?: StockTakeItemWhereInput[]
    NOT?: StockTakeItemWhereInput | StockTakeItemWhereInput[]
    id?: StringFilter<"StockTakeItem"> | string
    stockTakeId?: StringFilter<"StockTakeItem"> | string
    productId?: StringFilter<"StockTakeItem"> | string
    variantId?: StringNullableFilter<"StockTakeItem"> | string | null
    productName?: StringFilter<"StockTakeItem"> | string
    sku?: StringFilter<"StockTakeItem"> | string
    expectedQuantity?: IntFilter<"StockTakeItem"> | number
    countedQuantity?: IntFilter<"StockTakeItem"> | number
    notes?: StringNullableFilter<"StockTakeItem"> | string | null
    createdAt?: DateTimeFilter<"StockTakeItem"> | Date | string
    stockTake?: XOR<StockTakeRelationFilter, StockTakeWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    variant?: XOR<ProductVariantNullableRelationFilter, ProductVariantWhereInput> | null
  }

  export type StockTakeItemOrderByWithRelationInput = {
    id?: SortOrder
    stockTakeId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    productName?: SortOrder
    sku?: SortOrder
    expectedQuantity?: SortOrder
    countedQuantity?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    stockTake?: StockTakeOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    variant?: ProductVariantOrderByWithRelationInput
  }

  export type StockTakeItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockTakeItemWhereInput | StockTakeItemWhereInput[]
    OR?: StockTakeItemWhereInput[]
    NOT?: StockTakeItemWhereInput | StockTakeItemWhereInput[]
    stockTakeId?: StringFilter<"StockTakeItem"> | string
    productId?: StringFilter<"StockTakeItem"> | string
    variantId?: StringNullableFilter<"StockTakeItem"> | string | null
    productName?: StringFilter<"StockTakeItem"> | string
    sku?: StringFilter<"StockTakeItem"> | string
    expectedQuantity?: IntFilter<"StockTakeItem"> | number
    countedQuantity?: IntFilter<"StockTakeItem"> | number
    notes?: StringNullableFilter<"StockTakeItem"> | string | null
    createdAt?: DateTimeFilter<"StockTakeItem"> | Date | string
    stockTake?: XOR<StockTakeRelationFilter, StockTakeWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    variant?: XOR<ProductVariantNullableRelationFilter, ProductVariantWhereInput> | null
  }, "id">

  export type StockTakeItemOrderByWithAggregationInput = {
    id?: SortOrder
    stockTakeId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    productName?: SortOrder
    sku?: SortOrder
    expectedQuantity?: SortOrder
    countedQuantity?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StockTakeItemCountOrderByAggregateInput
    _avg?: StockTakeItemAvgOrderByAggregateInput
    _max?: StockTakeItemMaxOrderByAggregateInput
    _min?: StockTakeItemMinOrderByAggregateInput
    _sum?: StockTakeItemSumOrderByAggregateInput
  }

  export type StockTakeItemScalarWhereWithAggregatesInput = {
    AND?: StockTakeItemScalarWhereWithAggregatesInput | StockTakeItemScalarWhereWithAggregatesInput[]
    OR?: StockTakeItemScalarWhereWithAggregatesInput[]
    NOT?: StockTakeItemScalarWhereWithAggregatesInput | StockTakeItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockTakeItem"> | string
    stockTakeId?: StringWithAggregatesFilter<"StockTakeItem"> | string
    productId?: StringWithAggregatesFilter<"StockTakeItem"> | string
    variantId?: StringNullableWithAggregatesFilter<"StockTakeItem"> | string | null
    productName?: StringWithAggregatesFilter<"StockTakeItem"> | string
    sku?: StringWithAggregatesFilter<"StockTakeItem"> | string
    expectedQuantity?: IntWithAggregatesFilter<"StockTakeItem"> | number
    countedQuantity?: IntWithAggregatesFilter<"StockTakeItem"> | number
    notes?: StringNullableWithAggregatesFilter<"StockTakeItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StockTakeItem"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    vendorId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    link?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    vendorId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    link?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    vendorId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    vendorId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringFilter<"AuditLog"> | string
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    vendorId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringFilter<"AuditLog"> | string
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    vendorId?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringWithAggregatesFilter<"AuditLog"> | string
    oldValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type SupportTicketWhereInput = {
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    vendorId?: StringFilter<"SupportTicket"> | string
    vendorName?: StringFilter<"SupportTicket"> | string
    subject?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: EnumTicketStatusFilter<"SupportTicket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"SupportTicket"> | $Enums.TicketPriority
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }

  export type SupportTicketOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type SupportTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    vendorId?: StringFilter<"SupportTicket"> | string
    vendorName?: StringFilter<"SupportTicket"> | string
    subject?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: EnumTicketStatusFilter<"SupportTicket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"SupportTicket"> | $Enums.TicketPriority
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }, "id">

  export type SupportTicketOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupportTicketCountOrderByAggregateInput
    _max?: SupportTicketMaxOrderByAggregateInput
    _min?: SupportTicketMinOrderByAggregateInput
  }

  export type SupportTicketScalarWhereWithAggregatesInput = {
    AND?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    OR?: SupportTicketScalarWhereWithAggregatesInput[]
    NOT?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupportTicket"> | string
    vendorId?: StringWithAggregatesFilter<"SupportTicket"> | string
    vendorName?: StringWithAggregatesFilter<"SupportTicket"> | string
    subject?: StringWithAggregatesFilter<"SupportTicket"> | string
    description?: StringWithAggregatesFilter<"SupportTicket"> | string
    status?: EnumTicketStatusWithAggregatesFilter<"SupportTicket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityWithAggregatesFilter<"SupportTicket"> | $Enums.TicketPriority
    createdAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    vendorId?: StringFilter<"Report"> | string
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    period?: EnumReportPeriodFilter<"Report"> | $Enums.ReportPeriod
    startDate?: DateTimeFilter<"Report"> | Date | string
    endDate?: DateTimeFilter<"Report"> | Date | string
    data?: JsonFilter<"Report">
    generatedBy?: StringFilter<"Report"> | string
    generatedAt?: DateTimeFilter<"Report"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    generator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    data?: SortOrder
    generatedBy?: SortOrder
    generatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    generator?: UserOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    vendorId?: StringFilter<"Report"> | string
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    period?: EnumReportPeriodFilter<"Report"> | $Enums.ReportPeriod
    startDate?: DateTimeFilter<"Report"> | Date | string
    endDate?: DateTimeFilter<"Report"> | Date | string
    data?: JsonFilter<"Report">
    generatedBy?: StringFilter<"Report"> | string
    generatedAt?: DateTimeFilter<"Report"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    generator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    data?: SortOrder
    generatedBy?: SortOrder
    generatedAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    vendorId?: StringWithAggregatesFilter<"Report"> | string
    type?: EnumReportTypeWithAggregatesFilter<"Report"> | $Enums.ReportType
    period?: EnumReportPeriodWithAggregatesFilter<"Report"> | $Enums.ReportPeriod
    startDate?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    data?: JsonWithAggregatesFilter<"Report">
    generatedBy?: StringWithAggregatesFilter<"Report"> | string
    generatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type PricingPlanWhereInput = {
    AND?: PricingPlanWhereInput | PricingPlanWhereInput[]
    OR?: PricingPlanWhereInput[]
    NOT?: PricingPlanWhereInput | PricingPlanWhereInput[]
    id?: StringFilter<"PricingPlan"> | string
    name?: StringFilter<"PricingPlan"> | string
    price?: DecimalFilter<"PricingPlan"> | Decimal | DecimalJsLike | number | string
    duration?: IntFilter<"PricingPlan"> | number
    features?: JsonFilter<"PricingPlan">
    isActive?: BoolFilter<"PricingPlan"> | boolean
    createdAt?: DateTimeFilter<"PricingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"PricingPlan"> | Date | string
  }

  export type PricingPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    features?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PricingPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PricingPlanWhereInput | PricingPlanWhereInput[]
    OR?: PricingPlanWhereInput[]
    NOT?: PricingPlanWhereInput | PricingPlanWhereInput[]
    name?: StringFilter<"PricingPlan"> | string
    price?: DecimalFilter<"PricingPlan"> | Decimal | DecimalJsLike | number | string
    duration?: IntFilter<"PricingPlan"> | number
    features?: JsonFilter<"PricingPlan">
    isActive?: BoolFilter<"PricingPlan"> | boolean
    createdAt?: DateTimeFilter<"PricingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"PricingPlan"> | Date | string
  }, "id">

  export type PricingPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    features?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PricingPlanCountOrderByAggregateInput
    _avg?: PricingPlanAvgOrderByAggregateInput
    _max?: PricingPlanMaxOrderByAggregateInput
    _min?: PricingPlanMinOrderByAggregateInput
    _sum?: PricingPlanSumOrderByAggregateInput
  }

  export type PricingPlanScalarWhereWithAggregatesInput = {
    AND?: PricingPlanScalarWhereWithAggregatesInput | PricingPlanScalarWhereWithAggregatesInput[]
    OR?: PricingPlanScalarWhereWithAggregatesInput[]
    NOT?: PricingPlanScalarWhereWithAggregatesInput | PricingPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PricingPlan"> | string
    name?: StringWithAggregatesFilter<"PricingPlan"> | string
    price?: DecimalWithAggregatesFilter<"PricingPlan"> | Decimal | DecimalJsLike | number | string
    duration?: IntWithAggregatesFilter<"PricingPlan"> | number
    features?: JsonWithAggregatesFilter<"PricingPlan">
    isActive?: BoolWithAggregatesFilter<"PricingPlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PricingPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PricingPlan"> | Date | string
  }

  export type SystemSettingsWhereInput = {
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    id?: StringFilter<"SystemSettings"> | string
    settingKey?: StringFilter<"SystemSettings"> | string
    settingValue?: StringNullableFilter<"SystemSettings"> | string | null
    description?: StringNullableFilter<"SystemSettings"> | string | null
    createdAt?: DateTimeFilter<"SystemSettings"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
  }

  export type SystemSettingsOrderByWithRelationInput = {
    id?: SortOrder
    settingKey?: SortOrder
    settingValue?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    settingKey?: string
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    settingValue?: StringNullableFilter<"SystemSettings"> | string | null
    description?: StringNullableFilter<"SystemSettings"> | string | null
    createdAt?: DateTimeFilter<"SystemSettings"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
  }, "id" | "settingKey">

  export type SystemSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    settingKey?: SortOrder
    settingValue?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingsCountOrderByAggregateInput
    _max?: SystemSettingsMaxOrderByAggregateInput
    _min?: SystemSettingsMinOrderByAggregateInput
  }

  export type SystemSettingsScalarWhereWithAggregatesInput = {
    AND?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    OR?: SystemSettingsScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSettings"> | string
    settingKey?: StringWithAggregatesFilter<"SystemSettings"> | string
    settingValue?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    description?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSettings"> | Date | string
  }

  export type VendorCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutVendorInput
    products?: ProductCreateNestedManyWithoutVendorInput
    customers?: CustomerCreateNestedManyWithoutVendorInput
    sales?: SaleCreateNestedManyWithoutVendorInput
    suppliers?: SupplierCreateNestedManyWithoutVendorInput
    purchases?: PurchaseCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeCreateNestedManyWithoutVendorInput
    notifications?: NotificationCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketCreateNestedManyWithoutVendorInput
    reports?: ReportCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    customers?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    sales?: SaleUncheckedCreateNestedManyWithoutVendorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutVendorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutVendorInput
    reports?: ReportUncheckedCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutVendorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
    customers?: CustomerUpdateManyWithoutVendorNestedInput
    sales?: SaleUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutVendorNestedInput
    reports?: ReportUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutVendorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutVendorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorSettingsCreateInput = {
    id?: string
    taxRate?: Decimal | DecimalJsLike | number | string
    currency?: string
    timezone?: string
    receiptHeader?: string | null
    receiptFooter?: string | null
    loyaltyEnabled?: boolean
    loyaltyPointsPerDollar?: Decimal | DecimalJsLike | number | string
    loyaltyRedemptionRate?: Decimal | DecimalJsLike | number | string
    loyaltyMinimumPoints?: number
    lowStockAlert?: boolean
    lowStockThreshold?: number
    emailNotifications?: boolean
    smsNotifications?: boolean
    dailyReports?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutVendorSettingsInput
  }

  export type VendorSettingsUncheckedCreateInput = {
    id?: string
    vendorId: string
    taxRate?: Decimal | DecimalJsLike | number | string
    currency?: string
    timezone?: string
    receiptHeader?: string | null
    receiptFooter?: string | null
    loyaltyEnabled?: boolean
    loyaltyPointsPerDollar?: Decimal | DecimalJsLike | number | string
    loyaltyRedemptionRate?: Decimal | DecimalJsLike | number | string
    loyaltyMinimumPoints?: number
    lowStockAlert?: boolean
    lowStockThreshold?: number
    emailNotifications?: boolean
    smsNotifications?: boolean
    dailyReports?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    receiptHeader?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFooter?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyEnabled?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPointsPerDollar?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyRedemptionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyMinimumPoints?: IntFieldUpdateOperationsInput | number
    lowStockAlert?: BoolFieldUpdateOperationsInput | boolean
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    dailyReports?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutVendorSettingsNestedInput
  }

  export type VendorSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    receiptHeader?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFooter?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyEnabled?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPointsPerDollar?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyRedemptionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyMinimumPoints?: IntFieldUpdateOperationsInput | number
    lowStockAlert?: BoolFieldUpdateOperationsInput | boolean
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    dailyReports?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorSettingsCreateManyInput = {
    id?: string
    vendorId: string
    taxRate?: Decimal | DecimalJsLike | number | string
    currency?: string
    timezone?: string
    receiptHeader?: string | null
    receiptFooter?: string | null
    loyaltyEnabled?: boolean
    loyaltyPointsPerDollar?: Decimal | DecimalJsLike | number | string
    loyaltyRedemptionRate?: Decimal | DecimalJsLike | number | string
    loyaltyMinimumPoints?: number
    lowStockAlert?: boolean
    lowStockThreshold?: number
    emailNotifications?: boolean
    smsNotifications?: boolean
    dailyReports?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    receiptHeader?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFooter?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyEnabled?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPointsPerDollar?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyRedemptionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyMinimumPoints?: IntFieldUpdateOperationsInput | number
    lowStockAlert?: BoolFieldUpdateOperationsInput | boolean
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    dailyReports?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    receiptHeader?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFooter?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyEnabled?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPointsPerDollar?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyRedemptionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyMinimumPoints?: IntFieldUpdateOperationsInput | number
    lowStockAlert?: BoolFieldUpdateOperationsInput | boolean
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    dailyReports?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutUsersInput
    cashierSchedule?: CashierScheduleCreateNestedOneWithoutUserInput
    sales?: SaleCreateNestedManyWithoutCashierInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    stockTakes?: StockTakeCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratorInput
    productAssignments?: CashierProductAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    vendorId?: string | null
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashierSchedule?: CashierScheduleUncheckedCreateNestedOneWithoutUserInput
    sales?: SaleUncheckedCreateNestedManyWithoutCashierInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratorInput
    productAssignments?: CashierProductAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutUsersNestedInput
    cashierSchedule?: CashierScheduleUpdateOneWithoutUserNestedInput
    sales?: SaleUpdateManyWithoutCashierNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratorNestedInput
    productAssignments?: CashierProductAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashierSchedule?: CashierScheduleUncheckedUpdateOneWithoutUserNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCashierNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratorNestedInput
    productAssignments?: CashierProductAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    vendorId?: string | null
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierScheduleCreateInput = {
    id?: string
    checkInTime: string
    checkOutTime: string
    workDays: JsonNullValueInput | InputJsonValue
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCashierScheduleInput
  }

  export type CashierScheduleUncheckedCreateInput = {
    id?: string
    userId: string
    checkInTime: string
    checkOutTime: string
    workDays: JsonNullValueInput | InputJsonValue
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashierScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    workDays?: JsonNullValueInput | InputJsonValue
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCashierScheduleNestedInput
  }

  export type CashierScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    workDays?: JsonNullValueInput | InputJsonValue
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierScheduleCreateManyInput = {
    id?: string
    userId: string
    checkInTime: string
    checkOutTime: string
    workDays: JsonNullValueInput | InputJsonValue
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashierScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    workDays?: JsonNullValueInput | InputJsonValue
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    workDays?: JsonNullValueInput | InputJsonValue
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutProductsInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
    stockLocations?: ProductStockLocationCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    stockTakeItems?: StockTakeItemCreateNestedManyWithoutProductInput
    cashierAssignments?: CashierProductAssignmentCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    vendorId: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    stockLocations?: ProductStockLocationUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    stockTakeItems?: StockTakeItemUncheckedCreateNestedManyWithoutProductInput
    cashierAssignments?: CashierProductAssignmentUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutProductsNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
    stockLocations?: ProductStockLocationUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    stockTakeItems?: StockTakeItemUpdateManyWithoutProductNestedInput
    cashierAssignments?: CashierProductAssignmentUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    stockLocations?: ProductStockLocationUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    stockTakeItems?: StockTakeItemUncheckedUpdateManyWithoutProductNestedInput
    cashierAssignments?: CashierProductAssignmentUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    vendorId: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantCreateInput = {
    id?: string
    name: string
    value: string
    priceModifier?: Decimal | DecimalJsLike | number | string
    stock?: number
    sku: string
    barcode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    stockLocations?: ProductStockLocationCreateNestedManyWithoutVariantInput
    saleItems?: SaleItemCreateNestedManyWithoutVariantInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutVariantInput
    stockMovements?: StockMovementCreateNestedManyWithoutVariantInput
    stockTakeItems?: StockTakeItemCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateInput = {
    id?: string
    productId: string
    name: string
    value: string
    priceModifier?: Decimal | DecimalJsLike | number | string
    stock?: number
    sku: string
    barcode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockLocations?: ProductStockLocationUncheckedCreateNestedManyWithoutVariantInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutVariantInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutVariantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVariantInput
    stockTakeItems?: StockTakeItemUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priceModifier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    stockLocations?: ProductStockLocationUpdateManyWithoutVariantNestedInput
    saleItems?: SaleItemUpdateManyWithoutVariantNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutVariantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVariantNestedInput
    stockTakeItems?: StockTakeItemUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priceModifier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockLocations?: ProductStockLocationUncheckedUpdateManyWithoutVariantNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutVariantNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutVariantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVariantNestedInput
    stockTakeItems?: StockTakeItemUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantCreateManyInput = {
    id?: string
    productId: string
    name: string
    value: string
    priceModifier?: Decimal | DecimalJsLike | number | string
    stock?: number
    sku: string
    barcode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priceModifier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priceModifier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockLocationCreateInput = {
    id?: string
    locationName: string
    quantity?: number
    reservedQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutStockLocationsInput
    variant?: ProductVariantCreateNestedOneWithoutStockLocationsInput
  }

  export type ProductStockLocationUncheckedCreateInput = {
    id?: string
    productId: string
    variantId?: string | null
    locationName: string
    quantity?: number
    reservedQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductStockLocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockLocationsNestedInput
    variant?: ProductVariantUpdateOneWithoutStockLocationsNestedInput
  }

  export type ProductStockLocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockLocationCreateManyInput = {
    id?: string
    productId: string
    variantId?: string | null
    locationName: string
    quantity?: number
    reservedQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductStockLocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockLocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierProductAssignmentCreateInput = {
    id?: string
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutProductAssignmentsInput
    product: ProductCreateNestedOneWithoutCashierAssignmentsInput
  }

  export type CashierProductAssignmentUncheckedCreateInput = {
    id?: string
    userId: string
    productId: string
    assignedAt?: Date | string
  }

  export type CashierProductAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProductAssignmentsNestedInput
    product?: ProductUpdateOneRequiredWithoutCashierAssignmentsNestedInput
  }

  export type CashierProductAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierProductAssignmentCreateManyInput = {
    id?: string
    userId: string
    productId: string
    assignedAt?: Date | string
  }

  export type CashierProductAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierProductAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    visitCount?: number
    lastVisit?: Date | string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutCustomersInput
    sales?: SaleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    vendorId: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    visitCount?: number
    lastVisit?: Date | string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    visitCount?: IntFieldUpdateOperationsInput | number
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutCustomersNestedInput
    sales?: SaleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    visitCount?: IntFieldUpdateOperationsInput | number
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    vendorId: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    visitCount?: number
    lastVisit?: Date | string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    visitCount?: IntFieldUpdateOperationsInput | number
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    visitCount?: IntFieldUpdateOperationsInput | number
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateInput = {
    id?: string
    terminalId: string
    receiptNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paid: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.SaleStatus
    refundAmount?: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsUsed?: number
    notes?: string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutSalesInput
    cashier: UserCreateNestedOneWithoutSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateInput = {
    id?: string
    vendorId: string
    cashierId: string
    terminalId: string
    customerId?: string | null
    receiptNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paid: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.SaleStatus
    refundAmount?: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsUsed?: number
    notes?: string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsUsed?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutSalesNestedInput
    cashier?: UserUpdateOneRequiredWithoutSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsUsed?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleCreateManyInput = {
    id?: string
    vendorId: string
    cashierId: string
    terminalId: string
    customerId?: string | null
    receiptNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paid: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.SaleStatus
    refundAmount?: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsUsed?: number
    notes?: string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsUsed?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsUsed?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemCreateInput = {
    id?: string
    name: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    sale: SaleCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutSaleItemsInput
    variant?: ProductVariantCreateNestedOneWithoutSaleItemsInput
  }

  export type SaleItemUncheckedCreateInput = {
    id?: string
    saleId: string
    productId: string
    variantId?: string | null
    name: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutSaleItemsNestedInput
    variant?: ProductVariantUpdateOneWithoutSaleItemsNestedInput
  }

  export type SaleItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemCreateManyInput = {
    id?: string
    saleId: string
    productId: string
    variantId?: string | null
    name: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    paymentTerms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutSuppliersInput
    purchases?: PurchaseCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    vendorId: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    paymentTerms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchaseUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutSuppliersNestedInput
    purchases?: PurchaseUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: string
    vendorId: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    paymentTerms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateInput = {
    id?: string
    purchaseNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchasesInput
    supplier: SupplierCreateNestedOneWithoutPurchasesInput
    items?: PurchaseItemCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: string
    vendorId: string
    supplierId: string
    purchaseNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchasesNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchasesNestedInput
    items?: PurchaseItemUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseCreateManyInput = {
    id?: string
    vendorId: string
    supplierId: string
    purchaseNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemCreateInput = {
    id?: string
    name: string
    sku: string
    costPrice: Decimal | DecimalJsLike | number | string
    quantity: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutPurchaseItemsInput
    variant?: ProductVariantCreateNestedOneWithoutPurchaseItemsInput
  }

  export type PurchaseItemUncheckedCreateInput = {
    id?: string
    purchaseId: string
    productId: string
    variantId?: string | null
    name: string
    sku: string
    costPrice: Decimal | DecimalJsLike | number | string
    quantity: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PurchaseItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchaseItemsNestedInput
    variant?: ProductVariantUpdateOneWithoutPurchaseItemsNestedInput
  }

  export type PurchaseItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemCreateManyInput = {
    id?: string
    purchaseId: string
    productId: string
    variantId?: string | null
    name: string
    sku: string
    costPrice: Decimal | DecimalJsLike | number | string
    quantity: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PurchaseItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementCreateInput = {
    id?: string
    movementType: $Enums.StockMovementType
    quantity: number
    referenceType?: string | null
    referenceId?: string | null
    referenceNumber?: string | null
    locationFrom?: string | null
    locationTo?: string | null
    notes?: string | null
    createdAt?: Date | string
    vendor: VendorCreateNestedOneWithoutStockMovementsInput
    product: ProductCreateNestedOneWithoutStockMovementsInput
    variant?: ProductVariantCreateNestedOneWithoutStockMovementsInput
    creator: UserCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateInput = {
    id?: string
    vendorId: string
    productId: string
    variantId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    referenceType?: string | null
    referenceId?: string | null
    referenceNumber?: string | null
    locationFrom?: string | null
    locationTo?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type StockMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    locationFrom?: NullableStringFieldUpdateOperationsInput | string | null
    locationTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutStockMovementsNestedInput
    product?: ProductUpdateOneRequiredWithoutStockMovementsNestedInput
    variant?: ProductVariantUpdateOneWithoutStockMovementsNestedInput
    creator?: UserUpdateOneRequiredWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    locationFrom?: NullableStringFieldUpdateOperationsInput | string | null
    locationTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementCreateManyInput = {
    id?: string
    vendorId: string
    productId: string
    variantId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    referenceType?: string | null
    referenceId?: string | null
    referenceNumber?: string | null
    locationFrom?: string | null
    locationTo?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type StockMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    locationFrom?: NullableStringFieldUpdateOperationsInput | string | null
    locationTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    locationFrom?: NullableStringFieldUpdateOperationsInput | string | null
    locationTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTakeCreateInput = {
    id?: string
    location: string
    status?: $Enums.StockTakeStatus
    notes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutStockTakesInput
    creator: UserCreateNestedOneWithoutStockTakesInput
    items?: StockTakeItemCreateNestedManyWithoutStockTakeInput
  }

  export type StockTakeUncheckedCreateInput = {
    id?: string
    vendorId: string
    location: string
    status?: $Enums.StockTakeStatus
    notes?: string | null
    createdBy: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: StockTakeItemUncheckedCreateNestedManyWithoutStockTakeInput
  }

  export type StockTakeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStockTakeStatusFieldUpdateOperationsInput | $Enums.StockTakeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutStockTakesNestedInput
    creator?: UserUpdateOneRequiredWithoutStockTakesNestedInput
    items?: StockTakeItemUpdateManyWithoutStockTakeNestedInput
  }

  export type StockTakeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStockTakeStatusFieldUpdateOperationsInput | $Enums.StockTakeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: StockTakeItemUncheckedUpdateManyWithoutStockTakeNestedInput
  }

  export type StockTakeCreateManyInput = {
    id?: string
    vendorId: string
    location: string
    status?: $Enums.StockTakeStatus
    notes?: string | null
    createdBy: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTakeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStockTakeStatusFieldUpdateOperationsInput | $Enums.StockTakeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTakeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStockTakeStatusFieldUpdateOperationsInput | $Enums.StockTakeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTakeItemCreateInput = {
    id?: string
    productName: string
    sku: string
    expectedQuantity: number
    countedQuantity: number
    notes?: string | null
    createdAt?: Date | string
    stockTake: StockTakeCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutStockTakeItemsInput
    variant?: ProductVariantCreateNestedOneWithoutStockTakeItemsInput
  }

  export type StockTakeItemUncheckedCreateInput = {
    id?: string
    stockTakeId: string
    productId: string
    variantId?: string | null
    productName: string
    sku: string
    expectedQuantity: number
    countedQuantity: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type StockTakeItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockTake?: StockTakeUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutStockTakeItemsNestedInput
    variant?: ProductVariantUpdateOneWithoutStockTakeItemsNestedInput
  }

  export type StockTakeItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockTakeId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTakeItemCreateManyInput = {
    id?: string
    stockTakeId: string
    productId: string
    variantId?: string | null
    productName: string
    sku: string
    expectedQuantity: number
    countedQuantity: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type StockTakeItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTakeItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockTakeId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
    vendor: VendorCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    vendorId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    vendorId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    resource: string
    resourceId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    vendor: VendorCreateNestedOneWithoutAuditLogsInput
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    vendorId: string
    userId: string
    action: string
    resource: string
    resourceId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutAuditLogsNestedInput
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    vendorId: string
    userId: string
    action: string
    resource: string
    resourceId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketCreateInput = {
    id?: string
    vendorName: string
    subject: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutSupportTicketsInput
  }

  export type SupportTicketUncheckedCreateInput = {
    id?: string
    vendorId: string
    vendorName: string
    subject: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorName?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutSupportTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    vendorName?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketCreateManyInput = {
    id?: string
    vendorId: string
    vendorName: string
    subject: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorName?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    vendorName?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    type: $Enums.ReportType
    period: $Enums.ReportPeriod
    startDate: Date | string
    endDate: Date | string
    data: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutReportsInput
    generator: UserCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    vendorId: string
    type: $Enums.ReportType
    period: $Enums.ReportPeriod
    startDate: Date | string
    endDate: Date | string
    data: JsonNullValueInput | InputJsonValue
    generatedBy: string
    generatedAt?: Date | string
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    period?: EnumReportPeriodFieldUpdateOperationsInput | $Enums.ReportPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutReportsNestedInput
    generator?: UserUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    period?: EnumReportPeriodFieldUpdateOperationsInput | $Enums.ReportPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    generatedBy?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: string
    vendorId: string
    type: $Enums.ReportType
    period: $Enums.ReportPeriod
    startDate: Date | string
    endDate: Date | string
    data: JsonNullValueInput | InputJsonValue
    generatedBy: string
    generatedAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    period?: EnumReportPeriodFieldUpdateOperationsInput | $Enums.ReportPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    period?: EnumReportPeriodFieldUpdateOperationsInput | $Enums.ReportPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    generatedBy?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingPlanCreateInput = {
    id?: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration: number
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricingPlanUncheckedCreateInput = {
    id?: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration: number
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricingPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingPlanCreateManyInput = {
    id?: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration: number
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricingPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateInput = {
    id?: string
    settingKey: string
    settingValue?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingsUncheckedCreateInput = {
    id?: string
    settingKey: string
    settingValue?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    settingKey?: StringFieldUpdateOperationsInput | string
    settingValue?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    settingKey?: StringFieldUpdateOperationsInput | string
    settingValue?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateManyInput = {
    id?: string
    settingKey: string
    settingValue?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    settingKey?: StringFieldUpdateOperationsInput | string
    settingValue?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    settingKey?: StringFieldUpdateOperationsInput | string
    settingValue?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[]
    notIn?: $Enums.SubscriptionStatus[]
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type SaleListRelationFilter = {
    every?: SaleWhereInput
    some?: SaleWhereInput
    none?: SaleWhereInput
  }

  export type SupplierListRelationFilter = {
    every?: SupplierWhereInput
    some?: SupplierWhereInput
    none?: SupplierWhereInput
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type StockMovementListRelationFilter = {
    every?: StockMovementWhereInput
    some?: StockMovementWhereInput
    none?: StockMovementWhereInput
  }

  export type StockTakeListRelationFilter = {
    every?: StockTakeWhereInput
    some?: StockTakeWhereInput
    none?: StockTakeWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SupportTicketListRelationFilter = {
    every?: SupportTicketWhereInput
    some?: SupportTicketWhereInput
    none?: SupportTicketWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type VendorSettingsNullableRelationFilter = {
    is?: VendorSettingsWhereInput | null
    isNot?: VendorSettingsWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockTakeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    businessType?: SortOrder
    subscriptionPlan?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionExpiry?: SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    businessType?: SortOrder
    subscriptionPlan?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionExpiry?: SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    businessType?: SortOrder
    subscriptionPlan?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionExpiry?: SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[]
    notIn?: $Enums.SubscriptionStatus[]
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type VendorRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type VendorSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    taxRate?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    receiptHeader?: SortOrder
    receiptFooter?: SortOrder
    loyaltyEnabled?: SortOrder
    loyaltyPointsPerDollar?: SortOrder
    loyaltyRedemptionRate?: SortOrder
    loyaltyMinimumPoints?: SortOrder
    lowStockAlert?: SortOrder
    lowStockThreshold?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    dailyReports?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorSettingsAvgOrderByAggregateInput = {
    taxRate?: SortOrder
    loyaltyPointsPerDollar?: SortOrder
    loyaltyRedemptionRate?: SortOrder
    loyaltyMinimumPoints?: SortOrder
    lowStockThreshold?: SortOrder
  }

  export type VendorSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    taxRate?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    receiptHeader?: SortOrder
    receiptFooter?: SortOrder
    loyaltyEnabled?: SortOrder
    loyaltyPointsPerDollar?: SortOrder
    loyaltyRedemptionRate?: SortOrder
    loyaltyMinimumPoints?: SortOrder
    lowStockAlert?: SortOrder
    lowStockThreshold?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    dailyReports?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    taxRate?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    receiptHeader?: SortOrder
    receiptFooter?: SortOrder
    loyaltyEnabled?: SortOrder
    loyaltyPointsPerDollar?: SortOrder
    loyaltyRedemptionRate?: SortOrder
    loyaltyMinimumPoints?: SortOrder
    lowStockAlert?: SortOrder
    lowStockThreshold?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    dailyReports?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorSettingsSumOrderByAggregateInput = {
    taxRate?: SortOrder
    loyaltyPointsPerDollar?: SortOrder
    loyaltyRedemptionRate?: SortOrder
    loyaltyMinimumPoints?: SortOrder
    lowStockThreshold?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type VendorNullableRelationFilter = {
    is?: VendorWhereInput | null
    isNot?: VendorWhereInput | null
  }

  export type CashierScheduleNullableRelationFilter = {
    is?: CashierScheduleWhereInput | null
    isNot?: CashierScheduleWhereInput | null
  }

  export type CashierProductAssignmentListRelationFilter = {
    every?: CashierProductAssignmentWhereInput
    some?: CashierProductAssignmentWhereInput
    none?: CashierProductAssignmentWhereInput
  }

  export type CashierProductAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    terminalId?: SortOrder
    assignedLocations?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    terminalId?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    terminalId?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CashierScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    workDays?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashierScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashierScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ProductVariantListRelationFilter = {
    every?: ProductVariantWhereInput
    some?: ProductVariantWhereInput
    none?: ProductVariantWhereInput
  }

  export type ProductStockLocationListRelationFilter = {
    every?: ProductStockLocationWhereInput
    some?: ProductStockLocationWhereInput
    none?: ProductStockLocationWhereInput
  }

  export type SaleItemListRelationFilter = {
    every?: SaleItemWhereInput
    some?: SaleItemWhereInput
    none?: SaleItemWhereInput
  }

  export type PurchaseItemListRelationFilter = {
    every?: PurchaseItemWhereInput
    some?: PurchaseItemWhereInput
    none?: PurchaseItemWhereInput
  }

  export type StockTakeItemListRelationFilter = {
    every?: StockTakeItemWhereInput
    some?: StockTakeItemWhereInput
    none?: StockTakeItemWhereInput
  }

  export type ProductVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductStockLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockTakeItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductVendorIdSkuCompoundUniqueInput = {
    vendorId: string
    sku: string
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    category?: SortOrder
    brand?: SortOrder
    price?: SortOrder
    costPrice?: SortOrder
    totalStock?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    unit?: SortOrder
    images?: SortOrder
    isActive?: SortOrder
    expiryDate?: SortOrder
    trackExpiry?: SortOrder
    trackSerial?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    costPrice?: SortOrder
    totalStock?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    category?: SortOrder
    brand?: SortOrder
    price?: SortOrder
    costPrice?: SortOrder
    totalStock?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    unit?: SortOrder
    isActive?: SortOrder
    expiryDate?: SortOrder
    trackExpiry?: SortOrder
    trackSerial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    category?: SortOrder
    brand?: SortOrder
    price?: SortOrder
    costPrice?: SortOrder
    totalStock?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    unit?: SortOrder
    isActive?: SortOrder
    expiryDate?: SortOrder
    trackExpiry?: SortOrder
    trackSerial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    costPrice?: SortOrder
    totalStock?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductVariantProductIdSkuCompoundUniqueInput = {
    productId: string
    sku: string
  }

  export type ProductVariantCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    priceModifier?: SortOrder
    stock?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantAvgOrderByAggregateInput = {
    priceModifier?: SortOrder
    stock?: SortOrder
  }

  export type ProductVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    priceModifier?: SortOrder
    stock?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    priceModifier?: SortOrder
    stock?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantSumOrderByAggregateInput = {
    priceModifier?: SortOrder
    stock?: SortOrder
  }

  export type ProductVariantNullableRelationFilter = {
    is?: ProductVariantWhereInput | null
    isNot?: ProductVariantWhereInput | null
  }

  export type ProductStockLocationProductIdVariantIdLocationNameCompoundUniqueInput = {
    productId: string
    variantId: string
    locationName: string
  }

  export type ProductStockLocationCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    locationName?: SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductStockLocationAvgOrderByAggregateInput = {
    quantity?: SortOrder
    reservedQuantity?: SortOrder
  }

  export type ProductStockLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    locationName?: SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductStockLocationMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    locationName?: SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductStockLocationSumOrderByAggregateInput = {
    quantity?: SortOrder
    reservedQuantity?: SortOrder
  }

  export type CashierProductAssignmentUserIdProductIdCompoundUniqueInput = {
    userId: string
    productId: string
  }

  export type CashierProductAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    assignedAt?: SortOrder
  }

  export type CashierProductAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    assignedAt?: SortOrder
  }

  export type CashierProductAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    assignedAt?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    dateOfBirth?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    visitCount?: SortOrder
    lastVisit?: SortOrder
    isActive?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    visitCount?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    dateOfBirth?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    visitCount?: SortOrder
    lastVisit?: SortOrder
    isActive?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    dateOfBirth?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    visitCount?: SortOrder
    lastVisit?: SortOrder
    isActive?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    visitCount?: SortOrder
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumSaleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SaleStatus | EnumSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SaleStatus[]
    notIn?: $Enums.SaleStatus[]
    not?: NestedEnumSaleStatusFilter<$PrismaModel> | $Enums.SaleStatus
  }

  export type CustomerNullableRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type SaleVendorIdReceiptNumberCompoundUniqueInput = {
    vendorId: string
    receiptNumber: string
  }

  export type SaleCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    cashierId?: SortOrder
    terminalId?: SortOrder
    customerId?: SortOrder
    receiptNumber?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paid?: SortOrder
    changeAmount?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    refundAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    loyaltyPointsUsed?: SortOrder
    notes?: SortOrder
    receiptData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paid?: SortOrder
    changeAmount?: SortOrder
    refundAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    loyaltyPointsUsed?: SortOrder
  }

  export type SaleMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    cashierId?: SortOrder
    terminalId?: SortOrder
    customerId?: SortOrder
    receiptNumber?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paid?: SortOrder
    changeAmount?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    refundAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    loyaltyPointsUsed?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    cashierId?: SortOrder
    terminalId?: SortOrder
    customerId?: SortOrder
    receiptNumber?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paid?: SortOrder
    changeAmount?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    refundAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    loyaltyPointsUsed?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paid?: SortOrder
    changeAmount?: SortOrder
    refundAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    loyaltyPointsUsed?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumSaleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SaleStatus | EnumSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SaleStatus[]
    notIn?: $Enums.SaleStatus[]
    not?: NestedEnumSaleStatusWithAggregatesFilter<$PrismaModel> | $Enums.SaleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSaleStatusFilter<$PrismaModel>
    _max?: NestedEnumSaleStatusFilter<$PrismaModel>
  }

  export type SaleRelationFilter = {
    is?: SaleWhereInput
    isNot?: SaleWhereInput
  }

  export type SaleItemCountOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleItemAvgOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    total?: SortOrder
  }

  export type SaleItemMaxOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleItemMinOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleItemSumOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    total?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    paymentTerms?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    paymentTerms?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    paymentTerms?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPurchaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[]
    notIn?: $Enums.PurchaseStatus[]
    not?: NestedEnumPurchaseStatusFilter<$PrismaModel> | $Enums.PurchaseStatus
  }

  export type SupplierRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type PurchaseVendorIdPurchaseNumberCompoundUniqueInput = {
    vendorId: string
    purchaseNumber: string
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    supplierId?: SortOrder
    purchaseNumber?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    deliveryDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    supplierId?: SortOrder
    purchaseNumber?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    deliveryDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    supplierId?: SortOrder
    purchaseNumber?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    deliveryDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }

  export type EnumPurchaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[]
    notIn?: $Enums.PurchaseStatus[]
    not?: NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseStatusFilter<$PrismaModel>
  }

  export type PurchaseRelationFilter = {
    is?: PurchaseWhereInput
    isNot?: PurchaseWhereInput
  }

  export type PurchaseItemCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    costPrice?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseItemAvgOrderByAggregateInput = {
    costPrice?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
  }

  export type PurchaseItemMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    costPrice?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseItemMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    costPrice?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseItemSumOrderByAggregateInput = {
    costPrice?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
  }

  export type EnumStockMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StockMovementType | EnumStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockMovementType[]
    notIn?: $Enums.StockMovementType[]
    not?: NestedEnumStockMovementTypeFilter<$PrismaModel> | $Enums.StockMovementType
  }

  export type StockMovementCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrder
    referenceNumber?: SortOrder
    locationFrom?: SortOrder
    locationTo?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StockMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrder
    referenceNumber?: SortOrder
    locationFrom?: SortOrder
    locationTo?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrder
    referenceNumber?: SortOrder
    locationFrom?: SortOrder
    locationTo?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumStockMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockMovementType | EnumStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockMovementType[]
    notIn?: $Enums.StockMovementType[]
    not?: NestedEnumStockMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.StockMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumStockMovementTypeFilter<$PrismaModel>
  }

  export type EnumStockTakeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StockTakeStatus | EnumStockTakeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StockTakeStatus[]
    notIn?: $Enums.StockTakeStatus[]
    not?: NestedEnumStockTakeStatusFilter<$PrismaModel> | $Enums.StockTakeStatus
  }

  export type StockTakeCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    location?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockTakeMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    location?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockTakeMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    location?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStockTakeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockTakeStatus | EnumStockTakeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StockTakeStatus[]
    notIn?: $Enums.StockTakeStatus[]
    not?: NestedEnumStockTakeStatusWithAggregatesFilter<$PrismaModel> | $Enums.StockTakeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockTakeStatusFilter<$PrismaModel>
    _max?: NestedEnumStockTakeStatusFilter<$PrismaModel>
  }

  export type StockTakeRelationFilter = {
    is?: StockTakeWhereInput
    isNot?: StockTakeWhereInput
  }

  export type StockTakeItemCountOrderByAggregateInput = {
    id?: SortOrder
    stockTakeId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    productName?: SortOrder
    sku?: SortOrder
    expectedQuantity?: SortOrder
    countedQuantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type StockTakeItemAvgOrderByAggregateInput = {
    expectedQuantity?: SortOrder
    countedQuantity?: SortOrder
  }

  export type StockTakeItemMaxOrderByAggregateInput = {
    id?: SortOrder
    stockTakeId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    productName?: SortOrder
    sku?: SortOrder
    expectedQuantity?: SortOrder
    countedQuantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type StockTakeItemMinOrderByAggregateInput = {
    id?: SortOrder
    stockTakeId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    productName?: SortOrder
    sku?: SortOrder
    expectedQuantity?: SortOrder
    countedQuantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type StockTakeItemSumOrderByAggregateInput = {
    expectedQuantity?: SortOrder
    countedQuantity?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[]
    notIn?: $Enums.TicketStatus[]
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type EnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[]
    notIn?: $Enums.TicketPriority[]
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type SupportTicketCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[]
    notIn?: $Enums.TicketStatus[]
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type EnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[]
    notIn?: $Enums.TicketPriority[]
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type EnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[]
    notIn?: $Enums.ReportType[]
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type EnumReportPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportPeriod | EnumReportPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.ReportPeriod[]
    notIn?: $Enums.ReportPeriod[]
    not?: NestedEnumReportPeriodFilter<$PrismaModel> | $Enums.ReportPeriod
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    data?: SortOrder
    generatedBy?: SortOrder
    generatedAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    generatedBy?: SortOrder
    generatedAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    generatedBy?: SortOrder
    generatedAt?: SortOrder
  }

  export type EnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[]
    notIn?: $Enums.ReportType[]
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type EnumReportPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportPeriod | EnumReportPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.ReportPeriod[]
    notIn?: $Enums.ReportPeriod[]
    not?: NestedEnumReportPeriodWithAggregatesFilter<$PrismaModel> | $Enums.ReportPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportPeriodFilter<$PrismaModel>
    _max?: NestedEnumReportPeriodFilter<$PrismaModel>
  }

  export type PricingPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    features?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PricingPlanAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type PricingPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PricingPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PricingPlanSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type SystemSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    settingKey?: SortOrder
    settingValue?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    settingKey?: SortOrder
    settingValue?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    settingKey?: SortOrder
    settingValue?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreateNestedManyWithoutVendorInput = {
    create?: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput> | UserCreateWithoutVendorInput[] | UserUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutVendorInput | UserCreateOrConnectWithoutVendorInput[]
    createMany?: UserCreateManyVendorInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutVendorInput = {
    create?: XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput> | ProductCreateWithoutVendorInput[] | ProductUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutVendorInput | ProductCreateOrConnectWithoutVendorInput[]
    createMany?: ProductCreateManyVendorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutVendorInput = {
    create?: XOR<CustomerCreateWithoutVendorInput, CustomerUncheckedCreateWithoutVendorInput> | CustomerCreateWithoutVendorInput[] | CustomerUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutVendorInput | CustomerCreateOrConnectWithoutVendorInput[]
    createMany?: CustomerCreateManyVendorInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type SaleCreateNestedManyWithoutVendorInput = {
    create?: XOR<SaleCreateWithoutVendorInput, SaleUncheckedCreateWithoutVendorInput> | SaleCreateWithoutVendorInput[] | SaleUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutVendorInput | SaleCreateOrConnectWithoutVendorInput[]
    createMany?: SaleCreateManyVendorInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type SupplierCreateNestedManyWithoutVendorInput = {
    create?: XOR<SupplierCreateWithoutVendorInput, SupplierUncheckedCreateWithoutVendorInput> | SupplierCreateWithoutVendorInput[] | SupplierUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutVendorInput | SupplierCreateOrConnectWithoutVendorInput[]
    createMany?: SupplierCreateManyVendorInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseCreateWithoutVendorInput, PurchaseUncheckedCreateWithoutVendorInput> | PurchaseCreateWithoutVendorInput[] | PurchaseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutVendorInput | PurchaseCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseCreateManyVendorInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type StockMovementCreateNestedManyWithoutVendorInput = {
    create?: XOR<StockMovementCreateWithoutVendorInput, StockMovementUncheckedCreateWithoutVendorInput> | StockMovementCreateWithoutVendorInput[] | StockMovementUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutVendorInput | StockMovementCreateOrConnectWithoutVendorInput[]
    createMany?: StockMovementCreateManyVendorInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type StockTakeCreateNestedManyWithoutVendorInput = {
    create?: XOR<StockTakeCreateWithoutVendorInput, StockTakeUncheckedCreateWithoutVendorInput> | StockTakeCreateWithoutVendorInput[] | StockTakeUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: StockTakeCreateOrConnectWithoutVendorInput | StockTakeCreateOrConnectWithoutVendorInput[]
    createMany?: StockTakeCreateManyVendorInputEnvelope
    connect?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutVendorInput = {
    create?: XOR<NotificationCreateWithoutVendorInput, NotificationUncheckedCreateWithoutVendorInput> | NotificationCreateWithoutVendorInput[] | NotificationUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutVendorInput | NotificationCreateOrConnectWithoutVendorInput[]
    createMany?: NotificationCreateManyVendorInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutVendorInput = {
    create?: XOR<AuditLogCreateWithoutVendorInput, AuditLogUncheckedCreateWithoutVendorInput> | AuditLogCreateWithoutVendorInput[] | AuditLogUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutVendorInput | AuditLogCreateOrConnectWithoutVendorInput[]
    createMany?: AuditLogCreateManyVendorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutVendorInput = {
    create?: XOR<SupportTicketCreateWithoutVendorInput, SupportTicketUncheckedCreateWithoutVendorInput> | SupportTicketCreateWithoutVendorInput[] | SupportTicketUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutVendorInput | SupportTicketCreateOrConnectWithoutVendorInput[]
    createMany?: SupportTicketCreateManyVendorInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutVendorInput = {
    create?: XOR<ReportCreateWithoutVendorInput, ReportUncheckedCreateWithoutVendorInput> | ReportCreateWithoutVendorInput[] | ReportUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutVendorInput | ReportCreateOrConnectWithoutVendorInput[]
    createMany?: ReportCreateManyVendorInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type VendorSettingsCreateNestedOneWithoutVendorInput = {
    create?: XOR<VendorSettingsCreateWithoutVendorInput, VendorSettingsUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorSettingsCreateOrConnectWithoutVendorInput
    connect?: VendorSettingsWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput> | UserCreateWithoutVendorInput[] | UserUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutVendorInput | UserCreateOrConnectWithoutVendorInput[]
    createMany?: UserCreateManyVendorInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput> | ProductCreateWithoutVendorInput[] | ProductUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutVendorInput | ProductCreateOrConnectWithoutVendorInput[]
    createMany?: ProductCreateManyVendorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<CustomerCreateWithoutVendorInput, CustomerUncheckedCreateWithoutVendorInput> | CustomerCreateWithoutVendorInput[] | CustomerUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutVendorInput | CustomerCreateOrConnectWithoutVendorInput[]
    createMany?: CustomerCreateManyVendorInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<SaleCreateWithoutVendorInput, SaleUncheckedCreateWithoutVendorInput> | SaleCreateWithoutVendorInput[] | SaleUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutVendorInput | SaleCreateOrConnectWithoutVendorInput[]
    createMany?: SaleCreateManyVendorInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type SupplierUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<SupplierCreateWithoutVendorInput, SupplierUncheckedCreateWithoutVendorInput> | SupplierCreateWithoutVendorInput[] | SupplierUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutVendorInput | SupplierCreateOrConnectWithoutVendorInput[]
    createMany?: SupplierCreateManyVendorInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseCreateWithoutVendorInput, PurchaseUncheckedCreateWithoutVendorInput> | PurchaseCreateWithoutVendorInput[] | PurchaseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutVendorInput | PurchaseCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseCreateManyVendorInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type StockMovementUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<StockMovementCreateWithoutVendorInput, StockMovementUncheckedCreateWithoutVendorInput> | StockMovementCreateWithoutVendorInput[] | StockMovementUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutVendorInput | StockMovementCreateOrConnectWithoutVendorInput[]
    createMany?: StockMovementCreateManyVendorInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type StockTakeUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<StockTakeCreateWithoutVendorInput, StockTakeUncheckedCreateWithoutVendorInput> | StockTakeCreateWithoutVendorInput[] | StockTakeUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: StockTakeCreateOrConnectWithoutVendorInput | StockTakeCreateOrConnectWithoutVendorInput[]
    createMany?: StockTakeCreateManyVendorInputEnvelope
    connect?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<NotificationCreateWithoutVendorInput, NotificationUncheckedCreateWithoutVendorInput> | NotificationCreateWithoutVendorInput[] | NotificationUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutVendorInput | NotificationCreateOrConnectWithoutVendorInput[]
    createMany?: NotificationCreateManyVendorInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<AuditLogCreateWithoutVendorInput, AuditLogUncheckedCreateWithoutVendorInput> | AuditLogCreateWithoutVendorInput[] | AuditLogUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutVendorInput | AuditLogCreateOrConnectWithoutVendorInput[]
    createMany?: AuditLogCreateManyVendorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<SupportTicketCreateWithoutVendorInput, SupportTicketUncheckedCreateWithoutVendorInput> | SupportTicketCreateWithoutVendorInput[] | SupportTicketUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutVendorInput | SupportTicketCreateOrConnectWithoutVendorInput[]
    createMany?: SupportTicketCreateManyVendorInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<ReportCreateWithoutVendorInput, ReportUncheckedCreateWithoutVendorInput> | ReportCreateWithoutVendorInput[] | ReportUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutVendorInput | ReportCreateOrConnectWithoutVendorInput[]
    createMany?: ReportCreateManyVendorInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type VendorSettingsUncheckedCreateNestedOneWithoutVendorInput = {
    create?: XOR<VendorSettingsCreateWithoutVendorInput, VendorSettingsUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorSettingsCreateOrConnectWithoutVendorInput
    connect?: VendorSettingsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumSubscriptionPlanFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPlan
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutVendorNestedInput = {
    create?: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput> | UserCreateWithoutVendorInput[] | UserUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutVendorInput | UserCreateOrConnectWithoutVendorInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutVendorInput | UserUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: UserCreateManyVendorInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutVendorInput | UserUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: UserUpdateManyWithWhereWithoutVendorInput | UserUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput> | ProductCreateWithoutVendorInput[] | ProductUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutVendorInput | ProductCreateOrConnectWithoutVendorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutVendorInput | ProductUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ProductCreateManyVendorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutVendorInput | ProductUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutVendorInput | ProductUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutVendorNestedInput = {
    create?: XOR<CustomerCreateWithoutVendorInput, CustomerUncheckedCreateWithoutVendorInput> | CustomerCreateWithoutVendorInput[] | CustomerUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutVendorInput | CustomerCreateOrConnectWithoutVendorInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutVendorInput | CustomerUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: CustomerCreateManyVendorInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutVendorInput | CustomerUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutVendorInput | CustomerUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type SaleUpdateManyWithoutVendorNestedInput = {
    create?: XOR<SaleCreateWithoutVendorInput, SaleUncheckedCreateWithoutVendorInput> | SaleCreateWithoutVendorInput[] | SaleUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutVendorInput | SaleCreateOrConnectWithoutVendorInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutVendorInput | SaleUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: SaleCreateManyVendorInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutVendorInput | SaleUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutVendorInput | SaleUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type SupplierUpdateManyWithoutVendorNestedInput = {
    create?: XOR<SupplierCreateWithoutVendorInput, SupplierUncheckedCreateWithoutVendorInput> | SupplierCreateWithoutVendorInput[] | SupplierUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutVendorInput | SupplierCreateOrConnectWithoutVendorInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutVendorInput | SupplierUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: SupplierCreateManyVendorInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutVendorInput | SupplierUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutVendorInput | SupplierUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseCreateWithoutVendorInput, PurchaseUncheckedCreateWithoutVendorInput> | PurchaseCreateWithoutVendorInput[] | PurchaseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutVendorInput | PurchaseCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutVendorInput | PurchaseUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseCreateManyVendorInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutVendorInput | PurchaseUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutVendorInput | PurchaseUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type StockMovementUpdateManyWithoutVendorNestedInput = {
    create?: XOR<StockMovementCreateWithoutVendorInput, StockMovementUncheckedCreateWithoutVendorInput> | StockMovementCreateWithoutVendorInput[] | StockMovementUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutVendorInput | StockMovementCreateOrConnectWithoutVendorInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutVendorInput | StockMovementUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: StockMovementCreateManyVendorInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutVendorInput | StockMovementUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutVendorInput | StockMovementUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type StockTakeUpdateManyWithoutVendorNestedInput = {
    create?: XOR<StockTakeCreateWithoutVendorInput, StockTakeUncheckedCreateWithoutVendorInput> | StockTakeCreateWithoutVendorInput[] | StockTakeUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: StockTakeCreateOrConnectWithoutVendorInput | StockTakeCreateOrConnectWithoutVendorInput[]
    upsert?: StockTakeUpsertWithWhereUniqueWithoutVendorInput | StockTakeUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: StockTakeCreateManyVendorInputEnvelope
    set?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
    disconnect?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
    delete?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
    connect?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
    update?: StockTakeUpdateWithWhereUniqueWithoutVendorInput | StockTakeUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: StockTakeUpdateManyWithWhereWithoutVendorInput | StockTakeUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: StockTakeScalarWhereInput | StockTakeScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutVendorNestedInput = {
    create?: XOR<NotificationCreateWithoutVendorInput, NotificationUncheckedCreateWithoutVendorInput> | NotificationCreateWithoutVendorInput[] | NotificationUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutVendorInput | NotificationCreateOrConnectWithoutVendorInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutVendorInput | NotificationUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: NotificationCreateManyVendorInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutVendorInput | NotificationUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutVendorInput | NotificationUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutVendorNestedInput = {
    create?: XOR<AuditLogCreateWithoutVendorInput, AuditLogUncheckedCreateWithoutVendorInput> | AuditLogCreateWithoutVendorInput[] | AuditLogUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutVendorInput | AuditLogCreateOrConnectWithoutVendorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutVendorInput | AuditLogUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: AuditLogCreateManyVendorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutVendorInput | AuditLogUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutVendorInput | AuditLogUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutVendorNestedInput = {
    create?: XOR<SupportTicketCreateWithoutVendorInput, SupportTicketUncheckedCreateWithoutVendorInput> | SupportTicketCreateWithoutVendorInput[] | SupportTicketUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutVendorInput | SupportTicketCreateOrConnectWithoutVendorInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutVendorInput | SupportTicketUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: SupportTicketCreateManyVendorInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutVendorInput | SupportTicketUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutVendorInput | SupportTicketUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ReportCreateWithoutVendorInput, ReportUncheckedCreateWithoutVendorInput> | ReportCreateWithoutVendorInput[] | ReportUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutVendorInput | ReportCreateOrConnectWithoutVendorInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutVendorInput | ReportUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ReportCreateManyVendorInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutVendorInput | ReportUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutVendorInput | ReportUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type VendorSettingsUpdateOneWithoutVendorNestedInput = {
    create?: XOR<VendorSettingsCreateWithoutVendorInput, VendorSettingsUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorSettingsCreateOrConnectWithoutVendorInput
    upsert?: VendorSettingsUpsertWithoutVendorInput
    disconnect?: VendorSettingsWhereInput | boolean
    delete?: VendorSettingsWhereInput | boolean
    connect?: VendorSettingsWhereUniqueInput
    update?: XOR<XOR<VendorSettingsUpdateToOneWithWhereWithoutVendorInput, VendorSettingsUpdateWithoutVendorInput>, VendorSettingsUncheckedUpdateWithoutVendorInput>
  }

  export type UserUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput> | UserCreateWithoutVendorInput[] | UserUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutVendorInput | UserCreateOrConnectWithoutVendorInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutVendorInput | UserUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: UserCreateManyVendorInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutVendorInput | UserUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: UserUpdateManyWithWhereWithoutVendorInput | UserUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput> | ProductCreateWithoutVendorInput[] | ProductUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutVendorInput | ProductCreateOrConnectWithoutVendorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutVendorInput | ProductUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ProductCreateManyVendorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutVendorInput | ProductUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutVendorInput | ProductUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<CustomerCreateWithoutVendorInput, CustomerUncheckedCreateWithoutVendorInput> | CustomerCreateWithoutVendorInput[] | CustomerUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutVendorInput | CustomerCreateOrConnectWithoutVendorInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutVendorInput | CustomerUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: CustomerCreateManyVendorInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutVendorInput | CustomerUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutVendorInput | CustomerUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<SaleCreateWithoutVendorInput, SaleUncheckedCreateWithoutVendorInput> | SaleCreateWithoutVendorInput[] | SaleUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutVendorInput | SaleCreateOrConnectWithoutVendorInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutVendorInput | SaleUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: SaleCreateManyVendorInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutVendorInput | SaleUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutVendorInput | SaleUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type SupplierUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<SupplierCreateWithoutVendorInput, SupplierUncheckedCreateWithoutVendorInput> | SupplierCreateWithoutVendorInput[] | SupplierUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutVendorInput | SupplierCreateOrConnectWithoutVendorInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutVendorInput | SupplierUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: SupplierCreateManyVendorInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutVendorInput | SupplierUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutVendorInput | SupplierUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseCreateWithoutVendorInput, PurchaseUncheckedCreateWithoutVendorInput> | PurchaseCreateWithoutVendorInput[] | PurchaseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutVendorInput | PurchaseCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutVendorInput | PurchaseUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseCreateManyVendorInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutVendorInput | PurchaseUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutVendorInput | PurchaseUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type StockMovementUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<StockMovementCreateWithoutVendorInput, StockMovementUncheckedCreateWithoutVendorInput> | StockMovementCreateWithoutVendorInput[] | StockMovementUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutVendorInput | StockMovementCreateOrConnectWithoutVendorInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutVendorInput | StockMovementUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: StockMovementCreateManyVendorInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutVendorInput | StockMovementUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutVendorInput | StockMovementUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type StockTakeUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<StockTakeCreateWithoutVendorInput, StockTakeUncheckedCreateWithoutVendorInput> | StockTakeCreateWithoutVendorInput[] | StockTakeUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: StockTakeCreateOrConnectWithoutVendorInput | StockTakeCreateOrConnectWithoutVendorInput[]
    upsert?: StockTakeUpsertWithWhereUniqueWithoutVendorInput | StockTakeUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: StockTakeCreateManyVendorInputEnvelope
    set?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
    disconnect?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
    delete?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
    connect?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
    update?: StockTakeUpdateWithWhereUniqueWithoutVendorInput | StockTakeUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: StockTakeUpdateManyWithWhereWithoutVendorInput | StockTakeUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: StockTakeScalarWhereInput | StockTakeScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<NotificationCreateWithoutVendorInput, NotificationUncheckedCreateWithoutVendorInput> | NotificationCreateWithoutVendorInput[] | NotificationUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutVendorInput | NotificationCreateOrConnectWithoutVendorInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutVendorInput | NotificationUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: NotificationCreateManyVendorInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutVendorInput | NotificationUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutVendorInput | NotificationUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<AuditLogCreateWithoutVendorInput, AuditLogUncheckedCreateWithoutVendorInput> | AuditLogCreateWithoutVendorInput[] | AuditLogUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutVendorInput | AuditLogCreateOrConnectWithoutVendorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutVendorInput | AuditLogUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: AuditLogCreateManyVendorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutVendorInput | AuditLogUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutVendorInput | AuditLogUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<SupportTicketCreateWithoutVendorInput, SupportTicketUncheckedCreateWithoutVendorInput> | SupportTicketCreateWithoutVendorInput[] | SupportTicketUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutVendorInput | SupportTicketCreateOrConnectWithoutVendorInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutVendorInput | SupportTicketUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: SupportTicketCreateManyVendorInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutVendorInput | SupportTicketUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutVendorInput | SupportTicketUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ReportCreateWithoutVendorInput, ReportUncheckedCreateWithoutVendorInput> | ReportCreateWithoutVendorInput[] | ReportUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutVendorInput | ReportCreateOrConnectWithoutVendorInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutVendorInput | ReportUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ReportCreateManyVendorInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutVendorInput | ReportUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutVendorInput | ReportUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type VendorSettingsUncheckedUpdateOneWithoutVendorNestedInput = {
    create?: XOR<VendorSettingsCreateWithoutVendorInput, VendorSettingsUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorSettingsCreateOrConnectWithoutVendorInput
    upsert?: VendorSettingsUpsertWithoutVendorInput
    disconnect?: VendorSettingsWhereInput | boolean
    delete?: VendorSettingsWhereInput | boolean
    connect?: VendorSettingsWhereUniqueInput
    update?: XOR<XOR<VendorSettingsUpdateToOneWithWhereWithoutVendorInput, VendorSettingsUpdateWithoutVendorInput>, VendorSettingsUncheckedUpdateWithoutVendorInput>
  }

  export type VendorCreateNestedOneWithoutVendorSettingsInput = {
    create?: XOR<VendorCreateWithoutVendorSettingsInput, VendorUncheckedCreateWithoutVendorSettingsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVendorSettingsInput
    connect?: VendorWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VendorUpdateOneRequiredWithoutVendorSettingsNestedInput = {
    create?: XOR<VendorCreateWithoutVendorSettingsInput, VendorUncheckedCreateWithoutVendorSettingsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVendorSettingsInput
    upsert?: VendorUpsertWithoutVendorSettingsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutVendorSettingsInput, VendorUpdateWithoutVendorSettingsInput>, VendorUncheckedUpdateWithoutVendorSettingsInput>
  }

  export type VendorCreateNestedOneWithoutUsersInput = {
    create?: XOR<VendorCreateWithoutUsersInput, VendorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutUsersInput
    connect?: VendorWhereUniqueInput
  }

  export type CashierScheduleCreateNestedOneWithoutUserInput = {
    create?: XOR<CashierScheduleCreateWithoutUserInput, CashierScheduleUncheckedCreateWithoutUserInput>
    connectOrCreate?: CashierScheduleCreateOrConnectWithoutUserInput
    connect?: CashierScheduleWhereUniqueInput
  }

  export type SaleCreateNestedManyWithoutCashierInput = {
    create?: XOR<SaleCreateWithoutCashierInput, SaleUncheckedCreateWithoutCashierInput> | SaleCreateWithoutCashierInput[] | SaleUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCashierInput | SaleCreateOrConnectWithoutCashierInput[]
    createMany?: SaleCreateManyCashierInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type StockMovementCreateNestedManyWithoutCreatorInput = {
    create?: XOR<StockMovementCreateWithoutCreatorInput, StockMovementUncheckedCreateWithoutCreatorInput> | StockMovementCreateWithoutCreatorInput[] | StockMovementUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutCreatorInput | StockMovementCreateOrConnectWithoutCreatorInput[]
    createMany?: StockMovementCreateManyCreatorInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type StockTakeCreateNestedManyWithoutCreatorInput = {
    create?: XOR<StockTakeCreateWithoutCreatorInput, StockTakeUncheckedCreateWithoutCreatorInput> | StockTakeCreateWithoutCreatorInput[] | StockTakeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: StockTakeCreateOrConnectWithoutCreatorInput | StockTakeCreateOrConnectWithoutCreatorInput[]
    createMany?: StockTakeCreateManyCreatorInputEnvelope
    connect?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutGeneratorInput = {
    create?: XOR<ReportCreateWithoutGeneratorInput, ReportUncheckedCreateWithoutGeneratorInput> | ReportCreateWithoutGeneratorInput[] | ReportUncheckedCreateWithoutGeneratorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutGeneratorInput | ReportCreateOrConnectWithoutGeneratorInput[]
    createMany?: ReportCreateManyGeneratorInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type CashierProductAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<CashierProductAssignmentCreateWithoutUserInput, CashierProductAssignmentUncheckedCreateWithoutUserInput> | CashierProductAssignmentCreateWithoutUserInput[] | CashierProductAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CashierProductAssignmentCreateOrConnectWithoutUserInput | CashierProductAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: CashierProductAssignmentCreateManyUserInputEnvelope
    connect?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
  }

  export type CashierScheduleUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CashierScheduleCreateWithoutUserInput, CashierScheduleUncheckedCreateWithoutUserInput>
    connectOrCreate?: CashierScheduleCreateOrConnectWithoutUserInput
    connect?: CashierScheduleWhereUniqueInput
  }

  export type SaleUncheckedCreateNestedManyWithoutCashierInput = {
    create?: XOR<SaleCreateWithoutCashierInput, SaleUncheckedCreateWithoutCashierInput> | SaleCreateWithoutCashierInput[] | SaleUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCashierInput | SaleCreateOrConnectWithoutCashierInput[]
    createMany?: SaleCreateManyCashierInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type StockMovementUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<StockMovementCreateWithoutCreatorInput, StockMovementUncheckedCreateWithoutCreatorInput> | StockMovementCreateWithoutCreatorInput[] | StockMovementUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutCreatorInput | StockMovementCreateOrConnectWithoutCreatorInput[]
    createMany?: StockMovementCreateManyCreatorInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type StockTakeUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<StockTakeCreateWithoutCreatorInput, StockTakeUncheckedCreateWithoutCreatorInput> | StockTakeCreateWithoutCreatorInput[] | StockTakeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: StockTakeCreateOrConnectWithoutCreatorInput | StockTakeCreateOrConnectWithoutCreatorInput[]
    createMany?: StockTakeCreateManyCreatorInputEnvelope
    connect?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutGeneratorInput = {
    create?: XOR<ReportCreateWithoutGeneratorInput, ReportUncheckedCreateWithoutGeneratorInput> | ReportCreateWithoutGeneratorInput[] | ReportUncheckedCreateWithoutGeneratorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutGeneratorInput | ReportCreateOrConnectWithoutGeneratorInput[]
    createMany?: ReportCreateManyGeneratorInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type CashierProductAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CashierProductAssignmentCreateWithoutUserInput, CashierProductAssignmentUncheckedCreateWithoutUserInput> | CashierProductAssignmentCreateWithoutUserInput[] | CashierProductAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CashierProductAssignmentCreateOrConnectWithoutUserInput | CashierProductAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: CashierProductAssignmentCreateManyUserInputEnvelope
    connect?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type VendorUpdateOneWithoutUsersNestedInput = {
    create?: XOR<VendorCreateWithoutUsersInput, VendorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutUsersInput
    upsert?: VendorUpsertWithoutUsersInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutUsersInput, VendorUpdateWithoutUsersInput>, VendorUncheckedUpdateWithoutUsersInput>
  }

  export type CashierScheduleUpdateOneWithoutUserNestedInput = {
    create?: XOR<CashierScheduleCreateWithoutUserInput, CashierScheduleUncheckedCreateWithoutUserInput>
    connectOrCreate?: CashierScheduleCreateOrConnectWithoutUserInput
    upsert?: CashierScheduleUpsertWithoutUserInput
    disconnect?: CashierScheduleWhereInput | boolean
    delete?: CashierScheduleWhereInput | boolean
    connect?: CashierScheduleWhereUniqueInput
    update?: XOR<XOR<CashierScheduleUpdateToOneWithWhereWithoutUserInput, CashierScheduleUpdateWithoutUserInput>, CashierScheduleUncheckedUpdateWithoutUserInput>
  }

  export type SaleUpdateManyWithoutCashierNestedInput = {
    create?: XOR<SaleCreateWithoutCashierInput, SaleUncheckedCreateWithoutCashierInput> | SaleCreateWithoutCashierInput[] | SaleUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCashierInput | SaleCreateOrConnectWithoutCashierInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCashierInput | SaleUpsertWithWhereUniqueWithoutCashierInput[]
    createMany?: SaleCreateManyCashierInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCashierInput | SaleUpdateWithWhereUniqueWithoutCashierInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCashierInput | SaleUpdateManyWithWhereWithoutCashierInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type StockMovementUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<StockMovementCreateWithoutCreatorInput, StockMovementUncheckedCreateWithoutCreatorInput> | StockMovementCreateWithoutCreatorInput[] | StockMovementUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutCreatorInput | StockMovementCreateOrConnectWithoutCreatorInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutCreatorInput | StockMovementUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: StockMovementCreateManyCreatorInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutCreatorInput | StockMovementUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutCreatorInput | StockMovementUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type StockTakeUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<StockTakeCreateWithoutCreatorInput, StockTakeUncheckedCreateWithoutCreatorInput> | StockTakeCreateWithoutCreatorInput[] | StockTakeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: StockTakeCreateOrConnectWithoutCreatorInput | StockTakeCreateOrConnectWithoutCreatorInput[]
    upsert?: StockTakeUpsertWithWhereUniqueWithoutCreatorInput | StockTakeUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: StockTakeCreateManyCreatorInputEnvelope
    set?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
    disconnect?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
    delete?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
    connect?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
    update?: StockTakeUpdateWithWhereUniqueWithoutCreatorInput | StockTakeUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: StockTakeUpdateManyWithWhereWithoutCreatorInput | StockTakeUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: StockTakeScalarWhereInput | StockTakeScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutGeneratorNestedInput = {
    create?: XOR<ReportCreateWithoutGeneratorInput, ReportUncheckedCreateWithoutGeneratorInput> | ReportCreateWithoutGeneratorInput[] | ReportUncheckedCreateWithoutGeneratorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutGeneratorInput | ReportCreateOrConnectWithoutGeneratorInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutGeneratorInput | ReportUpsertWithWhereUniqueWithoutGeneratorInput[]
    createMany?: ReportCreateManyGeneratorInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutGeneratorInput | ReportUpdateWithWhereUniqueWithoutGeneratorInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutGeneratorInput | ReportUpdateManyWithWhereWithoutGeneratorInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type CashierProductAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CashierProductAssignmentCreateWithoutUserInput, CashierProductAssignmentUncheckedCreateWithoutUserInput> | CashierProductAssignmentCreateWithoutUserInput[] | CashierProductAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CashierProductAssignmentCreateOrConnectWithoutUserInput | CashierProductAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: CashierProductAssignmentUpsertWithWhereUniqueWithoutUserInput | CashierProductAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CashierProductAssignmentCreateManyUserInputEnvelope
    set?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
    disconnect?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
    delete?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
    connect?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
    update?: CashierProductAssignmentUpdateWithWhereUniqueWithoutUserInput | CashierProductAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CashierProductAssignmentUpdateManyWithWhereWithoutUserInput | CashierProductAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CashierProductAssignmentScalarWhereInput | CashierProductAssignmentScalarWhereInput[]
  }

  export type CashierScheduleUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CashierScheduleCreateWithoutUserInput, CashierScheduleUncheckedCreateWithoutUserInput>
    connectOrCreate?: CashierScheduleCreateOrConnectWithoutUserInput
    upsert?: CashierScheduleUpsertWithoutUserInput
    disconnect?: CashierScheduleWhereInput | boolean
    delete?: CashierScheduleWhereInput | boolean
    connect?: CashierScheduleWhereUniqueInput
    update?: XOR<XOR<CashierScheduleUpdateToOneWithWhereWithoutUserInput, CashierScheduleUpdateWithoutUserInput>, CashierScheduleUncheckedUpdateWithoutUserInput>
  }

  export type SaleUncheckedUpdateManyWithoutCashierNestedInput = {
    create?: XOR<SaleCreateWithoutCashierInput, SaleUncheckedCreateWithoutCashierInput> | SaleCreateWithoutCashierInput[] | SaleUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCashierInput | SaleCreateOrConnectWithoutCashierInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCashierInput | SaleUpsertWithWhereUniqueWithoutCashierInput[]
    createMany?: SaleCreateManyCashierInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCashierInput | SaleUpdateWithWhereUniqueWithoutCashierInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCashierInput | SaleUpdateManyWithWhereWithoutCashierInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type StockMovementUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<StockMovementCreateWithoutCreatorInput, StockMovementUncheckedCreateWithoutCreatorInput> | StockMovementCreateWithoutCreatorInput[] | StockMovementUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutCreatorInput | StockMovementCreateOrConnectWithoutCreatorInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutCreatorInput | StockMovementUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: StockMovementCreateManyCreatorInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutCreatorInput | StockMovementUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutCreatorInput | StockMovementUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type StockTakeUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<StockTakeCreateWithoutCreatorInput, StockTakeUncheckedCreateWithoutCreatorInput> | StockTakeCreateWithoutCreatorInput[] | StockTakeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: StockTakeCreateOrConnectWithoutCreatorInput | StockTakeCreateOrConnectWithoutCreatorInput[]
    upsert?: StockTakeUpsertWithWhereUniqueWithoutCreatorInput | StockTakeUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: StockTakeCreateManyCreatorInputEnvelope
    set?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
    disconnect?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
    delete?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
    connect?: StockTakeWhereUniqueInput | StockTakeWhereUniqueInput[]
    update?: StockTakeUpdateWithWhereUniqueWithoutCreatorInput | StockTakeUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: StockTakeUpdateManyWithWhereWithoutCreatorInput | StockTakeUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: StockTakeScalarWhereInput | StockTakeScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutGeneratorNestedInput = {
    create?: XOR<ReportCreateWithoutGeneratorInput, ReportUncheckedCreateWithoutGeneratorInput> | ReportCreateWithoutGeneratorInput[] | ReportUncheckedCreateWithoutGeneratorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutGeneratorInput | ReportCreateOrConnectWithoutGeneratorInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutGeneratorInput | ReportUpsertWithWhereUniqueWithoutGeneratorInput[]
    createMany?: ReportCreateManyGeneratorInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutGeneratorInput | ReportUpdateWithWhereUniqueWithoutGeneratorInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutGeneratorInput | ReportUpdateManyWithWhereWithoutGeneratorInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type CashierProductAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CashierProductAssignmentCreateWithoutUserInput, CashierProductAssignmentUncheckedCreateWithoutUserInput> | CashierProductAssignmentCreateWithoutUserInput[] | CashierProductAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CashierProductAssignmentCreateOrConnectWithoutUserInput | CashierProductAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: CashierProductAssignmentUpsertWithWhereUniqueWithoutUserInput | CashierProductAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CashierProductAssignmentCreateManyUserInputEnvelope
    set?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
    disconnect?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
    delete?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
    connect?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
    update?: CashierProductAssignmentUpdateWithWhereUniqueWithoutUserInput | CashierProductAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CashierProductAssignmentUpdateManyWithWhereWithoutUserInput | CashierProductAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CashierProductAssignmentScalarWhereInput | CashierProductAssignmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCashierScheduleInput = {
    create?: XOR<UserCreateWithoutCashierScheduleInput, UserUncheckedCreateWithoutCashierScheduleInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashierScheduleInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCashierScheduleNestedInput = {
    create?: XOR<UserCreateWithoutCashierScheduleInput, UserUncheckedCreateWithoutCashierScheduleInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashierScheduleInput
    upsert?: UserUpsertWithoutCashierScheduleInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCashierScheduleInput, UserUpdateWithoutCashierScheduleInput>, UserUncheckedUpdateWithoutCashierScheduleInput>
  }

  export type VendorCreateNestedOneWithoutProductsInput = {
    create?: XOR<VendorCreateWithoutProductsInput, VendorUncheckedCreateWithoutProductsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutProductsInput
    connect?: VendorWhereUniqueInput
  }

  export type ProductVariantCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
  }

  export type ProductStockLocationCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductStockLocationCreateWithoutProductInput, ProductStockLocationUncheckedCreateWithoutProductInput> | ProductStockLocationCreateWithoutProductInput[] | ProductStockLocationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStockLocationCreateOrConnectWithoutProductInput | ProductStockLocationCreateOrConnectWithoutProductInput[]
    createMany?: ProductStockLocationCreateManyProductInputEnvelope
    connect?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
  }

  export type SaleItemCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput> | SaleItemCreateWithoutProductInput[] | SaleItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutProductInput | SaleItemCreateOrConnectWithoutProductInput[]
    createMany?: SaleItemCreateManyProductInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type PurchaseItemCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type StockMovementCreateNestedManyWithoutProductInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type StockTakeItemCreateNestedManyWithoutProductInput = {
    create?: XOR<StockTakeItemCreateWithoutProductInput, StockTakeItemUncheckedCreateWithoutProductInput> | StockTakeItemCreateWithoutProductInput[] | StockTakeItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTakeItemCreateOrConnectWithoutProductInput | StockTakeItemCreateOrConnectWithoutProductInput[]
    createMany?: StockTakeItemCreateManyProductInputEnvelope
    connect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
  }

  export type CashierProductAssignmentCreateNestedManyWithoutProductInput = {
    create?: XOR<CashierProductAssignmentCreateWithoutProductInput, CashierProductAssignmentUncheckedCreateWithoutProductInput> | CashierProductAssignmentCreateWithoutProductInput[] | CashierProductAssignmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CashierProductAssignmentCreateOrConnectWithoutProductInput | CashierProductAssignmentCreateOrConnectWithoutProductInput[]
    createMany?: CashierProductAssignmentCreateManyProductInputEnvelope
    connect?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
  }

  export type ProductVariantUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
  }

  export type ProductStockLocationUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductStockLocationCreateWithoutProductInput, ProductStockLocationUncheckedCreateWithoutProductInput> | ProductStockLocationCreateWithoutProductInput[] | ProductStockLocationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStockLocationCreateOrConnectWithoutProductInput | ProductStockLocationCreateOrConnectWithoutProductInput[]
    createMany?: ProductStockLocationCreateManyProductInputEnvelope
    connect?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
  }

  export type SaleItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput> | SaleItemCreateWithoutProductInput[] | SaleItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutProductInput | SaleItemCreateOrConnectWithoutProductInput[]
    createMany?: SaleItemCreateManyProductInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type PurchaseItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type StockMovementUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type StockTakeItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockTakeItemCreateWithoutProductInput, StockTakeItemUncheckedCreateWithoutProductInput> | StockTakeItemCreateWithoutProductInput[] | StockTakeItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTakeItemCreateOrConnectWithoutProductInput | StockTakeItemCreateOrConnectWithoutProductInput[]
    createMany?: StockTakeItemCreateManyProductInputEnvelope
    connect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
  }

  export type CashierProductAssignmentUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CashierProductAssignmentCreateWithoutProductInput, CashierProductAssignmentUncheckedCreateWithoutProductInput> | CashierProductAssignmentCreateWithoutProductInput[] | CashierProductAssignmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CashierProductAssignmentCreateOrConnectWithoutProductInput | CashierProductAssignmentCreateOrConnectWithoutProductInput[]
    createMany?: CashierProductAssignmentCreateManyProductInputEnvelope
    connect?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
  }

  export type VendorUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<VendorCreateWithoutProductsInput, VendorUncheckedCreateWithoutProductsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutProductsInput
    upsert?: VendorUpsertWithoutProductsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutProductsInput, VendorUpdateWithoutProductsInput>, VendorUncheckedUpdateWithoutProductsInput>
  }

  export type ProductVariantUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariantUpsertWithWhereUniqueWithoutProductInput | ProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    set?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    disconnect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    delete?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    update?: ProductVariantUpdateWithWhereUniqueWithoutProductInput | ProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariantUpdateManyWithWhereWithoutProductInput | ProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
  }

  export type ProductStockLocationUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductStockLocationCreateWithoutProductInput, ProductStockLocationUncheckedCreateWithoutProductInput> | ProductStockLocationCreateWithoutProductInput[] | ProductStockLocationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStockLocationCreateOrConnectWithoutProductInput | ProductStockLocationCreateOrConnectWithoutProductInput[]
    upsert?: ProductStockLocationUpsertWithWhereUniqueWithoutProductInput | ProductStockLocationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductStockLocationCreateManyProductInputEnvelope
    set?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
    disconnect?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
    delete?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
    connect?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
    update?: ProductStockLocationUpdateWithWhereUniqueWithoutProductInput | ProductStockLocationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductStockLocationUpdateManyWithWhereWithoutProductInput | ProductStockLocationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductStockLocationScalarWhereInput | ProductStockLocationScalarWhereInput[]
  }

  export type SaleItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput> | SaleItemCreateWithoutProductInput[] | SaleItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutProductInput | SaleItemCreateOrConnectWithoutProductInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutProductInput | SaleItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleItemCreateManyProductInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutProductInput | SaleItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutProductInput | SaleItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type PurchaseItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutProductInput | PurchaseItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutProductInput | PurchaseItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutProductInput | PurchaseItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type StockMovementUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutProductInput | StockMovementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutProductInput | StockMovementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutProductInput | StockMovementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type StockTakeItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockTakeItemCreateWithoutProductInput, StockTakeItemUncheckedCreateWithoutProductInput> | StockTakeItemCreateWithoutProductInput[] | StockTakeItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTakeItemCreateOrConnectWithoutProductInput | StockTakeItemCreateOrConnectWithoutProductInput[]
    upsert?: StockTakeItemUpsertWithWhereUniqueWithoutProductInput | StockTakeItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockTakeItemCreateManyProductInputEnvelope
    set?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    disconnect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    delete?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    connect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    update?: StockTakeItemUpdateWithWhereUniqueWithoutProductInput | StockTakeItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockTakeItemUpdateManyWithWhereWithoutProductInput | StockTakeItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockTakeItemScalarWhereInput | StockTakeItemScalarWhereInput[]
  }

  export type CashierProductAssignmentUpdateManyWithoutProductNestedInput = {
    create?: XOR<CashierProductAssignmentCreateWithoutProductInput, CashierProductAssignmentUncheckedCreateWithoutProductInput> | CashierProductAssignmentCreateWithoutProductInput[] | CashierProductAssignmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CashierProductAssignmentCreateOrConnectWithoutProductInput | CashierProductAssignmentCreateOrConnectWithoutProductInput[]
    upsert?: CashierProductAssignmentUpsertWithWhereUniqueWithoutProductInput | CashierProductAssignmentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CashierProductAssignmentCreateManyProductInputEnvelope
    set?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
    disconnect?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
    delete?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
    connect?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
    update?: CashierProductAssignmentUpdateWithWhereUniqueWithoutProductInput | CashierProductAssignmentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CashierProductAssignmentUpdateManyWithWhereWithoutProductInput | CashierProductAssignmentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CashierProductAssignmentScalarWhereInput | CashierProductAssignmentScalarWhereInput[]
  }

  export type ProductVariantUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariantUpsertWithWhereUniqueWithoutProductInput | ProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    set?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    disconnect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    delete?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    update?: ProductVariantUpdateWithWhereUniqueWithoutProductInput | ProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariantUpdateManyWithWhereWithoutProductInput | ProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
  }

  export type ProductStockLocationUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductStockLocationCreateWithoutProductInput, ProductStockLocationUncheckedCreateWithoutProductInput> | ProductStockLocationCreateWithoutProductInput[] | ProductStockLocationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStockLocationCreateOrConnectWithoutProductInput | ProductStockLocationCreateOrConnectWithoutProductInput[]
    upsert?: ProductStockLocationUpsertWithWhereUniqueWithoutProductInput | ProductStockLocationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductStockLocationCreateManyProductInputEnvelope
    set?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
    disconnect?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
    delete?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
    connect?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
    update?: ProductStockLocationUpdateWithWhereUniqueWithoutProductInput | ProductStockLocationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductStockLocationUpdateManyWithWhereWithoutProductInput | ProductStockLocationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductStockLocationScalarWhereInput | ProductStockLocationScalarWhereInput[]
  }

  export type SaleItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput> | SaleItemCreateWithoutProductInput[] | SaleItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutProductInput | SaleItemCreateOrConnectWithoutProductInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutProductInput | SaleItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleItemCreateManyProductInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutProductInput | SaleItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutProductInput | SaleItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type PurchaseItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutProductInput | PurchaseItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutProductInput | PurchaseItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutProductInput | PurchaseItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type StockMovementUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutProductInput | StockMovementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutProductInput | StockMovementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutProductInput | StockMovementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type StockTakeItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockTakeItemCreateWithoutProductInput, StockTakeItemUncheckedCreateWithoutProductInput> | StockTakeItemCreateWithoutProductInput[] | StockTakeItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTakeItemCreateOrConnectWithoutProductInput | StockTakeItemCreateOrConnectWithoutProductInput[]
    upsert?: StockTakeItemUpsertWithWhereUniqueWithoutProductInput | StockTakeItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockTakeItemCreateManyProductInputEnvelope
    set?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    disconnect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    delete?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    connect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    update?: StockTakeItemUpdateWithWhereUniqueWithoutProductInput | StockTakeItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockTakeItemUpdateManyWithWhereWithoutProductInput | StockTakeItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockTakeItemScalarWhereInput | StockTakeItemScalarWhereInput[]
  }

  export type CashierProductAssignmentUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CashierProductAssignmentCreateWithoutProductInput, CashierProductAssignmentUncheckedCreateWithoutProductInput> | CashierProductAssignmentCreateWithoutProductInput[] | CashierProductAssignmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CashierProductAssignmentCreateOrConnectWithoutProductInput | CashierProductAssignmentCreateOrConnectWithoutProductInput[]
    upsert?: CashierProductAssignmentUpsertWithWhereUniqueWithoutProductInput | CashierProductAssignmentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CashierProductAssignmentCreateManyProductInputEnvelope
    set?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
    disconnect?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
    delete?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
    connect?: CashierProductAssignmentWhereUniqueInput | CashierProductAssignmentWhereUniqueInput[]
    update?: CashierProductAssignmentUpdateWithWhereUniqueWithoutProductInput | CashierProductAssignmentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CashierProductAssignmentUpdateManyWithWhereWithoutProductInput | CashierProductAssignmentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CashierProductAssignmentScalarWhereInput | CashierProductAssignmentScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutVariantsInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductStockLocationCreateNestedManyWithoutVariantInput = {
    create?: XOR<ProductStockLocationCreateWithoutVariantInput, ProductStockLocationUncheckedCreateWithoutVariantInput> | ProductStockLocationCreateWithoutVariantInput[] | ProductStockLocationUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ProductStockLocationCreateOrConnectWithoutVariantInput | ProductStockLocationCreateOrConnectWithoutVariantInput[]
    createMany?: ProductStockLocationCreateManyVariantInputEnvelope
    connect?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
  }

  export type SaleItemCreateNestedManyWithoutVariantInput = {
    create?: XOR<SaleItemCreateWithoutVariantInput, SaleItemUncheckedCreateWithoutVariantInput> | SaleItemCreateWithoutVariantInput[] | SaleItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutVariantInput | SaleItemCreateOrConnectWithoutVariantInput[]
    createMany?: SaleItemCreateManyVariantInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type PurchaseItemCreateNestedManyWithoutVariantInput = {
    create?: XOR<PurchaseItemCreateWithoutVariantInput, PurchaseItemUncheckedCreateWithoutVariantInput> | PurchaseItemCreateWithoutVariantInput[] | PurchaseItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutVariantInput | PurchaseItemCreateOrConnectWithoutVariantInput[]
    createMany?: PurchaseItemCreateManyVariantInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type StockMovementCreateNestedManyWithoutVariantInput = {
    create?: XOR<StockMovementCreateWithoutVariantInput, StockMovementUncheckedCreateWithoutVariantInput> | StockMovementCreateWithoutVariantInput[] | StockMovementUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutVariantInput | StockMovementCreateOrConnectWithoutVariantInput[]
    createMany?: StockMovementCreateManyVariantInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type StockTakeItemCreateNestedManyWithoutVariantInput = {
    create?: XOR<StockTakeItemCreateWithoutVariantInput, StockTakeItemUncheckedCreateWithoutVariantInput> | StockTakeItemCreateWithoutVariantInput[] | StockTakeItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockTakeItemCreateOrConnectWithoutVariantInput | StockTakeItemCreateOrConnectWithoutVariantInput[]
    createMany?: StockTakeItemCreateManyVariantInputEnvelope
    connect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
  }

  export type ProductStockLocationUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<ProductStockLocationCreateWithoutVariantInput, ProductStockLocationUncheckedCreateWithoutVariantInput> | ProductStockLocationCreateWithoutVariantInput[] | ProductStockLocationUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ProductStockLocationCreateOrConnectWithoutVariantInput | ProductStockLocationCreateOrConnectWithoutVariantInput[]
    createMany?: ProductStockLocationCreateManyVariantInputEnvelope
    connect?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
  }

  export type SaleItemUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<SaleItemCreateWithoutVariantInput, SaleItemUncheckedCreateWithoutVariantInput> | SaleItemCreateWithoutVariantInput[] | SaleItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutVariantInput | SaleItemCreateOrConnectWithoutVariantInput[]
    createMany?: SaleItemCreateManyVariantInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type PurchaseItemUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<PurchaseItemCreateWithoutVariantInput, PurchaseItemUncheckedCreateWithoutVariantInput> | PurchaseItemCreateWithoutVariantInput[] | PurchaseItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutVariantInput | PurchaseItemCreateOrConnectWithoutVariantInput[]
    createMany?: PurchaseItemCreateManyVariantInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type StockMovementUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<StockMovementCreateWithoutVariantInput, StockMovementUncheckedCreateWithoutVariantInput> | StockMovementCreateWithoutVariantInput[] | StockMovementUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutVariantInput | StockMovementCreateOrConnectWithoutVariantInput[]
    createMany?: StockMovementCreateManyVariantInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type StockTakeItemUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<StockTakeItemCreateWithoutVariantInput, StockTakeItemUncheckedCreateWithoutVariantInput> | StockTakeItemCreateWithoutVariantInput[] | StockTakeItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockTakeItemCreateOrConnectWithoutVariantInput | StockTakeItemCreateOrConnectWithoutVariantInput[]
    createMany?: StockTakeItemCreateManyVariantInputEnvelope
    connect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    upsert?: ProductUpsertWithoutVariantsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutVariantsInput, ProductUpdateWithoutVariantsInput>, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type ProductStockLocationUpdateManyWithoutVariantNestedInput = {
    create?: XOR<ProductStockLocationCreateWithoutVariantInput, ProductStockLocationUncheckedCreateWithoutVariantInput> | ProductStockLocationCreateWithoutVariantInput[] | ProductStockLocationUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ProductStockLocationCreateOrConnectWithoutVariantInput | ProductStockLocationCreateOrConnectWithoutVariantInput[]
    upsert?: ProductStockLocationUpsertWithWhereUniqueWithoutVariantInput | ProductStockLocationUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: ProductStockLocationCreateManyVariantInputEnvelope
    set?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
    disconnect?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
    delete?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
    connect?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
    update?: ProductStockLocationUpdateWithWhereUniqueWithoutVariantInput | ProductStockLocationUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: ProductStockLocationUpdateManyWithWhereWithoutVariantInput | ProductStockLocationUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: ProductStockLocationScalarWhereInput | ProductStockLocationScalarWhereInput[]
  }

  export type SaleItemUpdateManyWithoutVariantNestedInput = {
    create?: XOR<SaleItemCreateWithoutVariantInput, SaleItemUncheckedCreateWithoutVariantInput> | SaleItemCreateWithoutVariantInput[] | SaleItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutVariantInput | SaleItemCreateOrConnectWithoutVariantInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutVariantInput | SaleItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: SaleItemCreateManyVariantInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutVariantInput | SaleItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutVariantInput | SaleItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type PurchaseItemUpdateManyWithoutVariantNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutVariantInput, PurchaseItemUncheckedCreateWithoutVariantInput> | PurchaseItemCreateWithoutVariantInput[] | PurchaseItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutVariantInput | PurchaseItemCreateOrConnectWithoutVariantInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutVariantInput | PurchaseItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: PurchaseItemCreateManyVariantInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutVariantInput | PurchaseItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutVariantInput | PurchaseItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type StockMovementUpdateManyWithoutVariantNestedInput = {
    create?: XOR<StockMovementCreateWithoutVariantInput, StockMovementUncheckedCreateWithoutVariantInput> | StockMovementCreateWithoutVariantInput[] | StockMovementUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutVariantInput | StockMovementCreateOrConnectWithoutVariantInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutVariantInput | StockMovementUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: StockMovementCreateManyVariantInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutVariantInput | StockMovementUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutVariantInput | StockMovementUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type StockTakeItemUpdateManyWithoutVariantNestedInput = {
    create?: XOR<StockTakeItemCreateWithoutVariantInput, StockTakeItemUncheckedCreateWithoutVariantInput> | StockTakeItemCreateWithoutVariantInput[] | StockTakeItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockTakeItemCreateOrConnectWithoutVariantInput | StockTakeItemCreateOrConnectWithoutVariantInput[]
    upsert?: StockTakeItemUpsertWithWhereUniqueWithoutVariantInput | StockTakeItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: StockTakeItemCreateManyVariantInputEnvelope
    set?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    disconnect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    delete?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    connect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    update?: StockTakeItemUpdateWithWhereUniqueWithoutVariantInput | StockTakeItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: StockTakeItemUpdateManyWithWhereWithoutVariantInput | StockTakeItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: StockTakeItemScalarWhereInput | StockTakeItemScalarWhereInput[]
  }

  export type ProductStockLocationUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<ProductStockLocationCreateWithoutVariantInput, ProductStockLocationUncheckedCreateWithoutVariantInput> | ProductStockLocationCreateWithoutVariantInput[] | ProductStockLocationUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ProductStockLocationCreateOrConnectWithoutVariantInput | ProductStockLocationCreateOrConnectWithoutVariantInput[]
    upsert?: ProductStockLocationUpsertWithWhereUniqueWithoutVariantInput | ProductStockLocationUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: ProductStockLocationCreateManyVariantInputEnvelope
    set?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
    disconnect?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
    delete?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
    connect?: ProductStockLocationWhereUniqueInput | ProductStockLocationWhereUniqueInput[]
    update?: ProductStockLocationUpdateWithWhereUniqueWithoutVariantInput | ProductStockLocationUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: ProductStockLocationUpdateManyWithWhereWithoutVariantInput | ProductStockLocationUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: ProductStockLocationScalarWhereInput | ProductStockLocationScalarWhereInput[]
  }

  export type SaleItemUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<SaleItemCreateWithoutVariantInput, SaleItemUncheckedCreateWithoutVariantInput> | SaleItemCreateWithoutVariantInput[] | SaleItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutVariantInput | SaleItemCreateOrConnectWithoutVariantInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutVariantInput | SaleItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: SaleItemCreateManyVariantInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutVariantInput | SaleItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutVariantInput | SaleItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type PurchaseItemUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutVariantInput, PurchaseItemUncheckedCreateWithoutVariantInput> | PurchaseItemCreateWithoutVariantInput[] | PurchaseItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutVariantInput | PurchaseItemCreateOrConnectWithoutVariantInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutVariantInput | PurchaseItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: PurchaseItemCreateManyVariantInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutVariantInput | PurchaseItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutVariantInput | PurchaseItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type StockMovementUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<StockMovementCreateWithoutVariantInput, StockMovementUncheckedCreateWithoutVariantInput> | StockMovementCreateWithoutVariantInput[] | StockMovementUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutVariantInput | StockMovementCreateOrConnectWithoutVariantInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutVariantInput | StockMovementUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: StockMovementCreateManyVariantInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutVariantInput | StockMovementUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutVariantInput | StockMovementUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type StockTakeItemUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<StockTakeItemCreateWithoutVariantInput, StockTakeItemUncheckedCreateWithoutVariantInput> | StockTakeItemCreateWithoutVariantInput[] | StockTakeItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockTakeItemCreateOrConnectWithoutVariantInput | StockTakeItemCreateOrConnectWithoutVariantInput[]
    upsert?: StockTakeItemUpsertWithWhereUniqueWithoutVariantInput | StockTakeItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: StockTakeItemCreateManyVariantInputEnvelope
    set?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    disconnect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    delete?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    connect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    update?: StockTakeItemUpdateWithWhereUniqueWithoutVariantInput | StockTakeItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: StockTakeItemUpdateManyWithWhereWithoutVariantInput | StockTakeItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: StockTakeItemScalarWhereInput | StockTakeItemScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutStockLocationsInput = {
    create?: XOR<ProductCreateWithoutStockLocationsInput, ProductUncheckedCreateWithoutStockLocationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockLocationsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductVariantCreateNestedOneWithoutStockLocationsInput = {
    create?: XOR<ProductVariantCreateWithoutStockLocationsInput, ProductVariantUncheckedCreateWithoutStockLocationsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutStockLocationsInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutStockLocationsNestedInput = {
    create?: XOR<ProductCreateWithoutStockLocationsInput, ProductUncheckedCreateWithoutStockLocationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockLocationsInput
    upsert?: ProductUpsertWithoutStockLocationsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStockLocationsInput, ProductUpdateWithoutStockLocationsInput>, ProductUncheckedUpdateWithoutStockLocationsInput>
  }

  export type ProductVariantUpdateOneWithoutStockLocationsNestedInput = {
    create?: XOR<ProductVariantCreateWithoutStockLocationsInput, ProductVariantUncheckedCreateWithoutStockLocationsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutStockLocationsInput
    upsert?: ProductVariantUpsertWithoutStockLocationsInput
    disconnect?: ProductVariantWhereInput | boolean
    delete?: ProductVariantWhereInput | boolean
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutStockLocationsInput, ProductVariantUpdateWithoutStockLocationsInput>, ProductVariantUncheckedUpdateWithoutStockLocationsInput>
  }

  export type UserCreateNestedOneWithoutProductAssignmentsInput = {
    create?: XOR<UserCreateWithoutProductAssignmentsInput, UserUncheckedCreateWithoutProductAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCashierAssignmentsInput = {
    create?: XOR<ProductCreateWithoutCashierAssignmentsInput, ProductUncheckedCreateWithoutCashierAssignmentsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCashierAssignmentsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProductAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutProductAssignmentsInput, UserUncheckedCreateWithoutProductAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductAssignmentsInput
    upsert?: UserUpsertWithoutProductAssignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductAssignmentsInput, UserUpdateWithoutProductAssignmentsInput>, UserUncheckedUpdateWithoutProductAssignmentsInput>
  }

  export type ProductUpdateOneRequiredWithoutCashierAssignmentsNestedInput = {
    create?: XOR<ProductCreateWithoutCashierAssignmentsInput, ProductUncheckedCreateWithoutCashierAssignmentsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCashierAssignmentsInput
    upsert?: ProductUpsertWithoutCashierAssignmentsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCashierAssignmentsInput, ProductUpdateWithoutCashierAssignmentsInput>, ProductUncheckedUpdateWithoutCashierAssignmentsInput>
  }

  export type VendorCreateNestedOneWithoutCustomersInput = {
    create?: XOR<VendorCreateWithoutCustomersInput, VendorUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutCustomersInput
    connect?: VendorWhereUniqueInput
  }

  export type SaleCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type VendorUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<VendorCreateWithoutCustomersInput, VendorUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutCustomersInput
    upsert?: VendorUpsertWithoutCustomersInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutCustomersInput, VendorUpdateWithoutCustomersInput>, VendorUncheckedUpdateWithoutCustomersInput>
  }

  export type SaleUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCustomerInput | SaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCustomerInput | SaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCustomerInput | SaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCustomerInput | SaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCustomerInput | SaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCustomerInput | SaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type VendorCreateNestedOneWithoutSalesInput = {
    create?: XOR<VendorCreateWithoutSalesInput, VendorUncheckedCreateWithoutSalesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutSalesInput
    connect?: VendorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSalesInput = {
    create?: XOR<UserCreateWithoutSalesInput, UserUncheckedCreateWithoutSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutSalesInput = {
    create?: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesInput
    connect?: CustomerWhereUniqueInput
  }

  export type SaleItemCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput> | SaleItemCreateWithoutSaleInput[] | SaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutSaleInput | SaleItemCreateOrConnectWithoutSaleInput[]
    createMany?: SaleItemCreateManySaleInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type SaleItemUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput> | SaleItemCreateWithoutSaleInput[] | SaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutSaleInput | SaleItemCreateOrConnectWithoutSaleInput[]
    createMany?: SaleItemCreateManySaleInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumSaleStatusFieldUpdateOperationsInput = {
    set?: $Enums.SaleStatus
  }

  export type VendorUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<VendorCreateWithoutSalesInput, VendorUncheckedCreateWithoutSalesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutSalesInput
    upsert?: VendorUpsertWithoutSalesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutSalesInput, VendorUpdateWithoutSalesInput>, VendorUncheckedUpdateWithoutSalesInput>
  }

  export type UserUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<UserCreateWithoutSalesInput, UserUncheckedCreateWithoutSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesInput
    upsert?: UserUpsertWithoutSalesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalesInput, UserUpdateWithoutSalesInput>, UserUncheckedUpdateWithoutSalesInput>
  }

  export type CustomerUpdateOneWithoutSalesNestedInput = {
    create?: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesInput
    upsert?: CustomerUpsertWithoutSalesInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSalesInput, CustomerUpdateWithoutSalesInput>, CustomerUncheckedUpdateWithoutSalesInput>
  }

  export type SaleItemUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput> | SaleItemCreateWithoutSaleInput[] | SaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutSaleInput | SaleItemCreateOrConnectWithoutSaleInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutSaleInput | SaleItemUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleItemCreateManySaleInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutSaleInput | SaleItemUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutSaleInput | SaleItemUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type SaleItemUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput> | SaleItemCreateWithoutSaleInput[] | SaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutSaleInput | SaleItemCreateOrConnectWithoutSaleInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutSaleInput | SaleItemUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleItemCreateManySaleInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutSaleInput | SaleItemUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutSaleInput | SaleItemUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type SaleCreateNestedOneWithoutItemsInput = {
    create?: XOR<SaleCreateWithoutItemsInput, SaleUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutItemsInput
    connect?: SaleWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSaleItemsInput = {
    create?: XOR<ProductCreateWithoutSaleItemsInput, ProductUncheckedCreateWithoutSaleItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSaleItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductVariantCreateNestedOneWithoutSaleItemsInput = {
    create?: XOR<ProductVariantCreateWithoutSaleItemsInput, ProductVariantUncheckedCreateWithoutSaleItemsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutSaleItemsInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type SaleUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SaleCreateWithoutItemsInput, SaleUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutItemsInput
    upsert?: SaleUpsertWithoutItemsInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutItemsInput, SaleUpdateWithoutItemsInput>, SaleUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutSaleItemsNestedInput = {
    create?: XOR<ProductCreateWithoutSaleItemsInput, ProductUncheckedCreateWithoutSaleItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSaleItemsInput
    upsert?: ProductUpsertWithoutSaleItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSaleItemsInput, ProductUpdateWithoutSaleItemsInput>, ProductUncheckedUpdateWithoutSaleItemsInput>
  }

  export type ProductVariantUpdateOneWithoutSaleItemsNestedInput = {
    create?: XOR<ProductVariantCreateWithoutSaleItemsInput, ProductVariantUncheckedCreateWithoutSaleItemsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutSaleItemsInput
    upsert?: ProductVariantUpsertWithoutSaleItemsInput
    disconnect?: ProductVariantWhereInput | boolean
    delete?: ProductVariantWhereInput | boolean
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutSaleItemsInput, ProductVariantUpdateWithoutSaleItemsInput>, ProductVariantUncheckedUpdateWithoutSaleItemsInput>
  }

  export type VendorCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<VendorCreateWithoutSuppliersInput, VendorUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutSuppliersInput
    connect?: VendorWhereUniqueInput
  }

  export type PurchaseCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput> | PurchaseCreateWithoutSupplierInput[] | PurchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSupplierInput | PurchaseCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseCreateManySupplierInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput> | PurchaseCreateWithoutSupplierInput[] | PurchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSupplierInput | PurchaseCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseCreateManySupplierInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type VendorUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<VendorCreateWithoutSuppliersInput, VendorUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutSuppliersInput
    upsert?: VendorUpsertWithoutSuppliersInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutSuppliersInput, VendorUpdateWithoutSuppliersInput>, VendorUncheckedUpdateWithoutSuppliersInput>
  }

  export type PurchaseUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput> | PurchaseCreateWithoutSupplierInput[] | PurchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSupplierInput | PurchaseCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutSupplierInput | PurchaseUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseCreateManySupplierInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutSupplierInput | PurchaseUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutSupplierInput | PurchaseUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput> | PurchaseCreateWithoutSupplierInput[] | PurchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSupplierInput | PurchaseCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutSupplierInput | PurchaseUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseCreateManySupplierInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutSupplierInput | PurchaseUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutSupplierInput | PurchaseUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type VendorCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<VendorCreateWithoutPurchasesInput, VendorUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchasesInput
    connect?: VendorWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<SupplierCreateWithoutPurchasesInput, SupplierUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchasesInput
    connect?: SupplierWhereUniqueInput
  }

  export type PurchaseItemCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type EnumPurchaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.PurchaseStatus
  }

  export type VendorUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<VendorCreateWithoutPurchasesInput, VendorUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchasesInput
    upsert?: VendorUpsertWithoutPurchasesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutPurchasesInput, VendorUpdateWithoutPurchasesInput>, VendorUncheckedUpdateWithoutPurchasesInput>
  }

  export type SupplierUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchasesInput, SupplierUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchasesInput
    upsert?: SupplierUpsertWithoutPurchasesInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchasesInput, SupplierUpdateWithoutPurchasesInput>, SupplierUncheckedUpdateWithoutPurchasesInput>
  }

  export type PurchaseItemUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutPurchaseInput | PurchaseItemUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutPurchaseInput | PurchaseItemUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type PurchaseCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseCreateWithoutItemsInput, PurchaseUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutItemsInput
    connect?: PurchaseWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPurchaseItemsInput = {
    create?: XOR<ProductCreateWithoutPurchaseItemsInput, ProductUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductVariantCreateNestedOneWithoutPurchaseItemsInput = {
    create?: XOR<ProductVariantCreateWithoutPurchaseItemsInput, ProductVariantUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutPurchaseItemsInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type PurchaseUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseCreateWithoutItemsInput, PurchaseUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutItemsInput
    upsert?: PurchaseUpsertWithoutItemsInput
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutItemsInput, PurchaseUpdateWithoutItemsInput>, PurchaseUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutPurchaseItemsNestedInput = {
    create?: XOR<ProductCreateWithoutPurchaseItemsInput, ProductUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseItemsInput
    upsert?: ProductUpsertWithoutPurchaseItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPurchaseItemsInput, ProductUpdateWithoutPurchaseItemsInput>, ProductUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type ProductVariantUpdateOneWithoutPurchaseItemsNestedInput = {
    create?: XOR<ProductVariantCreateWithoutPurchaseItemsInput, ProductVariantUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutPurchaseItemsInput
    upsert?: ProductVariantUpsertWithoutPurchaseItemsInput
    disconnect?: ProductVariantWhereInput | boolean
    delete?: ProductVariantWhereInput | boolean
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutPurchaseItemsInput, ProductVariantUpdateWithoutPurchaseItemsInput>, ProductVariantUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type VendorCreateNestedOneWithoutStockMovementsInput = {
    create?: XOR<VendorCreateWithoutStockMovementsInput, VendorUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutStockMovementsInput
    connect?: VendorWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutStockMovementsInput = {
    create?: XOR<ProductCreateWithoutStockMovementsInput, ProductUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockMovementsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductVariantCreateNestedOneWithoutStockMovementsInput = {
    create?: XOR<ProductVariantCreateWithoutStockMovementsInput, ProductVariantUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutStockMovementsInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStockMovementsInput = {
    create?: XOR<UserCreateWithoutStockMovementsInput, UserUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStockMovementsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumStockMovementTypeFieldUpdateOperationsInput = {
    set?: $Enums.StockMovementType
  }

  export type VendorUpdateOneRequiredWithoutStockMovementsNestedInput = {
    create?: XOR<VendorCreateWithoutStockMovementsInput, VendorUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutStockMovementsInput
    upsert?: VendorUpsertWithoutStockMovementsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutStockMovementsInput, VendorUpdateWithoutStockMovementsInput>, VendorUncheckedUpdateWithoutStockMovementsInput>
  }

  export type ProductUpdateOneRequiredWithoutStockMovementsNestedInput = {
    create?: XOR<ProductCreateWithoutStockMovementsInput, ProductUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockMovementsInput
    upsert?: ProductUpsertWithoutStockMovementsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStockMovementsInput, ProductUpdateWithoutStockMovementsInput>, ProductUncheckedUpdateWithoutStockMovementsInput>
  }

  export type ProductVariantUpdateOneWithoutStockMovementsNestedInput = {
    create?: XOR<ProductVariantCreateWithoutStockMovementsInput, ProductVariantUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutStockMovementsInput
    upsert?: ProductVariantUpsertWithoutStockMovementsInput
    disconnect?: ProductVariantWhereInput | boolean
    delete?: ProductVariantWhereInput | boolean
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutStockMovementsInput, ProductVariantUpdateWithoutStockMovementsInput>, ProductVariantUncheckedUpdateWithoutStockMovementsInput>
  }

  export type UserUpdateOneRequiredWithoutStockMovementsNestedInput = {
    create?: XOR<UserCreateWithoutStockMovementsInput, UserUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStockMovementsInput
    upsert?: UserUpsertWithoutStockMovementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStockMovementsInput, UserUpdateWithoutStockMovementsInput>, UserUncheckedUpdateWithoutStockMovementsInput>
  }

  export type VendorCreateNestedOneWithoutStockTakesInput = {
    create?: XOR<VendorCreateWithoutStockTakesInput, VendorUncheckedCreateWithoutStockTakesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutStockTakesInput
    connect?: VendorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStockTakesInput = {
    create?: XOR<UserCreateWithoutStockTakesInput, UserUncheckedCreateWithoutStockTakesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStockTakesInput
    connect?: UserWhereUniqueInput
  }

  export type StockTakeItemCreateNestedManyWithoutStockTakeInput = {
    create?: XOR<StockTakeItemCreateWithoutStockTakeInput, StockTakeItemUncheckedCreateWithoutStockTakeInput> | StockTakeItemCreateWithoutStockTakeInput[] | StockTakeItemUncheckedCreateWithoutStockTakeInput[]
    connectOrCreate?: StockTakeItemCreateOrConnectWithoutStockTakeInput | StockTakeItemCreateOrConnectWithoutStockTakeInput[]
    createMany?: StockTakeItemCreateManyStockTakeInputEnvelope
    connect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
  }

  export type StockTakeItemUncheckedCreateNestedManyWithoutStockTakeInput = {
    create?: XOR<StockTakeItemCreateWithoutStockTakeInput, StockTakeItemUncheckedCreateWithoutStockTakeInput> | StockTakeItemCreateWithoutStockTakeInput[] | StockTakeItemUncheckedCreateWithoutStockTakeInput[]
    connectOrCreate?: StockTakeItemCreateOrConnectWithoutStockTakeInput | StockTakeItemCreateOrConnectWithoutStockTakeInput[]
    createMany?: StockTakeItemCreateManyStockTakeInputEnvelope
    connect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
  }

  export type EnumStockTakeStatusFieldUpdateOperationsInput = {
    set?: $Enums.StockTakeStatus
  }

  export type VendorUpdateOneRequiredWithoutStockTakesNestedInput = {
    create?: XOR<VendorCreateWithoutStockTakesInput, VendorUncheckedCreateWithoutStockTakesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutStockTakesInput
    upsert?: VendorUpsertWithoutStockTakesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutStockTakesInput, VendorUpdateWithoutStockTakesInput>, VendorUncheckedUpdateWithoutStockTakesInput>
  }

  export type UserUpdateOneRequiredWithoutStockTakesNestedInput = {
    create?: XOR<UserCreateWithoutStockTakesInput, UserUncheckedCreateWithoutStockTakesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStockTakesInput
    upsert?: UserUpsertWithoutStockTakesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStockTakesInput, UserUpdateWithoutStockTakesInput>, UserUncheckedUpdateWithoutStockTakesInput>
  }

  export type StockTakeItemUpdateManyWithoutStockTakeNestedInput = {
    create?: XOR<StockTakeItemCreateWithoutStockTakeInput, StockTakeItemUncheckedCreateWithoutStockTakeInput> | StockTakeItemCreateWithoutStockTakeInput[] | StockTakeItemUncheckedCreateWithoutStockTakeInput[]
    connectOrCreate?: StockTakeItemCreateOrConnectWithoutStockTakeInput | StockTakeItemCreateOrConnectWithoutStockTakeInput[]
    upsert?: StockTakeItemUpsertWithWhereUniqueWithoutStockTakeInput | StockTakeItemUpsertWithWhereUniqueWithoutStockTakeInput[]
    createMany?: StockTakeItemCreateManyStockTakeInputEnvelope
    set?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    disconnect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    delete?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    connect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    update?: StockTakeItemUpdateWithWhereUniqueWithoutStockTakeInput | StockTakeItemUpdateWithWhereUniqueWithoutStockTakeInput[]
    updateMany?: StockTakeItemUpdateManyWithWhereWithoutStockTakeInput | StockTakeItemUpdateManyWithWhereWithoutStockTakeInput[]
    deleteMany?: StockTakeItemScalarWhereInput | StockTakeItemScalarWhereInput[]
  }

  export type StockTakeItemUncheckedUpdateManyWithoutStockTakeNestedInput = {
    create?: XOR<StockTakeItemCreateWithoutStockTakeInput, StockTakeItemUncheckedCreateWithoutStockTakeInput> | StockTakeItemCreateWithoutStockTakeInput[] | StockTakeItemUncheckedCreateWithoutStockTakeInput[]
    connectOrCreate?: StockTakeItemCreateOrConnectWithoutStockTakeInput | StockTakeItemCreateOrConnectWithoutStockTakeInput[]
    upsert?: StockTakeItemUpsertWithWhereUniqueWithoutStockTakeInput | StockTakeItemUpsertWithWhereUniqueWithoutStockTakeInput[]
    createMany?: StockTakeItemCreateManyStockTakeInputEnvelope
    set?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    disconnect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    delete?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    connect?: StockTakeItemWhereUniqueInput | StockTakeItemWhereUniqueInput[]
    update?: StockTakeItemUpdateWithWhereUniqueWithoutStockTakeInput | StockTakeItemUpdateWithWhereUniqueWithoutStockTakeInput[]
    updateMany?: StockTakeItemUpdateManyWithWhereWithoutStockTakeInput | StockTakeItemUpdateManyWithWhereWithoutStockTakeInput[]
    deleteMany?: StockTakeItemScalarWhereInput | StockTakeItemScalarWhereInput[]
  }

  export type StockTakeCreateNestedOneWithoutItemsInput = {
    create?: XOR<StockTakeCreateWithoutItemsInput, StockTakeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: StockTakeCreateOrConnectWithoutItemsInput
    connect?: StockTakeWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutStockTakeItemsInput = {
    create?: XOR<ProductCreateWithoutStockTakeItemsInput, ProductUncheckedCreateWithoutStockTakeItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockTakeItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductVariantCreateNestedOneWithoutStockTakeItemsInput = {
    create?: XOR<ProductVariantCreateWithoutStockTakeItemsInput, ProductVariantUncheckedCreateWithoutStockTakeItemsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutStockTakeItemsInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type StockTakeUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<StockTakeCreateWithoutItemsInput, StockTakeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: StockTakeCreateOrConnectWithoutItemsInput
    upsert?: StockTakeUpsertWithoutItemsInput
    connect?: StockTakeWhereUniqueInput
    update?: XOR<XOR<StockTakeUpdateToOneWithWhereWithoutItemsInput, StockTakeUpdateWithoutItemsInput>, StockTakeUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutStockTakeItemsNestedInput = {
    create?: XOR<ProductCreateWithoutStockTakeItemsInput, ProductUncheckedCreateWithoutStockTakeItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockTakeItemsInput
    upsert?: ProductUpsertWithoutStockTakeItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStockTakeItemsInput, ProductUpdateWithoutStockTakeItemsInput>, ProductUncheckedUpdateWithoutStockTakeItemsInput>
  }

  export type ProductVariantUpdateOneWithoutStockTakeItemsNestedInput = {
    create?: XOR<ProductVariantCreateWithoutStockTakeItemsInput, ProductVariantUncheckedCreateWithoutStockTakeItemsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutStockTakeItemsInput
    upsert?: ProductVariantUpsertWithoutStockTakeItemsInput
    disconnect?: ProductVariantWhereInput | boolean
    delete?: ProductVariantWhereInput | boolean
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutStockTakeItemsInput, ProductVariantUpdateWithoutStockTakeItemsInput>, ProductVariantUncheckedUpdateWithoutStockTakeItemsInput>
  }

  export type VendorCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<VendorCreateWithoutNotificationsInput, VendorUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutNotificationsInput
    connect?: VendorWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type VendorUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<VendorCreateWithoutNotificationsInput, VendorUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutNotificationsInput
    upsert?: VendorUpsertWithoutNotificationsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutNotificationsInput, VendorUpdateWithoutNotificationsInput>, VendorUncheckedUpdateWithoutNotificationsInput>
  }

  export type VendorCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<VendorCreateWithoutAuditLogsInput, VendorUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAuditLogsInput
    connect?: VendorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type VendorUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<VendorCreateWithoutAuditLogsInput, VendorUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAuditLogsInput
    upsert?: VendorUpsertWithoutAuditLogsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutAuditLogsInput, VendorUpdateWithoutAuditLogsInput>, VendorUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type VendorCreateNestedOneWithoutSupportTicketsInput = {
    create?: XOR<VendorCreateWithoutSupportTicketsInput, VendorUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutSupportTicketsInput
    connect?: VendorWhereUniqueInput
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type EnumTicketPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TicketPriority
  }

  export type VendorUpdateOneRequiredWithoutSupportTicketsNestedInput = {
    create?: XOR<VendorCreateWithoutSupportTicketsInput, VendorUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutSupportTicketsInput
    upsert?: VendorUpsertWithoutSupportTicketsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutSupportTicketsInput, VendorUpdateWithoutSupportTicketsInput>, VendorUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type VendorCreateNestedOneWithoutReportsInput = {
    create?: XOR<VendorCreateWithoutReportsInput, VendorUncheckedCreateWithoutReportsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutReportsInput
    connect?: VendorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportsInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReportTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReportType
  }

  export type EnumReportPeriodFieldUpdateOperationsInput = {
    set?: $Enums.ReportPeriod
  }

  export type VendorUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<VendorCreateWithoutReportsInput, VendorUncheckedCreateWithoutReportsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutReportsInput
    upsert?: VendorUpsertWithoutReportsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutReportsInput, VendorUpdateWithoutReportsInput>, VendorUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    upsert?: UserUpsertWithoutReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsInput, UserUpdateWithoutReportsInput>, UserUncheckedUpdateWithoutReportsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[]
    notIn?: $Enums.SubscriptionStatus[]
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[]
    notIn?: $Enums.SubscriptionStatus[]
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumSaleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SaleStatus | EnumSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SaleStatus[]
    notIn?: $Enums.SaleStatus[]
    not?: NestedEnumSaleStatusFilter<$PrismaModel> | $Enums.SaleStatus
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumSaleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SaleStatus | EnumSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SaleStatus[]
    notIn?: $Enums.SaleStatus[]
    not?: NestedEnumSaleStatusWithAggregatesFilter<$PrismaModel> | $Enums.SaleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSaleStatusFilter<$PrismaModel>
    _max?: NestedEnumSaleStatusFilter<$PrismaModel>
  }

  export type NestedEnumPurchaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[]
    notIn?: $Enums.PurchaseStatus[]
    not?: NestedEnumPurchaseStatusFilter<$PrismaModel> | $Enums.PurchaseStatus
  }

  export type NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[]
    notIn?: $Enums.PurchaseStatus[]
    not?: NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseStatusFilter<$PrismaModel>
  }

  export type NestedEnumStockMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StockMovementType | EnumStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockMovementType[]
    notIn?: $Enums.StockMovementType[]
    not?: NestedEnumStockMovementTypeFilter<$PrismaModel> | $Enums.StockMovementType
  }

  export type NestedEnumStockMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockMovementType | EnumStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockMovementType[]
    notIn?: $Enums.StockMovementType[]
    not?: NestedEnumStockMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.StockMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumStockMovementTypeFilter<$PrismaModel>
  }

  export type NestedEnumStockTakeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StockTakeStatus | EnumStockTakeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StockTakeStatus[]
    notIn?: $Enums.StockTakeStatus[]
    not?: NestedEnumStockTakeStatusFilter<$PrismaModel> | $Enums.StockTakeStatus
  }

  export type NestedEnumStockTakeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockTakeStatus | EnumStockTakeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StockTakeStatus[]
    notIn?: $Enums.StockTakeStatus[]
    not?: NestedEnumStockTakeStatusWithAggregatesFilter<$PrismaModel> | $Enums.StockTakeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockTakeStatusFilter<$PrismaModel>
    _max?: NestedEnumStockTakeStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[]
    notIn?: $Enums.TicketStatus[]
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedEnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[]
    notIn?: $Enums.TicketPriority[]
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[]
    notIn?: $Enums.TicketStatus[]
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[]
    notIn?: $Enums.TicketPriority[]
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type NestedEnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[]
    notIn?: $Enums.ReportType[]
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type NestedEnumReportPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportPeriod | EnumReportPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.ReportPeriod[]
    notIn?: $Enums.ReportPeriod[]
    not?: NestedEnumReportPeriodFilter<$PrismaModel> | $Enums.ReportPeriod
  }

  export type NestedEnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[]
    notIn?: $Enums.ReportType[]
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type NestedEnumReportPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportPeriod | EnumReportPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.ReportPeriod[]
    notIn?: $Enums.ReportPeriod[]
    not?: NestedEnumReportPeriodWithAggregatesFilter<$PrismaModel> | $Enums.ReportPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportPeriodFilter<$PrismaModel>
    _max?: NestedEnumReportPeriodFilter<$PrismaModel>
  }

  export type UserCreateWithoutVendorInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashierSchedule?: CashierScheduleCreateNestedOneWithoutUserInput
    sales?: SaleCreateNestedManyWithoutCashierInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    stockTakes?: StockTakeCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratorInput
    productAssignments?: CashierProductAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVendorInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashierSchedule?: CashierScheduleUncheckedCreateNestedOneWithoutUserInput
    sales?: SaleUncheckedCreateNestedManyWithoutCashierInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratorInput
    productAssignments?: CashierProductAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVendorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput>
  }

  export type UserCreateManyVendorInputEnvelope = {
    data: UserCreateManyVendorInput | UserCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutVendorInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ProductVariantCreateNestedManyWithoutProductInput
    stockLocations?: ProductStockLocationCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    stockTakeItems?: StockTakeItemCreateNestedManyWithoutProductInput
    cashierAssignments?: CashierProductAssignmentCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutVendorInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    stockLocations?: ProductStockLocationUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    stockTakeItems?: StockTakeItemUncheckedCreateNestedManyWithoutProductInput
    cashierAssignments?: CashierProductAssignmentUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutVendorInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput>
  }

  export type ProductCreateManyVendorInputEnvelope = {
    data: ProductCreateManyVendorInput | ProductCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutVendorInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    visitCount?: number
    lastVisit?: Date | string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutVendorInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    visitCount?: number
    lastVisit?: Date | string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutVendorInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutVendorInput, CustomerUncheckedCreateWithoutVendorInput>
  }

  export type CustomerCreateManyVendorInputEnvelope = {
    data: CustomerCreateManyVendorInput | CustomerCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type SaleCreateWithoutVendorInput = {
    id?: string
    terminalId: string
    receiptNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paid: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.SaleStatus
    refundAmount?: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsUsed?: number
    notes?: string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    cashier: UserCreateNestedOneWithoutSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutVendorInput = {
    id?: string
    cashierId: string
    terminalId: string
    customerId?: string | null
    receiptNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paid: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.SaleStatus
    refundAmount?: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsUsed?: number
    notes?: string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutVendorInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutVendorInput, SaleUncheckedCreateWithoutVendorInput>
  }

  export type SaleCreateManyVendorInputEnvelope = {
    data: SaleCreateManyVendorInput | SaleCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type SupplierCreateWithoutVendorInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    paymentTerms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchaseCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutVendorInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    paymentTerms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchaseUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutVendorInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutVendorInput, SupplierUncheckedCreateWithoutVendorInput>
  }

  export type SupplierCreateManyVendorInputEnvelope = {
    data: SupplierCreateManyVendorInput | SupplierCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseCreateWithoutVendorInput = {
    id?: string
    purchaseNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchasesInput
    items?: PurchaseItemCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutVendorInput = {
    id?: string
    supplierId: string
    purchaseNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutVendorInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutVendorInput, PurchaseUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseCreateManyVendorInputEnvelope = {
    data: PurchaseCreateManyVendorInput | PurchaseCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type StockMovementCreateWithoutVendorInput = {
    id?: string
    movementType: $Enums.StockMovementType
    quantity: number
    referenceType?: string | null
    referenceId?: string | null
    referenceNumber?: string | null
    locationFrom?: string | null
    locationTo?: string | null
    notes?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutStockMovementsInput
    variant?: ProductVariantCreateNestedOneWithoutStockMovementsInput
    creator: UserCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateWithoutVendorInput = {
    id?: string
    productId: string
    variantId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    referenceType?: string | null
    referenceId?: string | null
    referenceNumber?: string | null
    locationFrom?: string | null
    locationTo?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutVendorInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutVendorInput, StockMovementUncheckedCreateWithoutVendorInput>
  }

  export type StockMovementCreateManyVendorInputEnvelope = {
    data: StockMovementCreateManyVendorInput | StockMovementCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type StockTakeCreateWithoutVendorInput = {
    id?: string
    location: string
    status?: $Enums.StockTakeStatus
    notes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutStockTakesInput
    items?: StockTakeItemCreateNestedManyWithoutStockTakeInput
  }

  export type StockTakeUncheckedCreateWithoutVendorInput = {
    id?: string
    location: string
    status?: $Enums.StockTakeStatus
    notes?: string | null
    createdBy: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: StockTakeItemUncheckedCreateNestedManyWithoutStockTakeInput
  }

  export type StockTakeCreateOrConnectWithoutVendorInput = {
    where: StockTakeWhereUniqueInput
    create: XOR<StockTakeCreateWithoutVendorInput, StockTakeUncheckedCreateWithoutVendorInput>
  }

  export type StockTakeCreateManyVendorInputEnvelope = {
    data: StockTakeCreateManyVendorInput | StockTakeCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutVendorInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutVendorInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutVendorInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutVendorInput, NotificationUncheckedCreateWithoutVendorInput>
  }

  export type NotificationCreateManyVendorInputEnvelope = {
    data: NotificationCreateManyVendorInput | NotificationCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutVendorInput = {
    id?: string
    action: string
    resource: string
    resourceId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutVendorInput = {
    id?: string
    userId: string
    action: string
    resource: string
    resourceId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutVendorInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutVendorInput, AuditLogUncheckedCreateWithoutVendorInput>
  }

  export type AuditLogCreateManyVendorInputEnvelope = {
    data: AuditLogCreateManyVendorInput | AuditLogCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutVendorInput = {
    id?: string
    vendorName: string
    subject: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketUncheckedCreateWithoutVendorInput = {
    id?: string
    vendorName: string
    subject: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateOrConnectWithoutVendorInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutVendorInput, SupportTicketUncheckedCreateWithoutVendorInput>
  }

  export type SupportTicketCreateManyVendorInputEnvelope = {
    data: SupportTicketCreateManyVendorInput | SupportTicketCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutVendorInput = {
    id?: string
    type: $Enums.ReportType
    period: $Enums.ReportPeriod
    startDate: Date | string
    endDate: Date | string
    data: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    generator: UserCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutVendorInput = {
    id?: string
    type: $Enums.ReportType
    period: $Enums.ReportPeriod
    startDate: Date | string
    endDate: Date | string
    data: JsonNullValueInput | InputJsonValue
    generatedBy: string
    generatedAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutVendorInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutVendorInput, ReportUncheckedCreateWithoutVendorInput>
  }

  export type ReportCreateManyVendorInputEnvelope = {
    data: ReportCreateManyVendorInput | ReportCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VendorSettingsCreateWithoutVendorInput = {
    id?: string
    taxRate?: Decimal | DecimalJsLike | number | string
    currency?: string
    timezone?: string
    receiptHeader?: string | null
    receiptFooter?: string | null
    loyaltyEnabled?: boolean
    loyaltyPointsPerDollar?: Decimal | DecimalJsLike | number | string
    loyaltyRedemptionRate?: Decimal | DecimalJsLike | number | string
    loyaltyMinimumPoints?: number
    lowStockAlert?: boolean
    lowStockThreshold?: number
    emailNotifications?: boolean
    smsNotifications?: boolean
    dailyReports?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorSettingsUncheckedCreateWithoutVendorInput = {
    id?: string
    taxRate?: Decimal | DecimalJsLike | number | string
    currency?: string
    timezone?: string
    receiptHeader?: string | null
    receiptFooter?: string | null
    loyaltyEnabled?: boolean
    loyaltyPointsPerDollar?: Decimal | DecimalJsLike | number | string
    loyaltyRedemptionRate?: Decimal | DecimalJsLike | number | string
    loyaltyMinimumPoints?: number
    lowStockAlert?: boolean
    lowStockThreshold?: number
    emailNotifications?: boolean
    smsNotifications?: boolean
    dailyReports?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorSettingsCreateOrConnectWithoutVendorInput = {
    where: VendorSettingsWhereUniqueInput
    create: XOR<VendorSettingsCreateWithoutVendorInput, VendorSettingsUncheckedCreateWithoutVendorInput>
  }

  export type UserUpsertWithWhereUniqueWithoutVendorInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutVendorInput, UserUncheckedUpdateWithoutVendorInput>
    create: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput>
  }

  export type UserUpdateWithWhereUniqueWithoutVendorInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutVendorInput, UserUncheckedUpdateWithoutVendorInput>
  }

  export type UserUpdateManyWithWhereWithoutVendorInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutVendorInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    vendorId?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    terminalId?: StringNullableFilter<"User"> | string | null
    assignedLocations?: JsonNullableFilter<"User">
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutVendorInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutVendorInput, ProductUncheckedUpdateWithoutVendorInput>
    create: XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutVendorInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutVendorInput, ProductUncheckedUpdateWithoutVendorInput>
  }

  export type ProductUpdateManyWithWhereWithoutVendorInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutVendorInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    vendorId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    sku?: StringFilter<"Product"> | string
    barcode?: StringNullableFilter<"Product"> | string | null
    category?: StringNullableFilter<"Product"> | string | null
    brand?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    totalStock?: IntFilter<"Product"> | number
    minStock?: IntFilter<"Product"> | number
    maxStock?: IntFilter<"Product"> | number
    unit?: StringFilter<"Product"> | string
    images?: JsonNullableFilter<"Product">
    isActive?: BoolFilter<"Product"> | boolean
    expiryDate?: DateTimeNullableFilter<"Product"> | Date | string | null
    trackExpiry?: BoolFilter<"Product"> | boolean
    trackSerial?: BoolFilter<"Product"> | boolean
    tags?: JsonNullableFilter<"Product">
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type CustomerUpsertWithWhereUniqueWithoutVendorInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutVendorInput, CustomerUncheckedUpdateWithoutVendorInput>
    create: XOR<CustomerCreateWithoutVendorInput, CustomerUncheckedCreateWithoutVendorInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutVendorInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutVendorInput, CustomerUncheckedUpdateWithoutVendorInput>
  }

  export type CustomerUpdateManyWithWhereWithoutVendorInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutVendorInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: StringFilter<"Customer"> | string
    vendorId?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Customer"> | Date | string | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    totalSpent?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    visitCount?: IntFilter<"Customer"> | number
    lastVisit?: DateTimeNullableFilter<"Customer"> | Date | string | null
    isActive?: BoolFilter<"Customer"> | boolean
    notes?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
  }

  export type SaleUpsertWithWhereUniqueWithoutVendorInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutVendorInput, SaleUncheckedUpdateWithoutVendorInput>
    create: XOR<SaleCreateWithoutVendorInput, SaleUncheckedCreateWithoutVendorInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutVendorInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutVendorInput, SaleUncheckedUpdateWithoutVendorInput>
  }

  export type SaleUpdateManyWithWhereWithoutVendorInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutVendorInput>
  }

  export type SaleScalarWhereInput = {
    AND?: SaleScalarWhereInput | SaleScalarWhereInput[]
    OR?: SaleScalarWhereInput[]
    NOT?: SaleScalarWhereInput | SaleScalarWhereInput[]
    id?: StringFilter<"Sale"> | string
    vendorId?: StringFilter<"Sale"> | string
    cashierId?: StringFilter<"Sale"> | string
    terminalId?: StringFilter<"Sale"> | string
    customerId?: StringNullableFilter<"Sale"> | string | null
    receiptNumber?: StringFilter<"Sale"> | string
    subtotal?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    paid?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Sale"> | $Enums.PaymentMethod
    status?: EnumSaleStatusFilter<"Sale"> | $Enums.SaleStatus
    refundAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFilter<"Sale"> | number
    loyaltyPointsUsed?: IntFilter<"Sale"> | number
    notes?: StringNullableFilter<"Sale"> | string | null
    receiptData?: JsonNullableFilter<"Sale">
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
  }

  export type SupplierUpsertWithWhereUniqueWithoutVendorInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutVendorInput, SupplierUncheckedUpdateWithoutVendorInput>
    create: XOR<SupplierCreateWithoutVendorInput, SupplierUncheckedCreateWithoutVendorInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutVendorInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutVendorInput, SupplierUncheckedUpdateWithoutVendorInput>
  }

  export type SupplierUpdateManyWithWhereWithoutVendorInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutVendorInput>
  }

  export type SupplierScalarWhereInput = {
    AND?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    OR?: SupplierScalarWhereInput[]
    NOT?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    id?: StringFilter<"Supplier"> | string
    vendorId?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    paymentTerms?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
  }

  export type PurchaseUpsertWithWhereUniqueWithoutVendorInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutVendorInput, PurchaseUncheckedUpdateWithoutVendorInput>
    create: XOR<PurchaseCreateWithoutVendorInput, PurchaseUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutVendorInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutVendorInput, PurchaseUncheckedUpdateWithoutVendorInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutVendorInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutVendorInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: StringFilter<"Purchase"> | string
    vendorId?: StringFilter<"Purchase"> | string
    supplierId?: StringFilter<"Purchase"> | string
    purchaseNumber?: StringFilter<"Purchase"> | string
    subtotal?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFilter<"Purchase"> | $Enums.PurchaseStatus
    deliveryDate?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    notes?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
  }

  export type StockMovementUpsertWithWhereUniqueWithoutVendorInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutVendorInput, StockMovementUncheckedUpdateWithoutVendorInput>
    create: XOR<StockMovementCreateWithoutVendorInput, StockMovementUncheckedCreateWithoutVendorInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutVendorInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutVendorInput, StockMovementUncheckedUpdateWithoutVendorInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutVendorInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutVendorInput>
  }

  export type StockMovementScalarWhereInput = {
    AND?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    OR?: StockMovementScalarWhereInput[]
    NOT?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    id?: StringFilter<"StockMovement"> | string
    vendorId?: StringFilter<"StockMovement"> | string
    productId?: StringFilter<"StockMovement"> | string
    variantId?: StringNullableFilter<"StockMovement"> | string | null
    movementType?: EnumStockMovementTypeFilter<"StockMovement"> | $Enums.StockMovementType
    quantity?: IntFilter<"StockMovement"> | number
    referenceType?: StringNullableFilter<"StockMovement"> | string | null
    referenceId?: StringNullableFilter<"StockMovement"> | string | null
    referenceNumber?: StringNullableFilter<"StockMovement"> | string | null
    locationFrom?: StringNullableFilter<"StockMovement"> | string | null
    locationTo?: StringNullableFilter<"StockMovement"> | string | null
    notes?: StringNullableFilter<"StockMovement"> | string | null
    createdBy?: StringFilter<"StockMovement"> | string
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
  }

  export type StockTakeUpsertWithWhereUniqueWithoutVendorInput = {
    where: StockTakeWhereUniqueInput
    update: XOR<StockTakeUpdateWithoutVendorInput, StockTakeUncheckedUpdateWithoutVendorInput>
    create: XOR<StockTakeCreateWithoutVendorInput, StockTakeUncheckedCreateWithoutVendorInput>
  }

  export type StockTakeUpdateWithWhereUniqueWithoutVendorInput = {
    where: StockTakeWhereUniqueInput
    data: XOR<StockTakeUpdateWithoutVendorInput, StockTakeUncheckedUpdateWithoutVendorInput>
  }

  export type StockTakeUpdateManyWithWhereWithoutVendorInput = {
    where: StockTakeScalarWhereInput
    data: XOR<StockTakeUpdateManyMutationInput, StockTakeUncheckedUpdateManyWithoutVendorInput>
  }

  export type StockTakeScalarWhereInput = {
    AND?: StockTakeScalarWhereInput | StockTakeScalarWhereInput[]
    OR?: StockTakeScalarWhereInput[]
    NOT?: StockTakeScalarWhereInput | StockTakeScalarWhereInput[]
    id?: StringFilter<"StockTake"> | string
    vendorId?: StringFilter<"StockTake"> | string
    location?: StringFilter<"StockTake"> | string
    status?: EnumStockTakeStatusFilter<"StockTake"> | $Enums.StockTakeStatus
    notes?: StringNullableFilter<"StockTake"> | string | null
    createdBy?: StringFilter<"StockTake"> | string
    completedAt?: DateTimeNullableFilter<"StockTake"> | Date | string | null
    createdAt?: DateTimeFilter<"StockTake"> | Date | string
    updatedAt?: DateTimeFilter<"StockTake"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutVendorInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutVendorInput, NotificationUncheckedUpdateWithoutVendorInput>
    create: XOR<NotificationCreateWithoutVendorInput, NotificationUncheckedCreateWithoutVendorInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutVendorInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutVendorInput, NotificationUncheckedUpdateWithoutVendorInput>
  }

  export type NotificationUpdateManyWithWhereWithoutVendorInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutVendorInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    vendorId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutVendorInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutVendorInput, AuditLogUncheckedUpdateWithoutVendorInput>
    create: XOR<AuditLogCreateWithoutVendorInput, AuditLogUncheckedCreateWithoutVendorInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutVendorInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutVendorInput, AuditLogUncheckedUpdateWithoutVendorInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutVendorInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutVendorInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    vendorId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringFilter<"AuditLog"> | string
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutVendorInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutVendorInput, SupportTicketUncheckedUpdateWithoutVendorInput>
    create: XOR<SupportTicketCreateWithoutVendorInput, SupportTicketUncheckedCreateWithoutVendorInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutVendorInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutVendorInput, SupportTicketUncheckedUpdateWithoutVendorInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutVendorInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutVendorInput>
  }

  export type SupportTicketScalarWhereInput = {
    AND?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    OR?: SupportTicketScalarWhereInput[]
    NOT?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    vendorId?: StringFilter<"SupportTicket"> | string
    vendorName?: StringFilter<"SupportTicket"> | string
    subject?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: EnumTicketStatusFilter<"SupportTicket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"SupportTicket"> | $Enums.TicketPriority
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutVendorInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutVendorInput, ReportUncheckedUpdateWithoutVendorInput>
    create: XOR<ReportCreateWithoutVendorInput, ReportUncheckedCreateWithoutVendorInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutVendorInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutVendorInput, ReportUncheckedUpdateWithoutVendorInput>
  }

  export type ReportUpdateManyWithWhereWithoutVendorInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutVendorInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    vendorId?: StringFilter<"Report"> | string
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    period?: EnumReportPeriodFilter<"Report"> | $Enums.ReportPeriod
    startDate?: DateTimeFilter<"Report"> | Date | string
    endDate?: DateTimeFilter<"Report"> | Date | string
    data?: JsonFilter<"Report">
    generatedBy?: StringFilter<"Report"> | string
    generatedAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type VendorSettingsUpsertWithoutVendorInput = {
    update: XOR<VendorSettingsUpdateWithoutVendorInput, VendorSettingsUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorSettingsCreateWithoutVendorInput, VendorSettingsUncheckedCreateWithoutVendorInput>
    where?: VendorSettingsWhereInput
  }

  export type VendorSettingsUpdateToOneWithWhereWithoutVendorInput = {
    where?: VendorSettingsWhereInput
    data: XOR<VendorSettingsUpdateWithoutVendorInput, VendorSettingsUncheckedUpdateWithoutVendorInput>
  }

  export type VendorSettingsUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    receiptHeader?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFooter?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyEnabled?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPointsPerDollar?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyRedemptionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyMinimumPoints?: IntFieldUpdateOperationsInput | number
    lowStockAlert?: BoolFieldUpdateOperationsInput | boolean
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    dailyReports?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorSettingsUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    receiptHeader?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFooter?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyEnabled?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPointsPerDollar?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyRedemptionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyMinimumPoints?: IntFieldUpdateOperationsInput | number
    lowStockAlert?: BoolFieldUpdateOperationsInput | boolean
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    dailyReports?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateWithoutVendorSettingsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutVendorInput
    products?: ProductCreateNestedManyWithoutVendorInput
    customers?: CustomerCreateNestedManyWithoutVendorInput
    sales?: SaleCreateNestedManyWithoutVendorInput
    suppliers?: SupplierCreateNestedManyWithoutVendorInput
    purchases?: PurchaseCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeCreateNestedManyWithoutVendorInput
    notifications?: NotificationCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketCreateNestedManyWithoutVendorInput
    reports?: ReportCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutVendorSettingsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    customers?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    sales?: SaleUncheckedCreateNestedManyWithoutVendorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutVendorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutVendorInput
    reports?: ReportUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutVendorSettingsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutVendorSettingsInput, VendorUncheckedCreateWithoutVendorSettingsInput>
  }

  export type VendorUpsertWithoutVendorSettingsInput = {
    update: XOR<VendorUpdateWithoutVendorSettingsInput, VendorUncheckedUpdateWithoutVendorSettingsInput>
    create: XOR<VendorCreateWithoutVendorSettingsInput, VendorUncheckedCreateWithoutVendorSettingsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutVendorSettingsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutVendorSettingsInput, VendorUncheckedUpdateWithoutVendorSettingsInput>
  }

  export type VendorUpdateWithoutVendorSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutVendorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
    customers?: CustomerUpdateManyWithoutVendorNestedInput
    sales?: SaleUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutVendorNestedInput
    reports?: ReportUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutVendorSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutVendorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutVendorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateWithoutUsersInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutVendorInput
    customers?: CustomerCreateNestedManyWithoutVendorInput
    sales?: SaleCreateNestedManyWithoutVendorInput
    suppliers?: SupplierCreateNestedManyWithoutVendorInput
    purchases?: PurchaseCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeCreateNestedManyWithoutVendorInput
    notifications?: NotificationCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketCreateNestedManyWithoutVendorInput
    reports?: ReportCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    customers?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    sales?: SaleUncheckedCreateNestedManyWithoutVendorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutVendorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutVendorInput
    reports?: ReportUncheckedCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutUsersInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutUsersInput, VendorUncheckedCreateWithoutUsersInput>
  }

  export type CashierScheduleCreateWithoutUserInput = {
    id?: string
    checkInTime: string
    checkOutTime: string
    workDays: JsonNullValueInput | InputJsonValue
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashierScheduleUncheckedCreateWithoutUserInput = {
    id?: string
    checkInTime: string
    checkOutTime: string
    workDays: JsonNullValueInput | InputJsonValue
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashierScheduleCreateOrConnectWithoutUserInput = {
    where: CashierScheduleWhereUniqueInput
    create: XOR<CashierScheduleCreateWithoutUserInput, CashierScheduleUncheckedCreateWithoutUserInput>
  }

  export type SaleCreateWithoutCashierInput = {
    id?: string
    terminalId: string
    receiptNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paid: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.SaleStatus
    refundAmount?: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsUsed?: number
    notes?: string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutCashierInput = {
    id?: string
    vendorId: string
    terminalId: string
    customerId?: string | null
    receiptNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paid: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.SaleStatus
    refundAmount?: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsUsed?: number
    notes?: string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutCashierInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutCashierInput, SaleUncheckedCreateWithoutCashierInput>
  }

  export type SaleCreateManyCashierInputEnvelope = {
    data: SaleCreateManyCashierInput | SaleCreateManyCashierInput[]
    skipDuplicates?: boolean
  }

  export type StockMovementCreateWithoutCreatorInput = {
    id?: string
    movementType: $Enums.StockMovementType
    quantity: number
    referenceType?: string | null
    referenceId?: string | null
    referenceNumber?: string | null
    locationFrom?: string | null
    locationTo?: string | null
    notes?: string | null
    createdAt?: Date | string
    vendor: VendorCreateNestedOneWithoutStockMovementsInput
    product: ProductCreateNestedOneWithoutStockMovementsInput
    variant?: ProductVariantCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateWithoutCreatorInput = {
    id?: string
    vendorId: string
    productId: string
    variantId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    referenceType?: string | null
    referenceId?: string | null
    referenceNumber?: string | null
    locationFrom?: string | null
    locationTo?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutCreatorInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutCreatorInput, StockMovementUncheckedCreateWithoutCreatorInput>
  }

  export type StockMovementCreateManyCreatorInputEnvelope = {
    data: StockMovementCreateManyCreatorInput | StockMovementCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type StockTakeCreateWithoutCreatorInput = {
    id?: string
    location: string
    status?: $Enums.StockTakeStatus
    notes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutStockTakesInput
    items?: StockTakeItemCreateNestedManyWithoutStockTakeInput
  }

  export type StockTakeUncheckedCreateWithoutCreatorInput = {
    id?: string
    vendorId: string
    location: string
    status?: $Enums.StockTakeStatus
    notes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: StockTakeItemUncheckedCreateNestedManyWithoutStockTakeInput
  }

  export type StockTakeCreateOrConnectWithoutCreatorInput = {
    where: StockTakeWhereUniqueInput
    create: XOR<StockTakeCreateWithoutCreatorInput, StockTakeUncheckedCreateWithoutCreatorInput>
  }

  export type StockTakeCreateManyCreatorInputEnvelope = {
    data: StockTakeCreateManyCreatorInput | StockTakeCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    resourceId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    vendor: VendorCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    vendorId: string
    action: string
    resource: string
    resourceId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutGeneratorInput = {
    id?: string
    type: $Enums.ReportType
    period: $Enums.ReportPeriod
    startDate: Date | string
    endDate: Date | string
    data: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutGeneratorInput = {
    id?: string
    vendorId: string
    type: $Enums.ReportType
    period: $Enums.ReportPeriod
    startDate: Date | string
    endDate: Date | string
    data: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutGeneratorInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutGeneratorInput, ReportUncheckedCreateWithoutGeneratorInput>
  }

  export type ReportCreateManyGeneratorInputEnvelope = {
    data: ReportCreateManyGeneratorInput | ReportCreateManyGeneratorInput[]
    skipDuplicates?: boolean
  }

  export type CashierProductAssignmentCreateWithoutUserInput = {
    id?: string
    assignedAt?: Date | string
    product: ProductCreateNestedOneWithoutCashierAssignmentsInput
  }

  export type CashierProductAssignmentUncheckedCreateWithoutUserInput = {
    id?: string
    productId: string
    assignedAt?: Date | string
  }

  export type CashierProductAssignmentCreateOrConnectWithoutUserInput = {
    where: CashierProductAssignmentWhereUniqueInput
    create: XOR<CashierProductAssignmentCreateWithoutUserInput, CashierProductAssignmentUncheckedCreateWithoutUserInput>
  }

  export type CashierProductAssignmentCreateManyUserInputEnvelope = {
    data: CashierProductAssignmentCreateManyUserInput | CashierProductAssignmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutUsersInput = {
    update: XOR<VendorUpdateWithoutUsersInput, VendorUncheckedUpdateWithoutUsersInput>
    create: XOR<VendorCreateWithoutUsersInput, VendorUncheckedCreateWithoutUsersInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutUsersInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutUsersInput, VendorUncheckedUpdateWithoutUsersInput>
  }

  export type VendorUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutVendorNestedInput
    customers?: CustomerUpdateManyWithoutVendorNestedInput
    sales?: SaleUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutVendorNestedInput
    reports?: ReportUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutVendorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutVendorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type CashierScheduleUpsertWithoutUserInput = {
    update: XOR<CashierScheduleUpdateWithoutUserInput, CashierScheduleUncheckedUpdateWithoutUserInput>
    create: XOR<CashierScheduleCreateWithoutUserInput, CashierScheduleUncheckedCreateWithoutUserInput>
    where?: CashierScheduleWhereInput
  }

  export type CashierScheduleUpdateToOneWithWhereWithoutUserInput = {
    where?: CashierScheduleWhereInput
    data: XOR<CashierScheduleUpdateWithoutUserInput, CashierScheduleUncheckedUpdateWithoutUserInput>
  }

  export type CashierScheduleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    workDays?: JsonNullValueInput | InputJsonValue
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierScheduleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    workDays?: JsonNullValueInput | InputJsonValue
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUpsertWithWhereUniqueWithoutCashierInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutCashierInput, SaleUncheckedUpdateWithoutCashierInput>
    create: XOR<SaleCreateWithoutCashierInput, SaleUncheckedCreateWithoutCashierInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutCashierInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutCashierInput, SaleUncheckedUpdateWithoutCashierInput>
  }

  export type SaleUpdateManyWithWhereWithoutCashierInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutCashierInput>
  }

  export type StockMovementUpsertWithWhereUniqueWithoutCreatorInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutCreatorInput, StockMovementUncheckedUpdateWithoutCreatorInput>
    create: XOR<StockMovementCreateWithoutCreatorInput, StockMovementUncheckedCreateWithoutCreatorInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutCreatorInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutCreatorInput, StockMovementUncheckedUpdateWithoutCreatorInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutCreatorInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutCreatorInput>
  }

  export type StockTakeUpsertWithWhereUniqueWithoutCreatorInput = {
    where: StockTakeWhereUniqueInput
    update: XOR<StockTakeUpdateWithoutCreatorInput, StockTakeUncheckedUpdateWithoutCreatorInput>
    create: XOR<StockTakeCreateWithoutCreatorInput, StockTakeUncheckedCreateWithoutCreatorInput>
  }

  export type StockTakeUpdateWithWhereUniqueWithoutCreatorInput = {
    where: StockTakeWhereUniqueInput
    data: XOR<StockTakeUpdateWithoutCreatorInput, StockTakeUncheckedUpdateWithoutCreatorInput>
  }

  export type StockTakeUpdateManyWithWhereWithoutCreatorInput = {
    where: StockTakeScalarWhereInput
    data: XOR<StockTakeUpdateManyMutationInput, StockTakeUncheckedUpdateManyWithoutCreatorInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutGeneratorInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutGeneratorInput, ReportUncheckedUpdateWithoutGeneratorInput>
    create: XOR<ReportCreateWithoutGeneratorInput, ReportUncheckedCreateWithoutGeneratorInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutGeneratorInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutGeneratorInput, ReportUncheckedUpdateWithoutGeneratorInput>
  }

  export type ReportUpdateManyWithWhereWithoutGeneratorInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutGeneratorInput>
  }

  export type CashierProductAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: CashierProductAssignmentWhereUniqueInput
    update: XOR<CashierProductAssignmentUpdateWithoutUserInput, CashierProductAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<CashierProductAssignmentCreateWithoutUserInput, CashierProductAssignmentUncheckedCreateWithoutUserInput>
  }

  export type CashierProductAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: CashierProductAssignmentWhereUniqueInput
    data: XOR<CashierProductAssignmentUpdateWithoutUserInput, CashierProductAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type CashierProductAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: CashierProductAssignmentScalarWhereInput
    data: XOR<CashierProductAssignmentUpdateManyMutationInput, CashierProductAssignmentUncheckedUpdateManyWithoutUserInput>
  }

  export type CashierProductAssignmentScalarWhereInput = {
    AND?: CashierProductAssignmentScalarWhereInput | CashierProductAssignmentScalarWhereInput[]
    OR?: CashierProductAssignmentScalarWhereInput[]
    NOT?: CashierProductAssignmentScalarWhereInput | CashierProductAssignmentScalarWhereInput[]
    id?: StringFilter<"CashierProductAssignment"> | string
    userId?: StringFilter<"CashierProductAssignment"> | string
    productId?: StringFilter<"CashierProductAssignment"> | string
    assignedAt?: DateTimeFilter<"CashierProductAssignment"> | Date | string
  }

  export type UserCreateWithoutCashierScheduleInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutUsersInput
    sales?: SaleCreateNestedManyWithoutCashierInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    stockTakes?: StockTakeCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratorInput
    productAssignments?: CashierProductAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCashierScheduleInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    vendorId?: string | null
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutCashierInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratorInput
    productAssignments?: CashierProductAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCashierScheduleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCashierScheduleInput, UserUncheckedCreateWithoutCashierScheduleInput>
  }

  export type UserUpsertWithoutCashierScheduleInput = {
    update: XOR<UserUpdateWithoutCashierScheduleInput, UserUncheckedUpdateWithoutCashierScheduleInput>
    create: XOR<UserCreateWithoutCashierScheduleInput, UserUncheckedCreateWithoutCashierScheduleInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCashierScheduleInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCashierScheduleInput, UserUncheckedUpdateWithoutCashierScheduleInput>
  }

  export type UserUpdateWithoutCashierScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutUsersNestedInput
    sales?: SaleUpdateManyWithoutCashierNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratorNestedInput
    productAssignments?: CashierProductAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCashierScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutCashierNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratorNestedInput
    productAssignments?: CashierProductAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VendorCreateWithoutProductsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutVendorInput
    customers?: CustomerCreateNestedManyWithoutVendorInput
    sales?: SaleCreateNestedManyWithoutVendorInput
    suppliers?: SupplierCreateNestedManyWithoutVendorInput
    purchases?: PurchaseCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeCreateNestedManyWithoutVendorInput
    notifications?: NotificationCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketCreateNestedManyWithoutVendorInput
    reports?: ReportCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    customers?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    sales?: SaleUncheckedCreateNestedManyWithoutVendorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutVendorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutVendorInput
    reports?: ReportUncheckedCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutProductsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutProductsInput, VendorUncheckedCreateWithoutProductsInput>
  }

  export type ProductVariantCreateWithoutProductInput = {
    id?: string
    name: string
    value: string
    priceModifier?: Decimal | DecimalJsLike | number | string
    stock?: number
    sku: string
    barcode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockLocations?: ProductStockLocationCreateNestedManyWithoutVariantInput
    saleItems?: SaleItemCreateNestedManyWithoutVariantInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutVariantInput
    stockMovements?: StockMovementCreateNestedManyWithoutVariantInput
    stockTakeItems?: StockTakeItemCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    value: string
    priceModifier?: Decimal | DecimalJsLike | number | string
    stock?: number
    sku: string
    barcode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockLocations?: ProductStockLocationUncheckedCreateNestedManyWithoutVariantInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutVariantInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutVariantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVariantInput
    stockTakeItems?: StockTakeItemUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
  }

  export type ProductVariantCreateManyProductInputEnvelope = {
    data: ProductVariantCreateManyProductInput | ProductVariantCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductStockLocationCreateWithoutProductInput = {
    id?: string
    locationName: string
    quantity?: number
    reservedQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    variant?: ProductVariantCreateNestedOneWithoutStockLocationsInput
  }

  export type ProductStockLocationUncheckedCreateWithoutProductInput = {
    id?: string
    variantId?: string | null
    locationName: string
    quantity?: number
    reservedQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductStockLocationCreateOrConnectWithoutProductInput = {
    where: ProductStockLocationWhereUniqueInput
    create: XOR<ProductStockLocationCreateWithoutProductInput, ProductStockLocationUncheckedCreateWithoutProductInput>
  }

  export type ProductStockLocationCreateManyProductInputEnvelope = {
    data: ProductStockLocationCreateManyProductInput | ProductStockLocationCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SaleItemCreateWithoutProductInput = {
    id?: string
    name: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    sale: SaleCreateNestedOneWithoutItemsInput
    variant?: ProductVariantCreateNestedOneWithoutSaleItemsInput
  }

  export type SaleItemUncheckedCreateWithoutProductInput = {
    id?: string
    saleId: string
    variantId?: string | null
    name: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleItemCreateOrConnectWithoutProductInput = {
    where: SaleItemWhereUniqueInput
    create: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput>
  }

  export type SaleItemCreateManyProductInputEnvelope = {
    data: SaleItemCreateManyProductInput | SaleItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseItemCreateWithoutProductInput = {
    id?: string
    name: string
    sku: string
    costPrice: Decimal | DecimalJsLike | number | string
    quantity: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutItemsInput
    variant?: ProductVariantCreateNestedOneWithoutPurchaseItemsInput
  }

  export type PurchaseItemUncheckedCreateWithoutProductInput = {
    id?: string
    purchaseId: string
    variantId?: string | null
    name: string
    sku: string
    costPrice: Decimal | DecimalJsLike | number | string
    quantity: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PurchaseItemCreateOrConnectWithoutProductInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseItemCreateManyProductInputEnvelope = {
    data: PurchaseItemCreateManyProductInput | PurchaseItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StockMovementCreateWithoutProductInput = {
    id?: string
    movementType: $Enums.StockMovementType
    quantity: number
    referenceType?: string | null
    referenceId?: string | null
    referenceNumber?: string | null
    locationFrom?: string | null
    locationTo?: string | null
    notes?: string | null
    createdAt?: Date | string
    vendor: VendorCreateNestedOneWithoutStockMovementsInput
    variant?: ProductVariantCreateNestedOneWithoutStockMovementsInput
    creator: UserCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateWithoutProductInput = {
    id?: string
    vendorId: string
    variantId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    referenceType?: string | null
    referenceId?: string | null
    referenceNumber?: string | null
    locationFrom?: string | null
    locationTo?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutProductInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput>
  }

  export type StockMovementCreateManyProductInputEnvelope = {
    data: StockMovementCreateManyProductInput | StockMovementCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StockTakeItemCreateWithoutProductInput = {
    id?: string
    productName: string
    sku: string
    expectedQuantity: number
    countedQuantity: number
    notes?: string | null
    createdAt?: Date | string
    stockTake: StockTakeCreateNestedOneWithoutItemsInput
    variant?: ProductVariantCreateNestedOneWithoutStockTakeItemsInput
  }

  export type StockTakeItemUncheckedCreateWithoutProductInput = {
    id?: string
    stockTakeId: string
    variantId?: string | null
    productName: string
    sku: string
    expectedQuantity: number
    countedQuantity: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type StockTakeItemCreateOrConnectWithoutProductInput = {
    where: StockTakeItemWhereUniqueInput
    create: XOR<StockTakeItemCreateWithoutProductInput, StockTakeItemUncheckedCreateWithoutProductInput>
  }

  export type StockTakeItemCreateManyProductInputEnvelope = {
    data: StockTakeItemCreateManyProductInput | StockTakeItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CashierProductAssignmentCreateWithoutProductInput = {
    id?: string
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutProductAssignmentsInput
  }

  export type CashierProductAssignmentUncheckedCreateWithoutProductInput = {
    id?: string
    userId: string
    assignedAt?: Date | string
  }

  export type CashierProductAssignmentCreateOrConnectWithoutProductInput = {
    where: CashierProductAssignmentWhereUniqueInput
    create: XOR<CashierProductAssignmentCreateWithoutProductInput, CashierProductAssignmentUncheckedCreateWithoutProductInput>
  }

  export type CashierProductAssignmentCreateManyProductInputEnvelope = {
    data: CashierProductAssignmentCreateManyProductInput | CashierProductAssignmentCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutProductsInput = {
    update: XOR<VendorUpdateWithoutProductsInput, VendorUncheckedUpdateWithoutProductsInput>
    create: XOR<VendorCreateWithoutProductsInput, VendorUncheckedCreateWithoutProductsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutProductsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutProductsInput, VendorUncheckedUpdateWithoutProductsInput>
  }

  export type VendorUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutVendorNestedInput
    customers?: CustomerUpdateManyWithoutVendorNestedInput
    sales?: SaleUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutVendorNestedInput
    reports?: ReportUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutVendorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutVendorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type ProductVariantUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    update: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
  }

  export type ProductVariantUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    data: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>
  }

  export type ProductVariantUpdateManyWithWhereWithoutProductInput = {
    where: ProductVariantScalarWhereInput
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductVariantScalarWhereInput = {
    AND?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
    OR?: ProductVariantScalarWhereInput[]
    NOT?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
    id?: StringFilter<"ProductVariant"> | string
    productId?: StringFilter<"ProductVariant"> | string
    name?: StringFilter<"ProductVariant"> | string
    value?: StringFilter<"ProductVariant"> | string
    priceModifier?: DecimalFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string
    stock?: IntFilter<"ProductVariant"> | number
    sku?: StringFilter<"ProductVariant"> | string
    barcode?: StringNullableFilter<"ProductVariant"> | string | null
    isActive?: BoolFilter<"ProductVariant"> | boolean
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
  }

  export type ProductStockLocationUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductStockLocationWhereUniqueInput
    update: XOR<ProductStockLocationUpdateWithoutProductInput, ProductStockLocationUncheckedUpdateWithoutProductInput>
    create: XOR<ProductStockLocationCreateWithoutProductInput, ProductStockLocationUncheckedCreateWithoutProductInput>
  }

  export type ProductStockLocationUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductStockLocationWhereUniqueInput
    data: XOR<ProductStockLocationUpdateWithoutProductInput, ProductStockLocationUncheckedUpdateWithoutProductInput>
  }

  export type ProductStockLocationUpdateManyWithWhereWithoutProductInput = {
    where: ProductStockLocationScalarWhereInput
    data: XOR<ProductStockLocationUpdateManyMutationInput, ProductStockLocationUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductStockLocationScalarWhereInput = {
    AND?: ProductStockLocationScalarWhereInput | ProductStockLocationScalarWhereInput[]
    OR?: ProductStockLocationScalarWhereInput[]
    NOT?: ProductStockLocationScalarWhereInput | ProductStockLocationScalarWhereInput[]
    id?: StringFilter<"ProductStockLocation"> | string
    productId?: StringFilter<"ProductStockLocation"> | string
    variantId?: StringNullableFilter<"ProductStockLocation"> | string | null
    locationName?: StringFilter<"ProductStockLocation"> | string
    quantity?: IntFilter<"ProductStockLocation"> | number
    reservedQuantity?: IntFilter<"ProductStockLocation"> | number
    createdAt?: DateTimeFilter<"ProductStockLocation"> | Date | string
    updatedAt?: DateTimeFilter<"ProductStockLocation"> | Date | string
  }

  export type SaleItemUpsertWithWhereUniqueWithoutProductInput = {
    where: SaleItemWhereUniqueInput
    update: XOR<SaleItemUpdateWithoutProductInput, SaleItemUncheckedUpdateWithoutProductInput>
    create: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput>
  }

  export type SaleItemUpdateWithWhereUniqueWithoutProductInput = {
    where: SaleItemWhereUniqueInput
    data: XOR<SaleItemUpdateWithoutProductInput, SaleItemUncheckedUpdateWithoutProductInput>
  }

  export type SaleItemUpdateManyWithWhereWithoutProductInput = {
    where: SaleItemScalarWhereInput
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyWithoutProductInput>
  }

  export type SaleItemScalarWhereInput = {
    AND?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
    OR?: SaleItemScalarWhereInput[]
    NOT?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
    id?: StringFilter<"SaleItem"> | string
    saleId?: StringFilter<"SaleItem"> | string
    productId?: StringFilter<"SaleItem"> | string
    variantId?: StringNullableFilter<"SaleItem"> | string | null
    name?: StringFilter<"SaleItem"> | string
    sku?: StringFilter<"SaleItem"> | string
    price?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"SaleItem"> | number
    discount?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleItem"> | Date | string
  }

  export type PurchaseItemUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchaseItemWhereUniqueInput
    update: XOR<PurchaseItemUpdateWithoutProductInput, PurchaseItemUncheckedUpdateWithoutProductInput>
    create: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseItemUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchaseItemWhereUniqueInput
    data: XOR<PurchaseItemUpdateWithoutProductInput, PurchaseItemUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseItemUpdateManyWithWhereWithoutProductInput = {
    where: PurchaseItemScalarWhereInput
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchaseItemScalarWhereInput = {
    AND?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
    OR?: PurchaseItemScalarWhereInput[]
    NOT?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
    id?: StringFilter<"PurchaseItem"> | string
    purchaseId?: StringFilter<"PurchaseItem"> | string
    productId?: StringFilter<"PurchaseItem"> | string
    variantId?: StringNullableFilter<"PurchaseItem"> | string | null
    name?: StringFilter<"PurchaseItem"> | string
    sku?: StringFilter<"PurchaseItem"> | string
    costPrice?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"PurchaseItem"> | number
    total?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PurchaseItem"> | Date | string
  }

  export type StockMovementUpsertWithWhereUniqueWithoutProductInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutProductInput, StockMovementUncheckedUpdateWithoutProductInput>
    create: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutProductInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutProductInput, StockMovementUncheckedUpdateWithoutProductInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutProductInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutProductInput>
  }

  export type StockTakeItemUpsertWithWhereUniqueWithoutProductInput = {
    where: StockTakeItemWhereUniqueInput
    update: XOR<StockTakeItemUpdateWithoutProductInput, StockTakeItemUncheckedUpdateWithoutProductInput>
    create: XOR<StockTakeItemCreateWithoutProductInput, StockTakeItemUncheckedCreateWithoutProductInput>
  }

  export type StockTakeItemUpdateWithWhereUniqueWithoutProductInput = {
    where: StockTakeItemWhereUniqueInput
    data: XOR<StockTakeItemUpdateWithoutProductInput, StockTakeItemUncheckedUpdateWithoutProductInput>
  }

  export type StockTakeItemUpdateManyWithWhereWithoutProductInput = {
    where: StockTakeItemScalarWhereInput
    data: XOR<StockTakeItemUpdateManyMutationInput, StockTakeItemUncheckedUpdateManyWithoutProductInput>
  }

  export type StockTakeItemScalarWhereInput = {
    AND?: StockTakeItemScalarWhereInput | StockTakeItemScalarWhereInput[]
    OR?: StockTakeItemScalarWhereInput[]
    NOT?: StockTakeItemScalarWhereInput | StockTakeItemScalarWhereInput[]
    id?: StringFilter<"StockTakeItem"> | string
    stockTakeId?: StringFilter<"StockTakeItem"> | string
    productId?: StringFilter<"StockTakeItem"> | string
    variantId?: StringNullableFilter<"StockTakeItem"> | string | null
    productName?: StringFilter<"StockTakeItem"> | string
    sku?: StringFilter<"StockTakeItem"> | string
    expectedQuantity?: IntFilter<"StockTakeItem"> | number
    countedQuantity?: IntFilter<"StockTakeItem"> | number
    notes?: StringNullableFilter<"StockTakeItem"> | string | null
    createdAt?: DateTimeFilter<"StockTakeItem"> | Date | string
  }

  export type CashierProductAssignmentUpsertWithWhereUniqueWithoutProductInput = {
    where: CashierProductAssignmentWhereUniqueInput
    update: XOR<CashierProductAssignmentUpdateWithoutProductInput, CashierProductAssignmentUncheckedUpdateWithoutProductInput>
    create: XOR<CashierProductAssignmentCreateWithoutProductInput, CashierProductAssignmentUncheckedCreateWithoutProductInput>
  }

  export type CashierProductAssignmentUpdateWithWhereUniqueWithoutProductInput = {
    where: CashierProductAssignmentWhereUniqueInput
    data: XOR<CashierProductAssignmentUpdateWithoutProductInput, CashierProductAssignmentUncheckedUpdateWithoutProductInput>
  }

  export type CashierProductAssignmentUpdateManyWithWhereWithoutProductInput = {
    where: CashierProductAssignmentScalarWhereInput
    data: XOR<CashierProductAssignmentUpdateManyMutationInput, CashierProductAssignmentUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductCreateWithoutVariantsInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutProductsInput
    stockLocations?: ProductStockLocationCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    stockTakeItems?: StockTakeItemCreateNestedManyWithoutProductInput
    cashierAssignments?: CashierProductAssignmentCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutVariantsInput = {
    id?: string
    vendorId: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    stockLocations?: ProductStockLocationUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    stockTakeItems?: StockTakeItemUncheckedCreateNestedManyWithoutProductInput
    cashierAssignments?: CashierProductAssignmentUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutVariantsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
  }

  export type ProductStockLocationCreateWithoutVariantInput = {
    id?: string
    locationName: string
    quantity?: number
    reservedQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutStockLocationsInput
  }

  export type ProductStockLocationUncheckedCreateWithoutVariantInput = {
    id?: string
    productId: string
    locationName: string
    quantity?: number
    reservedQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductStockLocationCreateOrConnectWithoutVariantInput = {
    where: ProductStockLocationWhereUniqueInput
    create: XOR<ProductStockLocationCreateWithoutVariantInput, ProductStockLocationUncheckedCreateWithoutVariantInput>
  }

  export type ProductStockLocationCreateManyVariantInputEnvelope = {
    data: ProductStockLocationCreateManyVariantInput | ProductStockLocationCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type SaleItemCreateWithoutVariantInput = {
    id?: string
    name: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    sale: SaleCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutSaleItemsInput
  }

  export type SaleItemUncheckedCreateWithoutVariantInput = {
    id?: string
    saleId: string
    productId: string
    name: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleItemCreateOrConnectWithoutVariantInput = {
    where: SaleItemWhereUniqueInput
    create: XOR<SaleItemCreateWithoutVariantInput, SaleItemUncheckedCreateWithoutVariantInput>
  }

  export type SaleItemCreateManyVariantInputEnvelope = {
    data: SaleItemCreateManyVariantInput | SaleItemCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseItemCreateWithoutVariantInput = {
    id?: string
    name: string
    sku: string
    costPrice: Decimal | DecimalJsLike | number | string
    quantity: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutPurchaseItemsInput
  }

  export type PurchaseItemUncheckedCreateWithoutVariantInput = {
    id?: string
    purchaseId: string
    productId: string
    name: string
    sku: string
    costPrice: Decimal | DecimalJsLike | number | string
    quantity: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PurchaseItemCreateOrConnectWithoutVariantInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutVariantInput, PurchaseItemUncheckedCreateWithoutVariantInput>
  }

  export type PurchaseItemCreateManyVariantInputEnvelope = {
    data: PurchaseItemCreateManyVariantInput | PurchaseItemCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type StockMovementCreateWithoutVariantInput = {
    id?: string
    movementType: $Enums.StockMovementType
    quantity: number
    referenceType?: string | null
    referenceId?: string | null
    referenceNumber?: string | null
    locationFrom?: string | null
    locationTo?: string | null
    notes?: string | null
    createdAt?: Date | string
    vendor: VendorCreateNestedOneWithoutStockMovementsInput
    product: ProductCreateNestedOneWithoutStockMovementsInput
    creator: UserCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateWithoutVariantInput = {
    id?: string
    vendorId: string
    productId: string
    movementType: $Enums.StockMovementType
    quantity: number
    referenceType?: string | null
    referenceId?: string | null
    referenceNumber?: string | null
    locationFrom?: string | null
    locationTo?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutVariantInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutVariantInput, StockMovementUncheckedCreateWithoutVariantInput>
  }

  export type StockMovementCreateManyVariantInputEnvelope = {
    data: StockMovementCreateManyVariantInput | StockMovementCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type StockTakeItemCreateWithoutVariantInput = {
    id?: string
    productName: string
    sku: string
    expectedQuantity: number
    countedQuantity: number
    notes?: string | null
    createdAt?: Date | string
    stockTake: StockTakeCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutStockTakeItemsInput
  }

  export type StockTakeItemUncheckedCreateWithoutVariantInput = {
    id?: string
    stockTakeId: string
    productId: string
    productName: string
    sku: string
    expectedQuantity: number
    countedQuantity: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type StockTakeItemCreateOrConnectWithoutVariantInput = {
    where: StockTakeItemWhereUniqueInput
    create: XOR<StockTakeItemCreateWithoutVariantInput, StockTakeItemUncheckedCreateWithoutVariantInput>
  }

  export type StockTakeItemCreateManyVariantInputEnvelope = {
    data: StockTakeItemCreateManyVariantInput | StockTakeItemCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutVariantsInput = {
    update: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutVariantsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type ProductUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutProductsNestedInput
    stockLocations?: ProductStockLocationUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    stockTakeItems?: StockTakeItemUpdateManyWithoutProductNestedInput
    cashierAssignments?: CashierProductAssignmentUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockLocations?: ProductStockLocationUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    stockTakeItems?: StockTakeItemUncheckedUpdateManyWithoutProductNestedInput
    cashierAssignments?: CashierProductAssignmentUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductStockLocationUpsertWithWhereUniqueWithoutVariantInput = {
    where: ProductStockLocationWhereUniqueInput
    update: XOR<ProductStockLocationUpdateWithoutVariantInput, ProductStockLocationUncheckedUpdateWithoutVariantInput>
    create: XOR<ProductStockLocationCreateWithoutVariantInput, ProductStockLocationUncheckedCreateWithoutVariantInput>
  }

  export type ProductStockLocationUpdateWithWhereUniqueWithoutVariantInput = {
    where: ProductStockLocationWhereUniqueInput
    data: XOR<ProductStockLocationUpdateWithoutVariantInput, ProductStockLocationUncheckedUpdateWithoutVariantInput>
  }

  export type ProductStockLocationUpdateManyWithWhereWithoutVariantInput = {
    where: ProductStockLocationScalarWhereInput
    data: XOR<ProductStockLocationUpdateManyMutationInput, ProductStockLocationUncheckedUpdateManyWithoutVariantInput>
  }

  export type SaleItemUpsertWithWhereUniqueWithoutVariantInput = {
    where: SaleItemWhereUniqueInput
    update: XOR<SaleItemUpdateWithoutVariantInput, SaleItemUncheckedUpdateWithoutVariantInput>
    create: XOR<SaleItemCreateWithoutVariantInput, SaleItemUncheckedCreateWithoutVariantInput>
  }

  export type SaleItemUpdateWithWhereUniqueWithoutVariantInput = {
    where: SaleItemWhereUniqueInput
    data: XOR<SaleItemUpdateWithoutVariantInput, SaleItemUncheckedUpdateWithoutVariantInput>
  }

  export type SaleItemUpdateManyWithWhereWithoutVariantInput = {
    where: SaleItemScalarWhereInput
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyWithoutVariantInput>
  }

  export type PurchaseItemUpsertWithWhereUniqueWithoutVariantInput = {
    where: PurchaseItemWhereUniqueInput
    update: XOR<PurchaseItemUpdateWithoutVariantInput, PurchaseItemUncheckedUpdateWithoutVariantInput>
    create: XOR<PurchaseItemCreateWithoutVariantInput, PurchaseItemUncheckedCreateWithoutVariantInput>
  }

  export type PurchaseItemUpdateWithWhereUniqueWithoutVariantInput = {
    where: PurchaseItemWhereUniqueInput
    data: XOR<PurchaseItemUpdateWithoutVariantInput, PurchaseItemUncheckedUpdateWithoutVariantInput>
  }

  export type PurchaseItemUpdateManyWithWhereWithoutVariantInput = {
    where: PurchaseItemScalarWhereInput
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyWithoutVariantInput>
  }

  export type StockMovementUpsertWithWhereUniqueWithoutVariantInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutVariantInput, StockMovementUncheckedUpdateWithoutVariantInput>
    create: XOR<StockMovementCreateWithoutVariantInput, StockMovementUncheckedCreateWithoutVariantInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutVariantInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutVariantInput, StockMovementUncheckedUpdateWithoutVariantInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutVariantInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutVariantInput>
  }

  export type StockTakeItemUpsertWithWhereUniqueWithoutVariantInput = {
    where: StockTakeItemWhereUniqueInput
    update: XOR<StockTakeItemUpdateWithoutVariantInput, StockTakeItemUncheckedUpdateWithoutVariantInput>
    create: XOR<StockTakeItemCreateWithoutVariantInput, StockTakeItemUncheckedCreateWithoutVariantInput>
  }

  export type StockTakeItemUpdateWithWhereUniqueWithoutVariantInput = {
    where: StockTakeItemWhereUniqueInput
    data: XOR<StockTakeItemUpdateWithoutVariantInput, StockTakeItemUncheckedUpdateWithoutVariantInput>
  }

  export type StockTakeItemUpdateManyWithWhereWithoutVariantInput = {
    where: StockTakeItemScalarWhereInput
    data: XOR<StockTakeItemUpdateManyMutationInput, StockTakeItemUncheckedUpdateManyWithoutVariantInput>
  }

  export type ProductCreateWithoutStockLocationsInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutProductsInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    stockTakeItems?: StockTakeItemCreateNestedManyWithoutProductInput
    cashierAssignments?: CashierProductAssignmentCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStockLocationsInput = {
    id?: string
    vendorId: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    stockTakeItems?: StockTakeItemUncheckedCreateNestedManyWithoutProductInput
    cashierAssignments?: CashierProductAssignmentUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStockLocationsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStockLocationsInput, ProductUncheckedCreateWithoutStockLocationsInput>
  }

  export type ProductVariantCreateWithoutStockLocationsInput = {
    id?: string
    name: string
    value: string
    priceModifier?: Decimal | DecimalJsLike | number | string
    stock?: number
    sku: string
    barcode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    saleItems?: SaleItemCreateNestedManyWithoutVariantInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutVariantInput
    stockMovements?: StockMovementCreateNestedManyWithoutVariantInput
    stockTakeItems?: StockTakeItemCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutStockLocationsInput = {
    id?: string
    productId: string
    name: string
    value: string
    priceModifier?: Decimal | DecimalJsLike | number | string
    stock?: number
    sku: string
    barcode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutVariantInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutVariantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVariantInput
    stockTakeItems?: StockTakeItemUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutStockLocationsInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutStockLocationsInput, ProductVariantUncheckedCreateWithoutStockLocationsInput>
  }

  export type ProductUpsertWithoutStockLocationsInput = {
    update: XOR<ProductUpdateWithoutStockLocationsInput, ProductUncheckedUpdateWithoutStockLocationsInput>
    create: XOR<ProductCreateWithoutStockLocationsInput, ProductUncheckedCreateWithoutStockLocationsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStockLocationsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStockLocationsInput, ProductUncheckedUpdateWithoutStockLocationsInput>
  }

  export type ProductUpdateWithoutStockLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutProductsNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    stockTakeItems?: StockTakeItemUpdateManyWithoutProductNestedInput
    cashierAssignments?: CashierProductAssignmentUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStockLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    stockTakeItems?: StockTakeItemUncheckedUpdateManyWithoutProductNestedInput
    cashierAssignments?: CashierProductAssignmentUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductVariantUpsertWithoutStockLocationsInput = {
    update: XOR<ProductVariantUpdateWithoutStockLocationsInput, ProductVariantUncheckedUpdateWithoutStockLocationsInput>
    create: XOR<ProductVariantCreateWithoutStockLocationsInput, ProductVariantUncheckedCreateWithoutStockLocationsInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutStockLocationsInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutStockLocationsInput, ProductVariantUncheckedUpdateWithoutStockLocationsInput>
  }

  export type ProductVariantUpdateWithoutStockLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priceModifier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    saleItems?: SaleItemUpdateManyWithoutVariantNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutVariantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVariantNestedInput
    stockTakeItems?: StockTakeItemUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutStockLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priceModifier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutVariantNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutVariantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVariantNestedInput
    stockTakeItems?: StockTakeItemUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type UserCreateWithoutProductAssignmentsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutUsersInput
    cashierSchedule?: CashierScheduleCreateNestedOneWithoutUserInput
    sales?: SaleCreateNestedManyWithoutCashierInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    stockTakes?: StockTakeCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratorInput
  }

  export type UserUncheckedCreateWithoutProductAssignmentsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    vendorId?: string | null
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashierSchedule?: CashierScheduleUncheckedCreateNestedOneWithoutUserInput
    sales?: SaleUncheckedCreateNestedManyWithoutCashierInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratorInput
  }

  export type UserCreateOrConnectWithoutProductAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductAssignmentsInput, UserUncheckedCreateWithoutProductAssignmentsInput>
  }

  export type ProductCreateWithoutCashierAssignmentsInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutProductsInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
    stockLocations?: ProductStockLocationCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    stockTakeItems?: StockTakeItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCashierAssignmentsInput = {
    id?: string
    vendorId: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    stockLocations?: ProductStockLocationUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    stockTakeItems?: StockTakeItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCashierAssignmentsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCashierAssignmentsInput, ProductUncheckedCreateWithoutCashierAssignmentsInput>
  }

  export type UserUpsertWithoutProductAssignmentsInput = {
    update: XOR<UserUpdateWithoutProductAssignmentsInput, UserUncheckedUpdateWithoutProductAssignmentsInput>
    create: XOR<UserCreateWithoutProductAssignmentsInput, UserUncheckedCreateWithoutProductAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductAssignmentsInput, UserUncheckedUpdateWithoutProductAssignmentsInput>
  }

  export type UserUpdateWithoutProductAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutUsersNestedInput
    cashierSchedule?: CashierScheduleUpdateOneWithoutUserNestedInput
    sales?: SaleUpdateManyWithoutCashierNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratorNestedInput
  }

  export type UserUncheckedUpdateWithoutProductAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashierSchedule?: CashierScheduleUncheckedUpdateOneWithoutUserNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCashierNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratorNestedInput
  }

  export type ProductUpsertWithoutCashierAssignmentsInput = {
    update: XOR<ProductUpdateWithoutCashierAssignmentsInput, ProductUncheckedUpdateWithoutCashierAssignmentsInput>
    create: XOR<ProductCreateWithoutCashierAssignmentsInput, ProductUncheckedCreateWithoutCashierAssignmentsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCashierAssignmentsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCashierAssignmentsInput, ProductUncheckedUpdateWithoutCashierAssignmentsInput>
  }

  export type ProductUpdateWithoutCashierAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutProductsNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
    stockLocations?: ProductStockLocationUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    stockTakeItems?: StockTakeItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCashierAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    stockLocations?: ProductStockLocationUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    stockTakeItems?: StockTakeItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type VendorCreateWithoutCustomersInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutVendorInput
    products?: ProductCreateNestedManyWithoutVendorInput
    sales?: SaleCreateNestedManyWithoutVendorInput
    suppliers?: SupplierCreateNestedManyWithoutVendorInput
    purchases?: PurchaseCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeCreateNestedManyWithoutVendorInput
    notifications?: NotificationCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketCreateNestedManyWithoutVendorInput
    reports?: ReportCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutCustomersInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    sales?: SaleUncheckedCreateNestedManyWithoutVendorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutVendorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutVendorInput
    reports?: ReportUncheckedCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutCustomersInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutCustomersInput, VendorUncheckedCreateWithoutCustomersInput>
  }

  export type SaleCreateWithoutCustomerInput = {
    id?: string
    terminalId: string
    receiptNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paid: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.SaleStatus
    refundAmount?: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsUsed?: number
    notes?: string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutSalesInput
    cashier: UserCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutCustomerInput = {
    id?: string
    vendorId: string
    cashierId: string
    terminalId: string
    receiptNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paid: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.SaleStatus
    refundAmount?: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsUsed?: number
    notes?: string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput>
  }

  export type SaleCreateManyCustomerInputEnvelope = {
    data: SaleCreateManyCustomerInput | SaleCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutCustomersInput = {
    update: XOR<VendorUpdateWithoutCustomersInput, VendorUncheckedUpdateWithoutCustomersInput>
    create: XOR<VendorCreateWithoutCustomersInput, VendorUncheckedCreateWithoutCustomersInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutCustomersInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutCustomersInput, VendorUncheckedUpdateWithoutCustomersInput>
  }

  export type VendorUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutVendorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
    sales?: SaleUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutVendorNestedInput
    reports?: ReportUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutVendorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type SaleUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutCustomerInput, SaleUncheckedUpdateWithoutCustomerInput>
    create: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutCustomerInput, SaleUncheckedUpdateWithoutCustomerInput>
  }

  export type SaleUpdateManyWithWhereWithoutCustomerInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutCustomerInput>
  }

  export type VendorCreateWithoutSalesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutVendorInput
    products?: ProductCreateNestedManyWithoutVendorInput
    customers?: CustomerCreateNestedManyWithoutVendorInput
    suppliers?: SupplierCreateNestedManyWithoutVendorInput
    purchases?: PurchaseCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeCreateNestedManyWithoutVendorInput
    notifications?: NotificationCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketCreateNestedManyWithoutVendorInput
    reports?: ReportCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutSalesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    customers?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutVendorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutVendorInput
    reports?: ReportUncheckedCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutSalesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutSalesInput, VendorUncheckedCreateWithoutSalesInput>
  }

  export type UserCreateWithoutSalesInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutUsersInput
    cashierSchedule?: CashierScheduleCreateNestedOneWithoutUserInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    stockTakes?: StockTakeCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratorInput
    productAssignments?: CashierProductAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSalesInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    vendorId?: string | null
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashierSchedule?: CashierScheduleUncheckedCreateNestedOneWithoutUserInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratorInput
    productAssignments?: CashierProductAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSalesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalesInput, UserUncheckedCreateWithoutSalesInput>
  }

  export type CustomerCreateWithoutSalesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    visitCount?: number
    lastVisit?: Date | string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutSalesInput = {
    id?: string
    vendorId: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    visitCount?: number
    lastVisit?: Date | string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateOrConnectWithoutSalesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
  }

  export type SaleItemCreateWithoutSaleInput = {
    id?: string
    name: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutSaleItemsInput
    variant?: ProductVariantCreateNestedOneWithoutSaleItemsInput
  }

  export type SaleItemUncheckedCreateWithoutSaleInput = {
    id?: string
    productId: string
    variantId?: string | null
    name: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleItemCreateOrConnectWithoutSaleInput = {
    where: SaleItemWhereUniqueInput
    create: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput>
  }

  export type SaleItemCreateManySaleInputEnvelope = {
    data: SaleItemCreateManySaleInput | SaleItemCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutSalesInput = {
    update: XOR<VendorUpdateWithoutSalesInput, VendorUncheckedUpdateWithoutSalesInput>
    create: XOR<VendorCreateWithoutSalesInput, VendorUncheckedCreateWithoutSalesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutSalesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutSalesInput, VendorUncheckedUpdateWithoutSalesInput>
  }

  export type VendorUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutVendorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
    customers?: CustomerUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutVendorNestedInput
    reports?: ReportUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutVendorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type UserUpsertWithoutSalesInput = {
    update: XOR<UserUpdateWithoutSalesInput, UserUncheckedUpdateWithoutSalesInput>
    create: XOR<UserCreateWithoutSalesInput, UserUncheckedCreateWithoutSalesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalesInput, UserUncheckedUpdateWithoutSalesInput>
  }

  export type UserUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutUsersNestedInput
    cashierSchedule?: CashierScheduleUpdateOneWithoutUserNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratorNestedInput
    productAssignments?: CashierProductAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashierSchedule?: CashierScheduleUncheckedUpdateOneWithoutUserNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratorNestedInput
    productAssignments?: CashierProductAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CustomerUpsertWithoutSalesInput = {
    update: XOR<CustomerUpdateWithoutSalesInput, CustomerUncheckedUpdateWithoutSalesInput>
    create: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSalesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSalesInput, CustomerUncheckedUpdateWithoutSalesInput>
  }

  export type CustomerUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    visitCount?: IntFieldUpdateOperationsInput | number
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    visitCount?: IntFieldUpdateOperationsInput | number
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUpsertWithWhereUniqueWithoutSaleInput = {
    where: SaleItemWhereUniqueInput
    update: XOR<SaleItemUpdateWithoutSaleInput, SaleItemUncheckedUpdateWithoutSaleInput>
    create: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput>
  }

  export type SaleItemUpdateWithWhereUniqueWithoutSaleInput = {
    where: SaleItemWhereUniqueInput
    data: XOR<SaleItemUpdateWithoutSaleInput, SaleItemUncheckedUpdateWithoutSaleInput>
  }

  export type SaleItemUpdateManyWithWhereWithoutSaleInput = {
    where: SaleItemScalarWhereInput
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyWithoutSaleInput>
  }

  export type SaleCreateWithoutItemsInput = {
    id?: string
    terminalId: string
    receiptNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paid: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.SaleStatus
    refundAmount?: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsUsed?: number
    notes?: string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutSalesInput
    cashier: UserCreateNestedOneWithoutSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutItemsInput = {
    id?: string
    vendorId: string
    cashierId: string
    terminalId: string
    customerId?: string | null
    receiptNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paid: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.SaleStatus
    refundAmount?: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsUsed?: number
    notes?: string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleCreateOrConnectWithoutItemsInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutItemsInput, SaleUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutSaleItemsInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutProductsInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
    stockLocations?: ProductStockLocationCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    stockTakeItems?: StockTakeItemCreateNestedManyWithoutProductInput
    cashierAssignments?: CashierProductAssignmentCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSaleItemsInput = {
    id?: string
    vendorId: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    stockLocations?: ProductStockLocationUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    stockTakeItems?: StockTakeItemUncheckedCreateNestedManyWithoutProductInput
    cashierAssignments?: CashierProductAssignmentUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSaleItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSaleItemsInput, ProductUncheckedCreateWithoutSaleItemsInput>
  }

  export type ProductVariantCreateWithoutSaleItemsInput = {
    id?: string
    name: string
    value: string
    priceModifier?: Decimal | DecimalJsLike | number | string
    stock?: number
    sku: string
    barcode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    stockLocations?: ProductStockLocationCreateNestedManyWithoutVariantInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutVariantInput
    stockMovements?: StockMovementCreateNestedManyWithoutVariantInput
    stockTakeItems?: StockTakeItemCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutSaleItemsInput = {
    id?: string
    productId: string
    name: string
    value: string
    priceModifier?: Decimal | DecimalJsLike | number | string
    stock?: number
    sku: string
    barcode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockLocations?: ProductStockLocationUncheckedCreateNestedManyWithoutVariantInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutVariantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVariantInput
    stockTakeItems?: StockTakeItemUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutSaleItemsInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutSaleItemsInput, ProductVariantUncheckedCreateWithoutSaleItemsInput>
  }

  export type SaleUpsertWithoutItemsInput = {
    update: XOR<SaleUpdateWithoutItemsInput, SaleUncheckedUpdateWithoutItemsInput>
    create: XOR<SaleCreateWithoutItemsInput, SaleUncheckedCreateWithoutItemsInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutItemsInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutItemsInput, SaleUncheckedUpdateWithoutItemsInput>
  }

  export type SaleUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsUsed?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutSalesNestedInput
    cashier?: UserUpdateOneRequiredWithoutSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsUsed?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutSaleItemsInput = {
    update: XOR<ProductUpdateWithoutSaleItemsInput, ProductUncheckedUpdateWithoutSaleItemsInput>
    create: XOR<ProductCreateWithoutSaleItemsInput, ProductUncheckedCreateWithoutSaleItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSaleItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSaleItemsInput, ProductUncheckedUpdateWithoutSaleItemsInput>
  }

  export type ProductUpdateWithoutSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutProductsNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
    stockLocations?: ProductStockLocationUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    stockTakeItems?: StockTakeItemUpdateManyWithoutProductNestedInput
    cashierAssignments?: CashierProductAssignmentUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    stockLocations?: ProductStockLocationUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    stockTakeItems?: StockTakeItemUncheckedUpdateManyWithoutProductNestedInput
    cashierAssignments?: CashierProductAssignmentUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductVariantUpsertWithoutSaleItemsInput = {
    update: XOR<ProductVariantUpdateWithoutSaleItemsInput, ProductVariantUncheckedUpdateWithoutSaleItemsInput>
    create: XOR<ProductVariantCreateWithoutSaleItemsInput, ProductVariantUncheckedCreateWithoutSaleItemsInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutSaleItemsInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutSaleItemsInput, ProductVariantUncheckedUpdateWithoutSaleItemsInput>
  }

  export type ProductVariantUpdateWithoutSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priceModifier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    stockLocations?: ProductStockLocationUpdateManyWithoutVariantNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutVariantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVariantNestedInput
    stockTakeItems?: StockTakeItemUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priceModifier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockLocations?: ProductStockLocationUncheckedUpdateManyWithoutVariantNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutVariantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVariantNestedInput
    stockTakeItems?: StockTakeItemUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type VendorCreateWithoutSuppliersInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutVendorInput
    products?: ProductCreateNestedManyWithoutVendorInput
    customers?: CustomerCreateNestedManyWithoutVendorInput
    sales?: SaleCreateNestedManyWithoutVendorInput
    purchases?: PurchaseCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeCreateNestedManyWithoutVendorInput
    notifications?: NotificationCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketCreateNestedManyWithoutVendorInput
    reports?: ReportCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutSuppliersInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    customers?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    sales?: SaleUncheckedCreateNestedManyWithoutVendorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutVendorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutVendorInput
    reports?: ReportUncheckedCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutSuppliersInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutSuppliersInput, VendorUncheckedCreateWithoutSuppliersInput>
  }

  export type PurchaseCreateWithoutSupplierInput = {
    id?: string
    purchaseNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchasesInput
    items?: PurchaseItemCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutSupplierInput = {
    id?: string
    vendorId: string
    purchaseNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutSupplierInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseCreateManySupplierInputEnvelope = {
    data: PurchaseCreateManySupplierInput | PurchaseCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutSuppliersInput = {
    update: XOR<VendorUpdateWithoutSuppliersInput, VendorUncheckedUpdateWithoutSuppliersInput>
    create: XOR<VendorCreateWithoutSuppliersInput, VendorUncheckedCreateWithoutSuppliersInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutSuppliersInput, VendorUncheckedUpdateWithoutSuppliersInput>
  }

  export type VendorUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutVendorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
    customers?: CustomerUpdateManyWithoutVendorNestedInput
    sales?: SaleUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutVendorNestedInput
    reports?: ReportUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutVendorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutVendorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type PurchaseUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutSupplierInput, PurchaseUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutSupplierInput, PurchaseUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutSupplierInput>
  }

  export type VendorCreateWithoutPurchasesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutVendorInput
    products?: ProductCreateNestedManyWithoutVendorInput
    customers?: CustomerCreateNestedManyWithoutVendorInput
    sales?: SaleCreateNestedManyWithoutVendorInput
    suppliers?: SupplierCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeCreateNestedManyWithoutVendorInput
    notifications?: NotificationCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketCreateNestedManyWithoutVendorInput
    reports?: ReportCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutPurchasesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    customers?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    sales?: SaleUncheckedCreateNestedManyWithoutVendorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutVendorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutVendorInput
    reports?: ReportUncheckedCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutPurchasesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPurchasesInput, VendorUncheckedCreateWithoutPurchasesInput>
  }

  export type SupplierCreateWithoutPurchasesInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    paymentTerms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutSuppliersInput
  }

  export type SupplierUncheckedCreateWithoutPurchasesInput = {
    id?: string
    vendorId: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    paymentTerms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierCreateOrConnectWithoutPurchasesInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchasesInput, SupplierUncheckedCreateWithoutPurchasesInput>
  }

  export type PurchaseItemCreateWithoutPurchaseInput = {
    id?: string
    name: string
    sku: string
    costPrice: Decimal | DecimalJsLike | number | string
    quantity: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutPurchaseItemsInput
    variant?: ProductVariantCreateNestedOneWithoutPurchaseItemsInput
  }

  export type PurchaseItemUncheckedCreateWithoutPurchaseInput = {
    id?: string
    productId: string
    variantId?: string | null
    name: string
    sku: string
    costPrice: Decimal | DecimalJsLike | number | string
    quantity: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PurchaseItemCreateOrConnectWithoutPurchaseInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseItemCreateManyPurchaseInputEnvelope = {
    data: PurchaseItemCreateManyPurchaseInput | PurchaseItemCreateManyPurchaseInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutPurchasesInput = {
    update: XOR<VendorUpdateWithoutPurchasesInput, VendorUncheckedUpdateWithoutPurchasesInput>
    create: XOR<VendorCreateWithoutPurchasesInput, VendorUncheckedCreateWithoutPurchasesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutPurchasesInput, VendorUncheckedUpdateWithoutPurchasesInput>
  }

  export type VendorUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutVendorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
    customers?: CustomerUpdateManyWithoutVendorNestedInput
    sales?: SaleUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutVendorNestedInput
    reports?: ReportUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutVendorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutVendorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type SupplierUpsertWithoutPurchasesInput = {
    update: XOR<SupplierUpdateWithoutPurchasesInput, SupplierUncheckedUpdateWithoutPurchasesInput>
    create: XOR<SupplierCreateWithoutPurchasesInput, SupplierUncheckedCreateWithoutPurchasesInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchasesInput, SupplierUncheckedUpdateWithoutPurchasesInput>
  }

  export type SupplierUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutSuppliersNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseItemWhereUniqueInput
    update: XOR<PurchaseItemUpdateWithoutPurchaseInput, PurchaseItemUncheckedUpdateWithoutPurchaseInput>
    create: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseItemWhereUniqueInput
    data: XOR<PurchaseItemUpdateWithoutPurchaseInput, PurchaseItemUncheckedUpdateWithoutPurchaseInput>
  }

  export type PurchaseItemUpdateManyWithWhereWithoutPurchaseInput = {
    where: PurchaseItemScalarWhereInput
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type PurchaseCreateWithoutItemsInput = {
    id?: string
    purchaseNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchasesInput
    supplier: SupplierCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateWithoutItemsInput = {
    id?: string
    vendorId: string
    supplierId: string
    purchaseNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateOrConnectWithoutItemsInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutItemsInput, PurchaseUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutPurchaseItemsInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutProductsInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
    stockLocations?: ProductStockLocationCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    stockTakeItems?: StockTakeItemCreateNestedManyWithoutProductInput
    cashierAssignments?: CashierProductAssignmentCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPurchaseItemsInput = {
    id?: string
    vendorId: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    stockLocations?: ProductStockLocationUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    stockTakeItems?: StockTakeItemUncheckedCreateNestedManyWithoutProductInput
    cashierAssignments?: CashierProductAssignmentUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchaseItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchaseItemsInput, ProductUncheckedCreateWithoutPurchaseItemsInput>
  }

  export type ProductVariantCreateWithoutPurchaseItemsInput = {
    id?: string
    name: string
    value: string
    priceModifier?: Decimal | DecimalJsLike | number | string
    stock?: number
    sku: string
    barcode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    stockLocations?: ProductStockLocationCreateNestedManyWithoutVariantInput
    saleItems?: SaleItemCreateNestedManyWithoutVariantInput
    stockMovements?: StockMovementCreateNestedManyWithoutVariantInput
    stockTakeItems?: StockTakeItemCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutPurchaseItemsInput = {
    id?: string
    productId: string
    name: string
    value: string
    priceModifier?: Decimal | DecimalJsLike | number | string
    stock?: number
    sku: string
    barcode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockLocations?: ProductStockLocationUncheckedCreateNestedManyWithoutVariantInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutVariantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVariantInput
    stockTakeItems?: StockTakeItemUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutPurchaseItemsInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutPurchaseItemsInput, ProductVariantUncheckedCreateWithoutPurchaseItemsInput>
  }

  export type PurchaseUpsertWithoutItemsInput = {
    update: XOR<PurchaseUpdateWithoutItemsInput, PurchaseUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseCreateWithoutItemsInput, PurchaseUncheckedCreateWithoutItemsInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutItemsInput, PurchaseUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchasesNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutPurchaseItemsInput = {
    update: XOR<ProductUpdateWithoutPurchaseItemsInput, ProductUncheckedUpdateWithoutPurchaseItemsInput>
    create: XOR<ProductCreateWithoutPurchaseItemsInput, ProductUncheckedCreateWithoutPurchaseItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPurchaseItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPurchaseItemsInput, ProductUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type ProductUpdateWithoutPurchaseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutProductsNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
    stockLocations?: ProductStockLocationUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    stockTakeItems?: StockTakeItemUpdateManyWithoutProductNestedInput
    cashierAssignments?: CashierProductAssignmentUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchaseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    stockLocations?: ProductStockLocationUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    stockTakeItems?: StockTakeItemUncheckedUpdateManyWithoutProductNestedInput
    cashierAssignments?: CashierProductAssignmentUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductVariantUpsertWithoutPurchaseItemsInput = {
    update: XOR<ProductVariantUpdateWithoutPurchaseItemsInput, ProductVariantUncheckedUpdateWithoutPurchaseItemsInput>
    create: XOR<ProductVariantCreateWithoutPurchaseItemsInput, ProductVariantUncheckedCreateWithoutPurchaseItemsInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutPurchaseItemsInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutPurchaseItemsInput, ProductVariantUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type ProductVariantUpdateWithoutPurchaseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priceModifier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    stockLocations?: ProductStockLocationUpdateManyWithoutVariantNestedInput
    saleItems?: SaleItemUpdateManyWithoutVariantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVariantNestedInput
    stockTakeItems?: StockTakeItemUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutPurchaseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priceModifier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockLocations?: ProductStockLocationUncheckedUpdateManyWithoutVariantNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutVariantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVariantNestedInput
    stockTakeItems?: StockTakeItemUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type VendorCreateWithoutStockMovementsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutVendorInput
    products?: ProductCreateNestedManyWithoutVendorInput
    customers?: CustomerCreateNestedManyWithoutVendorInput
    sales?: SaleCreateNestedManyWithoutVendorInput
    suppliers?: SupplierCreateNestedManyWithoutVendorInput
    purchases?: PurchaseCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeCreateNestedManyWithoutVendorInput
    notifications?: NotificationCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketCreateNestedManyWithoutVendorInput
    reports?: ReportCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutStockMovementsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    customers?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    sales?: SaleUncheckedCreateNestedManyWithoutVendorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutVendorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutVendorInput
    reports?: ReportUncheckedCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutStockMovementsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutStockMovementsInput, VendorUncheckedCreateWithoutStockMovementsInput>
  }

  export type ProductCreateWithoutStockMovementsInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutProductsInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
    stockLocations?: ProductStockLocationCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutProductInput
    stockTakeItems?: StockTakeItemCreateNestedManyWithoutProductInput
    cashierAssignments?: CashierProductAssignmentCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStockMovementsInput = {
    id?: string
    vendorId: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    stockLocations?: ProductStockLocationUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    stockTakeItems?: StockTakeItemUncheckedCreateNestedManyWithoutProductInput
    cashierAssignments?: CashierProductAssignmentUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStockMovementsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStockMovementsInput, ProductUncheckedCreateWithoutStockMovementsInput>
  }

  export type ProductVariantCreateWithoutStockMovementsInput = {
    id?: string
    name: string
    value: string
    priceModifier?: Decimal | DecimalJsLike | number | string
    stock?: number
    sku: string
    barcode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    stockLocations?: ProductStockLocationCreateNestedManyWithoutVariantInput
    saleItems?: SaleItemCreateNestedManyWithoutVariantInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutVariantInput
    stockTakeItems?: StockTakeItemCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutStockMovementsInput = {
    id?: string
    productId: string
    name: string
    value: string
    priceModifier?: Decimal | DecimalJsLike | number | string
    stock?: number
    sku: string
    barcode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockLocations?: ProductStockLocationUncheckedCreateNestedManyWithoutVariantInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutVariantInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutVariantInput
    stockTakeItems?: StockTakeItemUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutStockMovementsInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutStockMovementsInput, ProductVariantUncheckedCreateWithoutStockMovementsInput>
  }

  export type UserCreateWithoutStockMovementsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutUsersInput
    cashierSchedule?: CashierScheduleCreateNestedOneWithoutUserInput
    sales?: SaleCreateNestedManyWithoutCashierInput
    stockTakes?: StockTakeCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratorInput
    productAssignments?: CashierProductAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStockMovementsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    vendorId?: string | null
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashierSchedule?: CashierScheduleUncheckedCreateNestedOneWithoutUserInput
    sales?: SaleUncheckedCreateNestedManyWithoutCashierInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratorInput
    productAssignments?: CashierProductAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStockMovementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStockMovementsInput, UserUncheckedCreateWithoutStockMovementsInput>
  }

  export type VendorUpsertWithoutStockMovementsInput = {
    update: XOR<VendorUpdateWithoutStockMovementsInput, VendorUncheckedUpdateWithoutStockMovementsInput>
    create: XOR<VendorCreateWithoutStockMovementsInput, VendorUncheckedCreateWithoutStockMovementsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutStockMovementsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutStockMovementsInput, VendorUncheckedUpdateWithoutStockMovementsInput>
  }

  export type VendorUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutVendorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
    customers?: CustomerUpdateManyWithoutVendorNestedInput
    sales?: SaleUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutVendorNestedInput
    reports?: ReportUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutVendorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutVendorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type ProductUpsertWithoutStockMovementsInput = {
    update: XOR<ProductUpdateWithoutStockMovementsInput, ProductUncheckedUpdateWithoutStockMovementsInput>
    create: XOR<ProductCreateWithoutStockMovementsInput, ProductUncheckedCreateWithoutStockMovementsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStockMovementsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStockMovementsInput, ProductUncheckedUpdateWithoutStockMovementsInput>
  }

  export type ProductUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutProductsNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
    stockLocations?: ProductStockLocationUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutProductNestedInput
    stockTakeItems?: StockTakeItemUpdateManyWithoutProductNestedInput
    cashierAssignments?: CashierProductAssignmentUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    stockLocations?: ProductStockLocationUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    stockTakeItems?: StockTakeItemUncheckedUpdateManyWithoutProductNestedInput
    cashierAssignments?: CashierProductAssignmentUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductVariantUpsertWithoutStockMovementsInput = {
    update: XOR<ProductVariantUpdateWithoutStockMovementsInput, ProductVariantUncheckedUpdateWithoutStockMovementsInput>
    create: XOR<ProductVariantCreateWithoutStockMovementsInput, ProductVariantUncheckedCreateWithoutStockMovementsInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutStockMovementsInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutStockMovementsInput, ProductVariantUncheckedUpdateWithoutStockMovementsInput>
  }

  export type ProductVariantUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priceModifier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    stockLocations?: ProductStockLocationUpdateManyWithoutVariantNestedInput
    saleItems?: SaleItemUpdateManyWithoutVariantNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutVariantNestedInput
    stockTakeItems?: StockTakeItemUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priceModifier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockLocations?: ProductStockLocationUncheckedUpdateManyWithoutVariantNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutVariantNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutVariantNestedInput
    stockTakeItems?: StockTakeItemUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type UserUpsertWithoutStockMovementsInput = {
    update: XOR<UserUpdateWithoutStockMovementsInput, UserUncheckedUpdateWithoutStockMovementsInput>
    create: XOR<UserCreateWithoutStockMovementsInput, UserUncheckedCreateWithoutStockMovementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStockMovementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStockMovementsInput, UserUncheckedUpdateWithoutStockMovementsInput>
  }

  export type UserUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutUsersNestedInput
    cashierSchedule?: CashierScheduleUpdateOneWithoutUserNestedInput
    sales?: SaleUpdateManyWithoutCashierNestedInput
    stockTakes?: StockTakeUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratorNestedInput
    productAssignments?: CashierProductAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashierSchedule?: CashierScheduleUncheckedUpdateOneWithoutUserNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCashierNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratorNestedInput
    productAssignments?: CashierProductAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VendorCreateWithoutStockTakesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutVendorInput
    products?: ProductCreateNestedManyWithoutVendorInput
    customers?: CustomerCreateNestedManyWithoutVendorInput
    sales?: SaleCreateNestedManyWithoutVendorInput
    suppliers?: SupplierCreateNestedManyWithoutVendorInput
    purchases?: PurchaseCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementCreateNestedManyWithoutVendorInput
    notifications?: NotificationCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketCreateNestedManyWithoutVendorInput
    reports?: ReportCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutStockTakesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    customers?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    sales?: SaleUncheckedCreateNestedManyWithoutVendorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVendorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutVendorInput
    reports?: ReportUncheckedCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutStockTakesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutStockTakesInput, VendorUncheckedCreateWithoutStockTakesInput>
  }

  export type UserCreateWithoutStockTakesInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutUsersInput
    cashierSchedule?: CashierScheduleCreateNestedOneWithoutUserInput
    sales?: SaleCreateNestedManyWithoutCashierInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratorInput
    productAssignments?: CashierProductAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStockTakesInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    vendorId?: string | null
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashierSchedule?: CashierScheduleUncheckedCreateNestedOneWithoutUserInput
    sales?: SaleUncheckedCreateNestedManyWithoutCashierInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratorInput
    productAssignments?: CashierProductAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStockTakesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStockTakesInput, UserUncheckedCreateWithoutStockTakesInput>
  }

  export type StockTakeItemCreateWithoutStockTakeInput = {
    id?: string
    productName: string
    sku: string
    expectedQuantity: number
    countedQuantity: number
    notes?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutStockTakeItemsInput
    variant?: ProductVariantCreateNestedOneWithoutStockTakeItemsInput
  }

  export type StockTakeItemUncheckedCreateWithoutStockTakeInput = {
    id?: string
    productId: string
    variantId?: string | null
    productName: string
    sku: string
    expectedQuantity: number
    countedQuantity: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type StockTakeItemCreateOrConnectWithoutStockTakeInput = {
    where: StockTakeItemWhereUniqueInput
    create: XOR<StockTakeItemCreateWithoutStockTakeInput, StockTakeItemUncheckedCreateWithoutStockTakeInput>
  }

  export type StockTakeItemCreateManyStockTakeInputEnvelope = {
    data: StockTakeItemCreateManyStockTakeInput | StockTakeItemCreateManyStockTakeInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutStockTakesInput = {
    update: XOR<VendorUpdateWithoutStockTakesInput, VendorUncheckedUpdateWithoutStockTakesInput>
    create: XOR<VendorCreateWithoutStockTakesInput, VendorUncheckedCreateWithoutStockTakesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutStockTakesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutStockTakesInput, VendorUncheckedUpdateWithoutStockTakesInput>
  }

  export type VendorUpdateWithoutStockTakesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutVendorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
    customers?: CustomerUpdateManyWithoutVendorNestedInput
    sales?: SaleUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutVendorNestedInput
    reports?: ReportUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutStockTakesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutVendorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutVendorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type UserUpsertWithoutStockTakesInput = {
    update: XOR<UserUpdateWithoutStockTakesInput, UserUncheckedUpdateWithoutStockTakesInput>
    create: XOR<UserCreateWithoutStockTakesInput, UserUncheckedCreateWithoutStockTakesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStockTakesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStockTakesInput, UserUncheckedUpdateWithoutStockTakesInput>
  }

  export type UserUpdateWithoutStockTakesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutUsersNestedInput
    cashierSchedule?: CashierScheduleUpdateOneWithoutUserNestedInput
    sales?: SaleUpdateManyWithoutCashierNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratorNestedInput
    productAssignments?: CashierProductAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStockTakesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashierSchedule?: CashierScheduleUncheckedUpdateOneWithoutUserNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCashierNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratorNestedInput
    productAssignments?: CashierProductAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StockTakeItemUpsertWithWhereUniqueWithoutStockTakeInput = {
    where: StockTakeItemWhereUniqueInput
    update: XOR<StockTakeItemUpdateWithoutStockTakeInput, StockTakeItemUncheckedUpdateWithoutStockTakeInput>
    create: XOR<StockTakeItemCreateWithoutStockTakeInput, StockTakeItemUncheckedCreateWithoutStockTakeInput>
  }

  export type StockTakeItemUpdateWithWhereUniqueWithoutStockTakeInput = {
    where: StockTakeItemWhereUniqueInput
    data: XOR<StockTakeItemUpdateWithoutStockTakeInput, StockTakeItemUncheckedUpdateWithoutStockTakeInput>
  }

  export type StockTakeItemUpdateManyWithWhereWithoutStockTakeInput = {
    where: StockTakeItemScalarWhereInput
    data: XOR<StockTakeItemUpdateManyMutationInput, StockTakeItemUncheckedUpdateManyWithoutStockTakeInput>
  }

  export type StockTakeCreateWithoutItemsInput = {
    id?: string
    location: string
    status?: $Enums.StockTakeStatus
    notes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutStockTakesInput
    creator: UserCreateNestedOneWithoutStockTakesInput
  }

  export type StockTakeUncheckedCreateWithoutItemsInput = {
    id?: string
    vendorId: string
    location: string
    status?: $Enums.StockTakeStatus
    notes?: string | null
    createdBy: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTakeCreateOrConnectWithoutItemsInput = {
    where: StockTakeWhereUniqueInput
    create: XOR<StockTakeCreateWithoutItemsInput, StockTakeUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutStockTakeItemsInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutProductsInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
    stockLocations?: ProductStockLocationCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    cashierAssignments?: CashierProductAssignmentCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStockTakeItemsInput = {
    id?: string
    vendorId: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    stockLocations?: ProductStockLocationUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    cashierAssignments?: CashierProductAssignmentUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStockTakeItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStockTakeItemsInput, ProductUncheckedCreateWithoutStockTakeItemsInput>
  }

  export type ProductVariantCreateWithoutStockTakeItemsInput = {
    id?: string
    name: string
    value: string
    priceModifier?: Decimal | DecimalJsLike | number | string
    stock?: number
    sku: string
    barcode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    stockLocations?: ProductStockLocationCreateNestedManyWithoutVariantInput
    saleItems?: SaleItemCreateNestedManyWithoutVariantInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutVariantInput
    stockMovements?: StockMovementCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutStockTakeItemsInput = {
    id?: string
    productId: string
    name: string
    value: string
    priceModifier?: Decimal | DecimalJsLike | number | string
    stock?: number
    sku: string
    barcode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockLocations?: ProductStockLocationUncheckedCreateNestedManyWithoutVariantInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutVariantInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutVariantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutStockTakeItemsInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutStockTakeItemsInput, ProductVariantUncheckedCreateWithoutStockTakeItemsInput>
  }

  export type StockTakeUpsertWithoutItemsInput = {
    update: XOR<StockTakeUpdateWithoutItemsInput, StockTakeUncheckedUpdateWithoutItemsInput>
    create: XOR<StockTakeCreateWithoutItemsInput, StockTakeUncheckedCreateWithoutItemsInput>
    where?: StockTakeWhereInput
  }

  export type StockTakeUpdateToOneWithWhereWithoutItemsInput = {
    where?: StockTakeWhereInput
    data: XOR<StockTakeUpdateWithoutItemsInput, StockTakeUncheckedUpdateWithoutItemsInput>
  }

  export type StockTakeUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStockTakeStatusFieldUpdateOperationsInput | $Enums.StockTakeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutStockTakesNestedInput
    creator?: UserUpdateOneRequiredWithoutStockTakesNestedInput
  }

  export type StockTakeUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStockTakeStatusFieldUpdateOperationsInput | $Enums.StockTakeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutStockTakeItemsInput = {
    update: XOR<ProductUpdateWithoutStockTakeItemsInput, ProductUncheckedUpdateWithoutStockTakeItemsInput>
    create: XOR<ProductCreateWithoutStockTakeItemsInput, ProductUncheckedCreateWithoutStockTakeItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStockTakeItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStockTakeItemsInput, ProductUncheckedUpdateWithoutStockTakeItemsInput>
  }

  export type ProductUpdateWithoutStockTakeItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutProductsNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
    stockLocations?: ProductStockLocationUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    cashierAssignments?: CashierProductAssignmentUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStockTakeItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    stockLocations?: ProductStockLocationUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    cashierAssignments?: CashierProductAssignmentUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductVariantUpsertWithoutStockTakeItemsInput = {
    update: XOR<ProductVariantUpdateWithoutStockTakeItemsInput, ProductVariantUncheckedUpdateWithoutStockTakeItemsInput>
    create: XOR<ProductVariantCreateWithoutStockTakeItemsInput, ProductVariantUncheckedCreateWithoutStockTakeItemsInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutStockTakeItemsInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutStockTakeItemsInput, ProductVariantUncheckedUpdateWithoutStockTakeItemsInput>
  }

  export type ProductVariantUpdateWithoutStockTakeItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priceModifier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    stockLocations?: ProductStockLocationUpdateManyWithoutVariantNestedInput
    saleItems?: SaleItemUpdateManyWithoutVariantNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutVariantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutStockTakeItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priceModifier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockLocations?: ProductStockLocationUncheckedUpdateManyWithoutVariantNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutVariantNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutVariantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type VendorCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutVendorInput
    products?: ProductCreateNestedManyWithoutVendorInput
    customers?: CustomerCreateNestedManyWithoutVendorInput
    sales?: SaleCreateNestedManyWithoutVendorInput
    suppliers?: SupplierCreateNestedManyWithoutVendorInput
    purchases?: PurchaseCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketCreateNestedManyWithoutVendorInput
    reports?: ReportCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    customers?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    sales?: SaleUncheckedCreateNestedManyWithoutVendorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutVendorInput
    reports?: ReportUncheckedCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutNotificationsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutNotificationsInput, VendorUncheckedCreateWithoutNotificationsInput>
  }

  export type VendorUpsertWithoutNotificationsInput = {
    update: XOR<VendorUpdateWithoutNotificationsInput, VendorUncheckedUpdateWithoutNotificationsInput>
    create: XOR<VendorCreateWithoutNotificationsInput, VendorUncheckedCreateWithoutNotificationsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutNotificationsInput, VendorUncheckedUpdateWithoutNotificationsInput>
  }

  export type VendorUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutVendorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
    customers?: CustomerUpdateManyWithoutVendorNestedInput
    sales?: SaleUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutVendorNestedInput
    reports?: ReportUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutVendorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutVendorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type VendorCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutVendorInput
    products?: ProductCreateNestedManyWithoutVendorInput
    customers?: CustomerCreateNestedManyWithoutVendorInput
    sales?: SaleCreateNestedManyWithoutVendorInput
    suppliers?: SupplierCreateNestedManyWithoutVendorInput
    purchases?: PurchaseCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeCreateNestedManyWithoutVendorInput
    notifications?: NotificationCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketCreateNestedManyWithoutVendorInput
    reports?: ReportCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    customers?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    sales?: SaleUncheckedCreateNestedManyWithoutVendorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutVendorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutVendorInput
    reports?: ReportUncheckedCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutAuditLogsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutAuditLogsInput, VendorUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutUsersInput
    cashierSchedule?: CashierScheduleCreateNestedOneWithoutUserInput
    sales?: SaleCreateNestedManyWithoutCashierInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    stockTakes?: StockTakeCreateNestedManyWithoutCreatorInput
    reports?: ReportCreateNestedManyWithoutGeneratorInput
    productAssignments?: CashierProductAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    vendorId?: string | null
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashierSchedule?: CashierScheduleUncheckedCreateNestedOneWithoutUserInput
    sales?: SaleUncheckedCreateNestedManyWithoutCashierInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutCreatorInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratorInput
    productAssignments?: CashierProductAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type VendorUpsertWithoutAuditLogsInput = {
    update: XOR<VendorUpdateWithoutAuditLogsInput, VendorUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<VendorCreateWithoutAuditLogsInput, VendorUncheckedCreateWithoutAuditLogsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutAuditLogsInput, VendorUncheckedUpdateWithoutAuditLogsInput>
  }

  export type VendorUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutVendorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
    customers?: CustomerUpdateManyWithoutVendorNestedInput
    sales?: SaleUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutVendorNestedInput
    reports?: ReportUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutVendorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutVendorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutUsersNestedInput
    cashierSchedule?: CashierScheduleUpdateOneWithoutUserNestedInput
    sales?: SaleUpdateManyWithoutCashierNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutCreatorNestedInput
    reports?: ReportUpdateManyWithoutGeneratorNestedInput
    productAssignments?: CashierProductAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashierSchedule?: CashierScheduleUncheckedUpdateOneWithoutUserNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCashierNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutCreatorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratorNestedInput
    productAssignments?: CashierProductAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VendorCreateWithoutSupportTicketsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutVendorInput
    products?: ProductCreateNestedManyWithoutVendorInput
    customers?: CustomerCreateNestedManyWithoutVendorInput
    sales?: SaleCreateNestedManyWithoutVendorInput
    suppliers?: SupplierCreateNestedManyWithoutVendorInput
    purchases?: PurchaseCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeCreateNestedManyWithoutVendorInput
    notifications?: NotificationCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogCreateNestedManyWithoutVendorInput
    reports?: ReportCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutSupportTicketsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    customers?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    sales?: SaleUncheckedCreateNestedManyWithoutVendorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutVendorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVendorInput
    reports?: ReportUncheckedCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutSupportTicketsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutSupportTicketsInput, VendorUncheckedCreateWithoutSupportTicketsInput>
  }

  export type VendorUpsertWithoutSupportTicketsInput = {
    update: XOR<VendorUpdateWithoutSupportTicketsInput, VendorUncheckedUpdateWithoutSupportTicketsInput>
    create: XOR<VendorCreateWithoutSupportTicketsInput, VendorUncheckedCreateWithoutSupportTicketsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutSupportTicketsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutSupportTicketsInput, VendorUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type VendorUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutVendorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
    customers?: CustomerUpdateManyWithoutVendorNestedInput
    sales?: SaleUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVendorNestedInput
    reports?: ReportUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutVendorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVendorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type VendorCreateWithoutReportsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutVendorInput
    products?: ProductCreateNestedManyWithoutVendorInput
    customers?: CustomerCreateNestedManyWithoutVendorInput
    sales?: SaleCreateNestedManyWithoutVendorInput
    suppliers?: SupplierCreateNestedManyWithoutVendorInput
    purchases?: PurchaseCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeCreateNestedManyWithoutVendorInput
    notifications?: NotificationCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    businessType?: string | null
    subscriptionPlan?: $Enums.SubscriptionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    subscriptionExpiry?: Date | string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    customers?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    sales?: SaleUncheckedCreateNestedManyWithoutVendorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVendorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutVendorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutVendorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVendorInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutVendorInput
    vendorSettings?: VendorSettingsUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutReportsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutReportsInput, VendorUncheckedCreateWithoutReportsInput>
  }

  export type UserCreateWithoutReportsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutUsersInput
    cashierSchedule?: CashierScheduleCreateNestedOneWithoutUserInput
    sales?: SaleCreateNestedManyWithoutCashierInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    stockTakes?: StockTakeCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    productAssignments?: CashierProductAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    vendorId?: string | null
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashierSchedule?: CashierScheduleUncheckedCreateNestedOneWithoutUserInput
    sales?: SaleUncheckedCreateNestedManyWithoutCashierInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
    stockTakes?: StockTakeUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    productAssignments?: CashierProductAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
  }

  export type VendorUpsertWithoutReportsInput = {
    update: XOR<VendorUpdateWithoutReportsInput, VendorUncheckedUpdateWithoutReportsInput>
    create: XOR<VendorCreateWithoutReportsInput, VendorUncheckedCreateWithoutReportsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutReportsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutReportsInput, VendorUncheckedUpdateWithoutReportsInput>
  }

  export type VendorUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutVendorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
    customers?: CustomerUpdateManyWithoutVendorNestedInput
    sales?: SaleUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutVendorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutVendorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutVendorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVendorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVendorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutVendorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVendorNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutVendorNestedInput
    vendorSettings?: VendorSettingsUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type UserUpsertWithoutReportsInput = {
    update: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutUsersNestedInput
    cashierSchedule?: CashierScheduleUpdateOneWithoutUserNestedInput
    sales?: SaleUpdateManyWithoutCashierNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    productAssignments?: CashierProductAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashierSchedule?: CashierScheduleUncheckedUpdateOneWithoutUserNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCashierNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    productAssignments?: CashierProductAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyVendorInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    name: string
    avatar?: string | null
    isActive?: boolean
    terminalId?: string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyVendorInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    barcode?: string | null
    category?: string | null
    brand?: string | null
    price: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    totalStock?: number
    minStock?: number
    maxStock?: number
    unit?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiryDate?: Date | string | null
    trackExpiry?: boolean
    trackSerial?: boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateManyVendorInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    visitCount?: number
    lastVisit?: Date | string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleCreateManyVendorInput = {
    id?: string
    cashierId: string
    terminalId: string
    customerId?: string | null
    receiptNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paid: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.SaleStatus
    refundAmount?: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsUsed?: number
    notes?: string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierCreateManyVendorInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    paymentTerms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateManyVendorInput = {
    id?: string
    supplierId: string
    purchaseNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockMovementCreateManyVendorInput = {
    id?: string
    productId: string
    variantId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    referenceType?: string | null
    referenceId?: string | null
    referenceNumber?: string | null
    locationFrom?: string | null
    locationTo?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type StockTakeCreateManyVendorInput = {
    id?: string
    location: string
    status?: $Enums.StockTakeStatus
    notes?: string | null
    createdBy: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyVendorInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateManyVendorInput = {
    id?: string
    userId: string
    action: string
    resource: string
    resourceId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SupportTicketCreateManyVendorInput = {
    id?: string
    vendorName: string
    subject: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateManyVendorInput = {
    id?: string
    type: $Enums.ReportType
    period: $Enums.ReportPeriod
    startDate: Date | string
    endDate: Date | string
    data: JsonNullValueInput | InputJsonValue
    generatedBy: string
    generatedAt?: Date | string
  }

  export type UserUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashierSchedule?: CashierScheduleUpdateOneWithoutUserNestedInput
    sales?: SaleUpdateManyWithoutCashierNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    stockTakes?: StockTakeUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratorNestedInput
    productAssignments?: CashierProductAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashierSchedule?: CashierScheduleUncheckedUpdateOneWithoutUserNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCashierNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
    stockTakes?: StockTakeUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratorNestedInput
    productAssignments?: CashierProductAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedLocations?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
    stockLocations?: ProductStockLocationUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    stockTakeItems?: StockTakeItemUpdateManyWithoutProductNestedInput
    cashierAssignments?: CashierProductAssignmentUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    stockLocations?: ProductStockLocationUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    stockTakeItems?: StockTakeItemUncheckedUpdateManyWithoutProductNestedInput
    cashierAssignments?: CashierProductAssignmentUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalStock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    trackSerial?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    visitCount?: IntFieldUpdateOperationsInput | number
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    visitCount?: IntFieldUpdateOperationsInput | number
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    visitCount?: IntFieldUpdateOperationsInput | number
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsUsed?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashier?: UserUpdateOneRequiredWithoutSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsUsed?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsUsed?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchasesNestedInput
    items?: PurchaseItemUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    locationFrom?: NullableStringFieldUpdateOperationsInput | string | null
    locationTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockMovementsNestedInput
    variant?: ProductVariantUpdateOneWithoutStockMovementsNestedInput
    creator?: UserUpdateOneRequiredWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    locationFrom?: NullableStringFieldUpdateOperationsInput | string | null
    locationTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    locationFrom?: NullableStringFieldUpdateOperationsInput | string | null
    locationTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTakeUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStockTakeStatusFieldUpdateOperationsInput | $Enums.StockTakeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutStockTakesNestedInput
    items?: StockTakeItemUpdateManyWithoutStockTakeNestedInput
  }

  export type StockTakeUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStockTakeStatusFieldUpdateOperationsInput | $Enums.StockTakeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: StockTakeItemUncheckedUpdateManyWithoutStockTakeNestedInput
  }

  export type StockTakeUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStockTakeStatusFieldUpdateOperationsInput | $Enums.StockTakeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorName?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorName?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorName?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    period?: EnumReportPeriodFieldUpdateOperationsInput | $Enums.ReportPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generator?: UserUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    period?: EnumReportPeriodFieldUpdateOperationsInput | $Enums.ReportPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    generatedBy?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    period?: EnumReportPeriodFieldUpdateOperationsInput | $Enums.ReportPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    generatedBy?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateManyCashierInput = {
    id?: string
    vendorId: string
    terminalId: string
    customerId?: string | null
    receiptNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paid: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.SaleStatus
    refundAmount?: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsUsed?: number
    notes?: string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockMovementCreateManyCreatorInput = {
    id?: string
    vendorId: string
    productId: string
    variantId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    referenceType?: string | null
    referenceId?: string | null
    referenceNumber?: string | null
    locationFrom?: string | null
    locationTo?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type StockTakeCreateManyCreatorInput = {
    id?: string
    vendorId: string
    location: string
    status?: $Enums.StockTakeStatus
    notes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    vendorId: string
    action: string
    resource: string
    resourceId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ReportCreateManyGeneratorInput = {
    id?: string
    vendorId: string
    type: $Enums.ReportType
    period: $Enums.ReportPeriod
    startDate: Date | string
    endDate: Date | string
    data: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type CashierProductAssignmentCreateManyUserInput = {
    id?: string
    productId: string
    assignedAt?: Date | string
  }

  export type SaleUpdateWithoutCashierInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsUsed?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutCashierInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsUsed?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutCashierInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsUsed?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    locationFrom?: NullableStringFieldUpdateOperationsInput | string | null
    locationTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutStockMovementsNestedInput
    product?: ProductUpdateOneRequiredWithoutStockMovementsNestedInput
    variant?: ProductVariantUpdateOneWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    locationFrom?: NullableStringFieldUpdateOperationsInput | string | null
    locationTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    locationFrom?: NullableStringFieldUpdateOperationsInput | string | null
    locationTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTakeUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStockTakeStatusFieldUpdateOperationsInput | $Enums.StockTakeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutStockTakesNestedInput
    items?: StockTakeItemUpdateManyWithoutStockTakeNestedInput
  }

  export type StockTakeUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStockTakeStatusFieldUpdateOperationsInput | $Enums.StockTakeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: StockTakeItemUncheckedUpdateManyWithoutStockTakeNestedInput
  }

  export type StockTakeUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStockTakeStatusFieldUpdateOperationsInput | $Enums.StockTakeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutGeneratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    period?: EnumReportPeriodFieldUpdateOperationsInput | $Enums.ReportPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutGeneratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    period?: EnumReportPeriodFieldUpdateOperationsInput | $Enums.ReportPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutGeneratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    period?: EnumReportPeriodFieldUpdateOperationsInput | $Enums.ReportPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierProductAssignmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutCashierAssignmentsNestedInput
  }

  export type CashierProductAssignmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierProductAssignmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantCreateManyProductInput = {
    id?: string
    name: string
    value: string
    priceModifier?: Decimal | DecimalJsLike | number | string
    stock?: number
    sku: string
    barcode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductStockLocationCreateManyProductInput = {
    id?: string
    variantId?: string | null
    locationName: string
    quantity?: number
    reservedQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleItemCreateManyProductInput = {
    id?: string
    saleId: string
    variantId?: string | null
    name: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PurchaseItemCreateManyProductInput = {
    id?: string
    purchaseId: string
    variantId?: string | null
    name: string
    sku: string
    costPrice: Decimal | DecimalJsLike | number | string
    quantity: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type StockMovementCreateManyProductInput = {
    id?: string
    vendorId: string
    variantId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    referenceType?: string | null
    referenceId?: string | null
    referenceNumber?: string | null
    locationFrom?: string | null
    locationTo?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type StockTakeItemCreateManyProductInput = {
    id?: string
    stockTakeId: string
    variantId?: string | null
    productName: string
    sku: string
    expectedQuantity: number
    countedQuantity: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type CashierProductAssignmentCreateManyProductInput = {
    id?: string
    userId: string
    assignedAt?: Date | string
  }

  export type ProductVariantUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priceModifier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockLocations?: ProductStockLocationUpdateManyWithoutVariantNestedInput
    saleItems?: SaleItemUpdateManyWithoutVariantNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutVariantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutVariantNestedInput
    stockTakeItems?: StockTakeItemUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priceModifier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockLocations?: ProductStockLocationUncheckedUpdateManyWithoutVariantNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutVariantNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutVariantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutVariantNestedInput
    stockTakeItems?: StockTakeItemUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priceModifier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockLocationUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variant?: ProductVariantUpdateOneWithoutStockLocationsNestedInput
  }

  export type ProductStockLocationUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockLocationUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutItemsNestedInput
    variant?: ProductVariantUpdateOneWithoutSaleItemsNestedInput
  }

  export type SaleItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutItemsNestedInput
    variant?: ProductVariantUpdateOneWithoutPurchaseItemsNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    locationFrom?: NullableStringFieldUpdateOperationsInput | string | null
    locationTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutStockMovementsNestedInput
    variant?: ProductVariantUpdateOneWithoutStockMovementsNestedInput
    creator?: UserUpdateOneRequiredWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    locationFrom?: NullableStringFieldUpdateOperationsInput | string | null
    locationTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    locationFrom?: NullableStringFieldUpdateOperationsInput | string | null
    locationTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTakeItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockTake?: StockTakeUpdateOneRequiredWithoutItemsNestedInput
    variant?: ProductVariantUpdateOneWithoutStockTakeItemsNestedInput
  }

  export type StockTakeItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockTakeId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTakeItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockTakeId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierProductAssignmentUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProductAssignmentsNestedInput
  }

  export type CashierProductAssignmentUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashierProductAssignmentUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockLocationCreateManyVariantInput = {
    id?: string
    productId: string
    locationName: string
    quantity?: number
    reservedQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleItemCreateManyVariantInput = {
    id?: string
    saleId: string
    productId: string
    name: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PurchaseItemCreateManyVariantInput = {
    id?: string
    purchaseId: string
    productId: string
    name: string
    sku: string
    costPrice: Decimal | DecimalJsLike | number | string
    quantity: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type StockMovementCreateManyVariantInput = {
    id?: string
    vendorId: string
    productId: string
    movementType: $Enums.StockMovementType
    quantity: number
    referenceType?: string | null
    referenceId?: string | null
    referenceNumber?: string | null
    locationFrom?: string | null
    locationTo?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type StockTakeItemCreateManyVariantInput = {
    id?: string
    stockTakeId: string
    productId: string
    productName: string
    sku: string
    expectedQuantity: number
    countedQuantity: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type ProductStockLocationUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockLocationsNestedInput
  }

  export type ProductStockLocationUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockLocationUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutSaleItemsNestedInput
  }

  export type SaleItemUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchaseItemsNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    locationFrom?: NullableStringFieldUpdateOperationsInput | string | null
    locationTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutStockMovementsNestedInput
    product?: ProductUpdateOneRequiredWithoutStockMovementsNestedInput
    creator?: UserUpdateOneRequiredWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    locationFrom?: NullableStringFieldUpdateOperationsInput | string | null
    locationTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    locationFrom?: NullableStringFieldUpdateOperationsInput | string | null
    locationTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTakeItemUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockTake?: StockTakeUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutStockTakeItemsNestedInput
  }

  export type StockTakeItemUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockTakeId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTakeItemUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockTakeId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateManyCustomerInput = {
    id?: string
    vendorId: string
    cashierId: string
    terminalId: string
    receiptNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paid: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.SaleStatus
    refundAmount?: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsUsed?: number
    notes?: string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsUsed?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutSalesNestedInput
    cashier?: UserUpdateOneRequiredWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsUsed?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsUsed?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemCreateManySaleInput = {
    id?: string
    productId: string
    variantId?: string | null
    name: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleItemUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSaleItemsNestedInput
    variant?: ProductVariantUpdateOneWithoutSaleItemsNestedInput
  }

  export type SaleItemUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateManySupplierInput = {
    id?: string
    vendorId: string
    purchaseNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchasesNestedInput
    items?: PurchaseItemUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemCreateManyPurchaseInput = {
    id?: string
    productId: string
    variantId?: string | null
    name: string
    sku: string
    costPrice: Decimal | DecimalJsLike | number | string
    quantity: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PurchaseItemUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPurchaseItemsNestedInput
    variant?: ProductVariantUpdateOneWithoutPurchaseItemsNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUncheckedUpdateManyWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTakeItemCreateManyStockTakeInput = {
    id?: string
    productId: string
    variantId?: string | null
    productName: string
    sku: string
    expectedQuantity: number
    countedQuantity: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type StockTakeItemUpdateWithoutStockTakeInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockTakeItemsNestedInput
    variant?: ProductVariantUpdateOneWithoutStockTakeItemsNestedInput
  }

  export type StockTakeItemUncheckedUpdateWithoutStockTakeInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTakeItemUncheckedUpdateManyWithoutStockTakeInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use VendorCountOutputTypeDefaultArgs instead
     */
    export type VendorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductVariantCountOutputTypeDefaultArgs instead
     */
    export type ProductVariantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductVariantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerCountOutputTypeDefaultArgs instead
     */
    export type CustomerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleCountOutputTypeDefaultArgs instead
     */
    export type SaleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierCountOutputTypeDefaultArgs instead
     */
    export type SupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseCountOutputTypeDefaultArgs instead
     */
    export type PurchaseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockTakeCountOutputTypeDefaultArgs instead
     */
    export type StockTakeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockTakeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendorDefaultArgs instead
     */
    export type VendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendorSettingsDefaultArgs instead
     */
    export type VendorSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CashierScheduleDefaultArgs instead
     */
    export type CashierScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CashierScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductVariantDefaultArgs instead
     */
    export type ProductVariantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductVariantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductStockLocationDefaultArgs instead
     */
    export type ProductStockLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductStockLocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CashierProductAssignmentDefaultArgs instead
     */
    export type CashierProductAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CashierProductAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerDefaultArgs instead
     */
    export type CustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleDefaultArgs instead
     */
    export type SaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleItemDefaultArgs instead
     */
    export type SaleItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierDefaultArgs instead
     */
    export type SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseDefaultArgs instead
     */
    export type PurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseItemDefaultArgs instead
     */
    export type PurchaseItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockMovementDefaultArgs instead
     */
    export type StockMovementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockMovementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockTakeDefaultArgs instead
     */
    export type StockTakeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockTakeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockTakeItemDefaultArgs instead
     */
    export type StockTakeItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockTakeItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupportTicketDefaultArgs instead
     */
    export type SupportTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupportTicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PricingPlanDefaultArgs instead
     */
    export type PricingPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PricingPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemSettingsDefaultArgs instead
     */
    export type SystemSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemSettingsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}